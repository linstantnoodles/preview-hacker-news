<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>The HTML5 Herald</title>
  <meta name="description" content="The HTML5 Herald">
  <meta name="author" content="SitePoint">

  <link rel="stylesheet" href="css/styles.css?v=1.0">

</head>

<body>
  <script type="text/javascript">

   /*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
( function( global, factory ) {

  "use strict";

  if ( typeof module === "object" && typeof module.exports === "object" ) {

    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ?
      factory( global, true ) :
      function( w ) {
        if ( !w.document ) {
          throw new Error( "jQuery requires a window with a document" );
        }
        return factory( w );
      };
  } else {
    factory( global );
  }

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
  return arr.flat.call( array );
} : function( array ) {
  return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
    return obj != null && obj === obj.window;
  };


var document = window.document;



  var preservedScriptAttributes = {
    type: true,
    src: true,
    nonce: true,
    noModule: true
  };

  function DOMEval( code, node, doc ) {
    doc = doc || document;

    var i, val,
      script = doc.createElement( "script" );

    script.text = code;
    if ( node ) {
      for ( i in preservedScriptAttributes ) {

        // Support: Firefox 64+, Edge 18+
        // Some browsers don't support the "nonce" property on scripts.
        // On the other hand, just using `getAttribute` is not enough as
        // the `nonce` attribute is reset to an empty string whenever it
        // becomes browsing-context connected.
        // See https://github.com/whatwg/html/issues/2369
        // See https://html.spec.whatwg.org/#nonce-attributes
        // The `node.getAttribute` check was added for the sake of
        // `jQuery.globalEval` so that it can fake a nonce-containing node
        // via an object.
        val = node[ i ] || node.getAttribute && node.getAttribute( i );
        if ( val ) {
          script.setAttribute( i, val );
        }
      }
    }
    doc.head.appendChild( script ).parentNode.removeChild( script );
  }


function toType( obj ) {
  if ( obj == null ) {
    return obj + "";
  }

  // Support: Android <=2.3 only (functionish RegExp)
  return typeof obj === "object" || typeof obj === "function" ?
    class2type[ toString.call( obj ) ] || "object" :
    typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
  version = "3.5.1",

  // Define a local copy of jQuery
  jQuery = function( selector, context ) {

    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init( selector, context );
  };

jQuery.fn = jQuery.prototype = {

  // The current version of jQuery being used
  jquery: version,

  constructor: jQuery,

  // The default length of a jQuery object is 0
  length: 0,

  toArray: function() {
    return slice.call( this );
  },

  // Get the Nth element in the matched element set OR
  // Get the whole matched element set as a clean array
  get: function( num ) {

    // Return all the elements in a clean array
    if ( num == null ) {
      return slice.call( this );
    }

    // Return just the one element from the set
    return num < 0 ? this[ num + this.length ] : this[ num ];
  },

  // Take an array of elements and push it onto the stack
  // (returning the new matched element set)
  pushStack: function( elems ) {

    // Build a new jQuery matched element set
    var ret = jQuery.merge( this.constructor(), elems );

    // Add the old object onto the stack (as a reference)
    ret.prevObject = this;

    // Return the newly-formed element set
    return ret;
  },

  // Execute a callback for every element in the matched set.
  each: function( callback ) {
    return jQuery.each( this, callback );
  },

  map: function( callback ) {
    return this.pushStack( jQuery.map( this, function( elem, i ) {
      return callback.call( elem, i, elem );
    } ) );
  },

  slice: function() {
    return this.pushStack( slice.apply( this, arguments ) );
  },

  first: function() {
    return this.eq( 0 );
  },

  last: function() {
    return this.eq( -1 );
  },

  even: function() {
    return this.pushStack( jQuery.grep( this, function( _elem, i ) {
      return ( i + 1 ) % 2;
    } ) );
  },

  odd: function() {
    return this.pushStack( jQuery.grep( this, function( _elem, i ) {
      return i % 2;
    } ) );
  },

  eq: function( i ) {
    var len = this.length,
      j = +i + ( i < 0 ? len : 0 );
    return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
  },

  end: function() {
    return this.prevObject || this.constructor();
  },

  // For internal use only.
  // Behaves like an Array's method, not like a jQuery method.
  push: push,
  sort: arr.sort,
  splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
  var options, name, src, copy, copyIsArray, clone,
    target = arguments[ 0 ] || {},
    i = 1,
    length = arguments.length,
    deep = false;

  // Handle a deep copy situation
  if ( typeof target === "boolean" ) {
    deep = target;

    // Skip the boolean and the target
    target = arguments[ i ] || {};
    i++;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if ( typeof target !== "object" && !isFunction( target ) ) {
    target = {};
  }

  // Extend jQuery itself if only one argument is passed
  if ( i === length ) {
    target = this;
    i--;
  }

  for ( ; i < length; i++ ) {

    // Only deal with non-null/undefined values
    if ( ( options = arguments[ i ] ) != null ) {

      // Extend the base object
      for ( name in options ) {
        copy = options[ name ];

        // Prevent Object.prototype pollution
        // Prevent never-ending loop
        if ( name === "__proto__" || target === copy ) {
          continue;
        }

        // Recurse if we're merging plain objects or arrays
        if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
          ( copyIsArray = Array.isArray( copy ) ) ) ) {
          src = target[ name ];

          // Ensure proper type for the source value
          if ( copyIsArray && !Array.isArray( src ) ) {
            clone = [];
          } else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
            clone = {};
          } else {
            clone = src;
          }
          copyIsArray = false;

          // Never move original objects, clone them
          target[ name ] = jQuery.extend( deep, clone, copy );

        // Don't bring in undefined values
        } else if ( copy !== undefined ) {
          target[ name ] = copy;
        }
      }
    }
  }

  // Return the modified object
  return target;
};

jQuery.extend( {

  // Unique for each copy of jQuery on the page
  expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

  // Assume jQuery is ready without the ready module
  isReady: true,

  error: function( msg ) {
    throw new Error( msg );
  },

  noop: function() {},

  isPlainObject: function( obj ) {
    var proto, Ctor;

    // Detect obvious negatives
    // Use toString instead of jQuery.type to catch host objects
    if ( !obj || toString.call( obj ) !== "[object Object]" ) {
      return false;
    }

    proto = getProto( obj );

    // Objects with no prototype (e.g., `Object.create( null )`) are plain
    if ( !proto ) {
      return true;
    }

    // Objects with prototype are plain iff they were constructed by a global Object function
    Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
    return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
  },

  isEmptyObject: function( obj ) {
    var name;

    for ( name in obj ) {
      return false;
    }
    return true;
  },

  // Evaluates a script in a provided context; falls back to the global one
  // if not specified.
  globalEval: function( code, options, doc ) {
    DOMEval( code, { nonce: options && options.nonce }, doc );
  },

  each: function( obj, callback ) {
    var length, i = 0;

    if ( isArrayLike( obj ) ) {
      length = obj.length;
      for ( ; i < length; i++ ) {
        if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
          break;
        }
      }
    } else {
      for ( i in obj ) {
        if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
          break;
        }
      }
    }

    return obj;
  },

  // results is for internal usage only
  makeArray: function( arr, results ) {
    var ret = results || [];

    if ( arr != null ) {
      if ( isArrayLike( Object( arr ) ) ) {
        jQuery.merge( ret,
          typeof arr === "string" ?
          [ arr ] : arr
        );
      } else {
        push.call( ret, arr );
      }
    }

    return ret;
  },

  inArray: function( elem, arr, i ) {
    return arr == null ? -1 : indexOf.call( arr, elem, i );
  },

  // Support: Android <=4.0 only, PhantomJS 1 only
  // push.apply(_, arraylike) throws on ancient WebKit
  merge: function( first, second ) {
    var len = +second.length,
      j = 0,
      i = first.length;

    for ( ; j < len; j++ ) {
      first[ i++ ] = second[ j ];
    }

    first.length = i;

    return first;
  },

  grep: function( elems, callback, invert ) {
    var callbackInverse,
      matches = [],
      i = 0,
      length = elems.length,
      callbackExpect = !invert;

    // Go through the array, only saving the items
    // that pass the validator function
    for ( ; i < length; i++ ) {
      callbackInverse = !callback( elems[ i ], i );
      if ( callbackInverse !== callbackExpect ) {
        matches.push( elems[ i ] );
      }
    }

    return matches;
  },

  // arg is for internal usage only
  map: function( elems, callback, arg ) {
    var length, value,
      i = 0,
      ret = [];

    // Go through the array, translating each of the items to their new values
    if ( isArrayLike( elems ) ) {
      length = elems.length;
      for ( ; i < length; i++ ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
          ret.push( value );
        }
      }

    // Go through every key on the object,
    } else {
      for ( i in elems ) {
        value = callback( elems[ i ], i, arg );

        if ( value != null ) {
          ret.push( value );
        }
      }
    }

    // Flatten any nested arrays
    return flat( ret );
  },

  // A global GUID counter for objects
  guid: 1,

  // jQuery.support is not used in Core but other projects attach their
  // properties to it so it needs to exist.
  support: support
} );

if ( typeof Symbol === "function" ) {
  jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
  class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

  // Support: real iOS 8.2 only (not reproducible in simulator)
  // `in` check used to prevent JIT error (gh-2145)
  // hasOwn isn't used here due to false negatives
  // regarding Nodelist length in IE
  var length = !!obj && "length" in obj && obj.length,
    type = toType( obj );

  if ( isFunction( obj ) || isWindow( obj ) ) {
    return false;
  }

  return type === "array" || length === 0 ||
    typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
  support,
  Expr,
  getText,
  isXML,
  tokenize,
  compile,
  select,
  outermostContext,
  sortInput,
  hasDuplicate,

  // Local document vars
  setDocument,
  document,
  docElem,
  documentIsHTML,
  rbuggyQSA,
  rbuggyMatches,
  matches,
  contains,

  // Instance-specific data
  expando = "sizzle" + 1 * new Date(),
  preferredDoc = window.document,
  dirruns = 0,
  done = 0,
  classCache = createCache(),
  tokenCache = createCache(),
  compilerCache = createCache(),
  nonnativeSelectorCache = createCache(),
  sortOrder = function( a, b ) {
    if ( a === b ) {
      hasDuplicate = true;
    }
    return 0;
  },

  // Instance methods
  hasOwn = ( {} ).hasOwnProperty,
  arr = [],
  pop = arr.pop,
  pushNative = arr.push,
  push = arr.push,
  slice = arr.slice,

  // Use a stripped-down indexOf as it's faster than native
  // https://jsperf.com/thor-indexof-vs-for/5
  indexOf = function( list, elem ) {
    var i = 0,
      len = list.length;
    for ( ; i < len; i++ ) {
      if ( list[ i ] === elem ) {
        return i;
      }
    }
    return -1;
  },

  booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
    "ismap|loop|multiple|open|readonly|required|scoped",

  // Regular expressions

  // http://www.w3.org/TR/css3-selectors/#whitespace
  whitespace = "[\\x20\\t\\r\\n\\f]",

  // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
  identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
    "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

  // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
  attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

    // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace +

    // "Attribute values must be CSS identifiers [capture 5]
    // or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
    whitespace + "*\\]",

  pseudos = ":(" + identifier + ")(?:\\((" +

    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

    // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

    // 3. anything else (capture 2)
    ".*" +
    ")\\)|)",

  // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
  rwhitespace = new RegExp( whitespace + "+", "g" ),
  rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
    whitespace + "+$", "g" ),

  rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
  rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
    "*" ),
  rdescend = new RegExp( whitespace + "|>" ),

  rpseudo = new RegExp( pseudos ),
  ridentifier = new RegExp( "^" + identifier + "$" ),

  matchExpr = {
    "ID": new RegExp( "^#(" + identifier + ")" ),
    "CLASS": new RegExp( "^\\.(" + identifier + ")" ),
    "TAG": new RegExp( "^(" + identifier + "|[*])" ),
    "ATTR": new RegExp( "^" + attributes ),
    "PSEUDO": new RegExp( "^" + pseudos ),
    "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
      whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
      whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
    "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

    // For use in libraries implementing .is()
    // We use this for POS matching in `select`
    "needsContext": new RegExp( "^" + whitespace +
      "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
      "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
  },

  rhtml = /HTML$/i,
  rinputs = /^(?:input|select|textarea|button)$/i,
  rheader = /^h\d$/i,

  rnative = /^[^{]+\{\s*\[native \w/,

  // Easily-parseable/retrievable ID or TAG or CLASS selectors
  rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

  rsibling = /[+~]/,

  // CSS escapes
  // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
  runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
  funescape = function( escape, nonHex ) {
    var high = "0x" + escape.slice( 1 ) - 0x10000;

    return nonHex ?

      // Strip the backslash prefix from a non-hex escape sequence
      nonHex :

      // Replace a hexadecimal escape sequence with the encoded Unicode code point
      // Support: IE <=11+
      // For values outside the Basic Multilingual Plane (BMP), manually construct a
      // surrogate pair
      high < 0 ?
        String.fromCharCode( high + 0x10000 ) :
        String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
  },

  // CSS string/identifier serialization
  // https://drafts.csswg.org/cssom/#common-serializing-idioms
  rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
  fcssescape = function( ch, asCodePoint ) {
    if ( asCodePoint ) {

      // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
      if ( ch === "\0" ) {
        return "\uFFFD";
      }

      // Control characters and (dependent upon position) numbers get escaped as code points
      return ch.slice( 0, -1 ) + "\\" +
        ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
    }

    // Other potentially-special ASCII characters get backslash-escaped
    return "\\" + ch;
  },

  // Used for iframes
  // See setDocument()
  // Removing the function wrapper causes a "Permission Denied"
  // error in IE
  unloadHandler = function() {
    setDocument();
  },

  inDisabledFieldset = addCombinator(
    function( elem ) {
      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    },
    { dir: "parentNode", next: "legend" }
  );

// Optimize for push.apply( _, NodeList )
try {
  push.apply(
    ( arr = slice.call( preferredDoc.childNodes ) ),
    preferredDoc.childNodes
  );

  // Support: Android<4.0
  // Detect silently failing push.apply
  // eslint-disable-next-line no-unused-expressions
  arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
  push = { apply: arr.length ?

    // Leverage slice if possible
    function( target, els ) {
      pushNative.apply( target, slice.call( els ) );
    } :

    // Support: IE<9
    // Otherwise append directly
    function( target, els ) {
      var j = target.length,
        i = 0;

      // Can't trust NodeList.length
      while ( ( target[ j++ ] = els[ i++ ] ) ) {}
      target.length = j - 1;
    }
  };
}

function Sizzle( selector, context, results, seed ) {
  var m, i, elem, nid, match, groups, newSelector,
    newContext = context && context.ownerDocument,

    // nodeType defaults to 9, since context defaults to document
    nodeType = context ? context.nodeType : 9;

  results = results || [];

  // Return early from calls with invalid selector or context
  if ( typeof selector !== "string" || !selector ||
    nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

    return results;
  }

  // Try to shortcut find operations (as opposed to filters) in HTML documents
  if ( !seed ) {
    setDocument( context );
    context = context || document;

    if ( documentIsHTML ) {

      // If the selector is sufficiently simple, try using a "get*By*" DOM method
      // (excepting DocumentFragment context, where the methods don't exist)
      if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

        // ID selector
        if ( ( m = match[ 1 ] ) ) {

          // Document context
          if ( nodeType === 9 ) {
            if ( ( elem = context.getElementById( m ) ) ) {

              // Support: IE, Opera, Webkit
              // TODO: identify versions
              // getElementById can match elements by name instead of ID
              if ( elem.id === m ) {
                results.push( elem );
                return results;
              }
            } else {
              return results;
            }

          // Element context
          } else {

            // Support: IE, Opera, Webkit
            // TODO: identify versions
            // getElementById can match elements by name instead of ID
            if ( newContext && ( elem = newContext.getElementById( m ) ) &&
              contains( context, elem ) &&
              elem.id === m ) {

              results.push( elem );
              return results;
            }
          }

        // Type selector
        } else if ( match[ 2 ] ) {
          push.apply( results, context.getElementsByTagName( selector ) );
          return results;

        // Class selector
        } else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
          context.getElementsByClassName ) {

          push.apply( results, context.getElementsByClassName( m ) );
          return results;
        }
      }

      // Take advantage of querySelectorAll
      if ( support.qsa &&
        !nonnativeSelectorCache[ selector + " " ] &&
        ( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

        // Support: IE 8 only
        // Exclude object elements
        ( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

        newSelector = selector;
        newContext = context;

        // qSA considers elements outside a scoping root when evaluating child or
        // descendant combinators, which is not what we want.
        // In such cases, we work around the behavior by prefixing every selector in the
        // list with an ID selector referencing the scope context.
        // The technique has to be used as well when a leading combinator is used
        // as such selectors are not recognized by querySelectorAll.
        // Thanks to Andrew Dupont for this technique.
        if ( nodeType === 1 &&
          ( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

          // Expand context for sibling selectors
          newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
            context;

          // We can use :scope instead of the ID hack if the browser
          // supports it & if we're not changing the context.
          if ( newContext !== context || !support.scope ) {

            // Capture the context ID, setting it first if necessary
            if ( ( nid = context.getAttribute( "id" ) ) ) {
              nid = nid.replace( rcssescape, fcssescape );
            } else {
              context.setAttribute( "id", ( nid = expando ) );
            }
          }

          // Prefix every selector in the list
          groups = tokenize( selector );
          i = groups.length;
          while ( i-- ) {
            groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
              toSelector( groups[ i ] );
          }
          newSelector = groups.join( "," );
        }

        try {
          push.apply( results,
            newContext.querySelectorAll( newSelector )
          );
          return results;
        } catch ( qsaError ) {
          nonnativeSelectorCache( selector, true );
        } finally {
          if ( nid === expando ) {
            context.removeAttribute( "id" );
          }
        }
      }
    }
  }

  // All others
  return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *  deleting the oldest entry
 */
function createCache() {
  var keys = [];

  function cache( key, value ) {

    // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
    if ( keys.push( key + " " ) > Expr.cacheLength ) {

      // Only keep the most recent entries
      delete cache[ keys.shift() ];
    }
    return ( cache[ key + " " ] = value );
  }
  return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
  fn[ expando ] = true;
  return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
  var el = document.createElement( "fieldset" );

  try {
    return !!fn( el );
  } catch ( e ) {
    return false;
  } finally {

    // Remove from its parent by default
    if ( el.parentNode ) {
      el.parentNode.removeChild( el );
    }

    // release memory in IE
    el = null;
  }
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
  var arr = attrs.split( "|" ),
    i = arr.length;

  while ( i-- ) {
    Expr.attrHandle[ arr[ i ] ] = handler;
  }
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
  var cur = b && a,
    diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
      a.sourceIndex - b.sourceIndex;

  // Use IE sourceIndex if available on both nodes
  if ( diff ) {
    return diff;
  }

  // Check if b follows a
  if ( cur ) {
    while ( ( cur = cur.nextSibling ) ) {
      if ( cur === b ) {
        return -1;
      }
    }
  }

  return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
  return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return name === "input" && elem.type === type;
  };
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
  return function( elem ) {
    var name = elem.nodeName.toLowerCase();
    return ( name === "input" || name === "button" ) && elem.type === type;
  };
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

  // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
  return function( elem ) {

    // Only certain elements can match :enabled or :disabled
    // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
    // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
    if ( "form" in elem ) {

      // Check for inherited disabledness on relevant non-disabled elements:
      // * listed form-associated elements in a disabled fieldset
      //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
      //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
      // * option elements in a disabled optgroup
      //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
      // All such elements have a "form" property.
      if ( elem.parentNode && elem.disabled === false ) {

        // Option elements defer to a parent optgroup if present
        if ( "label" in elem ) {
          if ( "label" in elem.parentNode ) {
            return elem.parentNode.disabled === disabled;
          } else {
            return elem.disabled === disabled;
          }
        }

        // Support: IE 6 - 11
        // Use the isDisabled shortcut property to check for disabled fieldset ancestors
        return elem.isDisabled === disabled ||

          // Where there is no isDisabled, check manually
          /* jshint -W018 */
          elem.isDisabled !== !disabled &&
          inDisabledFieldset( elem ) === disabled;
      }

      return elem.disabled === disabled;

    // Try to winnow out elements that can't be disabled before trusting the disabled property.
    // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
    // even exist on them, let alone have a boolean value.
    } else if ( "label" in elem ) {
      return elem.disabled === disabled;
    }

    // Remaining elements are neither :enabled nor :disabled
    return false;
  };
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
  return markFunction( function( argument ) {
    argument = +argument;
    return markFunction( function( seed, matches ) {
      var j,
        matchIndexes = fn( [], seed.length, argument ),
        i = matchIndexes.length;

      // Match elements found at the specified indexes
      while ( i-- ) {
        if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
          seed[ j ] = !( matches[ j ] = seed[ j ] );
        }
      }
    } );
  } );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
  return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
  var namespace = elem.namespaceURI,
    docElem = ( elem.ownerDocument || elem ).documentElement;

  // Support: IE <=8
  // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
  // https://bugs.jquery.com/ticket/4833
  return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
  var hasCompare, subWindow,
    doc = node ? node.ownerDocument || node : preferredDoc;

  // Return early if doc is invalid or already selected
  // Support: IE 11+, Edge 17 - 18+
  // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  // two documents; shallow comparisons work.
  // eslint-disable-next-line eqeqeq
  if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
    return document;
  }

  // Update global variables
  document = doc;
  docElem = document.documentElement;
  documentIsHTML = !isXML( document );

  // Support: IE 9 - 11+, Edge 12 - 18+
  // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
  // Support: IE 11+, Edge 17 - 18+
  // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  // two documents; shallow comparisons work.
  // eslint-disable-next-line eqeqeq
  if ( preferredDoc != document &&
    ( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

    // Support: IE 11, Edge
    if ( subWindow.addEventListener ) {
      subWindow.addEventListener( "unload", unloadHandler, false );

    // Support: IE 9 - 10 only
    } else if ( subWindow.attachEvent ) {
      subWindow.attachEvent( "onunload", unloadHandler );
    }
  }

  // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
  // Safari 4 - 5 only, Opera <=11.6 - 12.x only
  // IE/Edge & older browsers don't support the :scope pseudo-class.
  // Support: Safari 6.0 only
  // Safari 6.0 supports :scope but it's an alias of :root there.
  support.scope = assert( function( el ) {
    docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
    return typeof el.querySelectorAll !== "undefined" &&
      !el.querySelectorAll( ":scope fieldset div" ).length;
  } );

  /* Attributes
  ---------------------------------------------------------------------- */

  // Support: IE<8
  // Verify that getAttribute really returns attributes and not properties
  // (excepting IE8 booleans)
  support.attributes = assert( function( el ) {
    el.className = "i";
    return !el.getAttribute( "className" );
  } );

  /* getElement(s)By*
  ---------------------------------------------------------------------- */

  // Check if getElementsByTagName("*") returns only elements
  support.getElementsByTagName = assert( function( el ) {
    el.appendChild( document.createComment( "" ) );
    return !el.getElementsByTagName( "*" ).length;
  } );

  // Support: IE<9
  support.getElementsByClassName = rnative.test( document.getElementsByClassName );

  // Support: IE<10
  // Check if getElementById returns elements by name
  // The broken getElementById methods don't pick up programmatically-set names,
  // so use a roundabout getElementsByName test
  support.getById = assert( function( el ) {
    docElem.appendChild( el ).id = expando;
    return !document.getElementsByName || !document.getElementsByName( expando ).length;
  } );

  // ID filter and find
  if ( support.getById ) {
    Expr.filter[ "ID" ] = function( id ) {
      var attrId = id.replace( runescape, funescape );
      return function( elem ) {
        return elem.getAttribute( "id" ) === attrId;
      };
    };
    Expr.find[ "ID" ] = function( id, context ) {
      if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
        var elem = context.getElementById( id );
        return elem ? [ elem ] : [];
      }
    };
  } else {
    Expr.filter[ "ID" ] =  function( id ) {
      var attrId = id.replace( runescape, funescape );
      return function( elem ) {
        var node = typeof elem.getAttributeNode !== "undefined" &&
          elem.getAttributeNode( "id" );
        return node && node.value === attrId;
      };
    };

    // Support: IE 6 - 7 only
    // getElementById is not reliable as a find shortcut
    Expr.find[ "ID" ] = function( id, context ) {
      if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
        var node, i, elems,
          elem = context.getElementById( id );

        if ( elem ) {

          // Verify the id attribute
          node = elem.getAttributeNode( "id" );
          if ( node && node.value === id ) {
            return [ elem ];
          }

          // Fall back on getElementsByName
          elems = context.getElementsByName( id );
          i = 0;
          while ( ( elem = elems[ i++ ] ) ) {
            node = elem.getAttributeNode( "id" );
            if ( node && node.value === id ) {
              return [ elem ];
            }
          }
        }

        return [];
      }
    };
  }

  // Tag
  Expr.find[ "TAG" ] = support.getElementsByTagName ?
    function( tag, context ) {
      if ( typeof context.getElementsByTagName !== "undefined" ) {
        return context.getElementsByTagName( tag );

      // DocumentFragment nodes don't have gEBTN
      } else if ( support.qsa ) {
        return context.querySelectorAll( tag );
      }
    } :

    function( tag, context ) {
      var elem,
        tmp = [],
        i = 0,

        // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName( tag );

      // Filter out possible comments
      if ( tag === "*" ) {
        while ( ( elem = results[ i++ ] ) ) {
          if ( elem.nodeType === 1 ) {
            tmp.push( elem );
          }
        }

        return tmp;
      }
      return results;
    };

  // Class
  Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
    if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
      return context.getElementsByClassName( className );
    }
  };

  /* QSA/matchesSelector
  ---------------------------------------------------------------------- */

  // QSA and matchesSelector support

  // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
  rbuggyMatches = [];

  // qSa(:focus) reports false when true (Chrome 21)
  // We allow this because of a bug in IE8/9 that throws an error
  // whenever `document.activeElement` is accessed on an iframe
  // So, we allow :focus to pass through QSA all the time to avoid the IE error
  // See https://bugs.jquery.com/ticket/13378
  rbuggyQSA = [];

  if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

    // Build QSA regex
    // Regex strategy adopted from Diego Perini
    assert( function( el ) {

      var input;

      // Select is set to empty string on purpose
      // This is to test IE's treatment of not explicitly
      // setting a boolean content attribute,
      // since its presence should be enough
      // https://bugs.jquery.com/ticket/12359
      docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
        "<select id='" + expando + "-\r\\' msallowcapture=''>" +
        "<option selected=''></option></select>";

      // Support: IE8, Opera 11-12.16
      // Nothing should be selected when empty strings follow ^= or $= or *=
      // The test attribute must be unknown in Opera but "safe" for WinRT
      // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
      if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
        rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
      }

      // Support: IE8
      // Boolean attributes and "value" are not treated correctly
      if ( !el.querySelectorAll( "[selected]" ).length ) {
        rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
      }

      // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
      if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
        rbuggyQSA.push( "~=" );
      }

      // Support: IE 11+, Edge 15 - 18+
      // IE 11/Edge don't find elements on a `[name='']` query in some cases.
      // Adding a temporary attribute to the document before the selection works
      // around the issue.
      // Interestingly, IE 10 & older don't seem to have the issue.
      input = document.createElement( "input" );
      input.setAttribute( "name", "" );
      el.appendChild( input );
      if ( !el.querySelectorAll( "[name='']" ).length ) {
        rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
          whitespace + "*(?:''|\"\")" );
      }

      // Webkit/Opera - :checked should return selected option elements
      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
      // IE8 throws error here and will not see later tests
      if ( !el.querySelectorAll( ":checked" ).length ) {
        rbuggyQSA.push( ":checked" );
      }

      // Support: Safari 8+, iOS 8+
      // https://bugs.webkit.org/show_bug.cgi?id=136851
      // In-page `selector#id sibling-combinator selector` fails
      if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
        rbuggyQSA.push( ".#.+[+~]" );
      }

      // Support: Firefox <=3.6 - 5 only
      // Old Firefox doesn't throw on a badly-escaped identifier.
      el.querySelectorAll( "\\\f" );
      rbuggyQSA.push( "[\\r\\n\\f]" );
    } );

    assert( function( el ) {
      el.innerHTML = "<a href='' disabled='disabled'></a>" +
        "<select disabled='disabled'><option/></select>";

      // Support: Windows 8 Native Apps
      // The type and name attributes are restricted during .innerHTML assignment
      var input = document.createElement( "input" );
      input.setAttribute( "type", "hidden" );
      el.appendChild( input ).setAttribute( "name", "D" );

      // Support: IE8
      // Enforce case-sensitivity of name attribute
      if ( el.querySelectorAll( "[name=d]" ).length ) {
        rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
      }

      // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
      // IE8 throws error here and will not see later tests
      if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
        rbuggyQSA.push( ":enabled", ":disabled" );
      }

      // Support: IE9-11+
      // IE's :disabled selector does not pick up the children of disabled fieldsets
      docElem.appendChild( el ).disabled = true;
      if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
        rbuggyQSA.push( ":enabled", ":disabled" );
      }

      // Support: Opera 10 - 11 only
      // Opera 10-11 does not throw on post-comma invalid pseudos
      el.querySelectorAll( "*,:x" );
      rbuggyQSA.push( ",.*:" );
    } );
  }

  if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
    docElem.webkitMatchesSelector ||
    docElem.mozMatchesSelector ||
    docElem.oMatchesSelector ||
    docElem.msMatchesSelector ) ) ) ) {

    assert( function( el ) {

      // Check to see if it's possible to do matchesSelector
      // on a disconnected node (IE 9)
      support.disconnectedMatch = matches.call( el, "*" );

      // This should fail with an exception
      // Gecko does not error, returns false instead
      matches.call( el, "[s!='']:x" );
      rbuggyMatches.push( "!=", pseudos );
    } );
  }

  rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
  rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

  /* Contains
  ---------------------------------------------------------------------- */
  hasCompare = rnative.test( docElem.compareDocumentPosition );

  // Element contains another
  // Purposefully self-exclusive
  // As in, an element does not contain itself
  contains = hasCompare || rnative.test( docElem.contains ) ?
    function( a, b ) {
      var adown = a.nodeType === 9 ? a.documentElement : a,
        bup = b && b.parentNode;
      return a === bup || !!( bup && bup.nodeType === 1 && (
        adown.contains ?
          adown.contains( bup ) :
          a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
      ) );
    } :
    function( a, b ) {
      if ( b ) {
        while ( ( b = b.parentNode ) ) {
          if ( b === a ) {
            return true;
          }
        }
      }
      return false;
    };

  /* Sorting
  ---------------------------------------------------------------------- */

  // Document order sorting
  sortOrder = hasCompare ?
  function( a, b ) {

    // Flag for duplicate removal
    if ( a === b ) {
      hasDuplicate = true;
      return 0;
    }

    // Sort on method existence if only one input has compareDocumentPosition
    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
    if ( compare ) {
      return compare;
    }

    // Calculate position if both inputs belong to the same document
    // Support: IE 11+, Edge 17 - 18+
    // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
    // two documents; shallow comparisons work.
    // eslint-disable-next-line eqeqeq
    compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
      a.compareDocumentPosition( b ) :

      // Otherwise we know they are disconnected
      1;

    // Disconnected nodes
    if ( compare & 1 ||
      ( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

      // Choose the first element that is related to our preferred document
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ( a == document || a.ownerDocument == preferredDoc &&
        contains( preferredDoc, a ) ) {
        return -1;
      }

      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ( b == document || b.ownerDocument == preferredDoc &&
        contains( preferredDoc, b ) ) {
        return 1;
      }

      // Maintain original order
      return sortInput ?
        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
        0;
    }

    return compare & 4 ? -1 : 1;
  } :
  function( a, b ) {

    // Exit early if the nodes are identical
    if ( a === b ) {
      hasDuplicate = true;
      return 0;
    }

    var cur,
      i = 0,
      aup = a.parentNode,
      bup = b.parentNode,
      ap = [ a ],
      bp = [ b ];

    // Parentless nodes are either documents or disconnected
    if ( !aup || !bup ) {

      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      /* eslint-disable eqeqeq */
      return a == document ? -1 :
        b == document ? 1 :
        /* eslint-enable eqeqeq */
        aup ? -1 :
        bup ? 1 :
        sortInput ?
        ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
        0;

    // If the nodes are siblings, we can do a quick check
    } else if ( aup === bup ) {
      return siblingCheck( a, b );
    }

    // Otherwise we need full lists of their ancestors for comparison
    cur = a;
    while ( ( cur = cur.parentNode ) ) {
      ap.unshift( cur );
    }
    cur = b;
    while ( ( cur = cur.parentNode ) ) {
      bp.unshift( cur );
    }

    // Walk down the tree looking for a discrepancy
    while ( ap[ i ] === bp[ i ] ) {
      i++;
    }

    return i ?

      // Do a sibling check if the nodes have a common ancestor
      siblingCheck( ap[ i ], bp[ i ] ) :

      // Otherwise nodes in our document sort first
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      /* eslint-disable eqeqeq */
      ap[ i ] == preferredDoc ? -1 :
      bp[ i ] == preferredDoc ? 1 :
      /* eslint-enable eqeqeq */
      0;
  };

  return document;
};

Sizzle.matches = function( expr, elements ) {
  return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
  setDocument( elem );

  if ( support.matchesSelector && documentIsHTML &&
    !nonnativeSelectorCache[ expr + " " ] &&
    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

    try {
      var ret = matches.call( elem, expr );

      // IE 9's matchesSelector returns false on disconnected nodes
      if ( ret || support.disconnectedMatch ||

        // As well, disconnected nodes are said to be in a document
        // fragment in IE 9
        elem.document && elem.document.nodeType !== 11 ) {
        return ret;
      }
    } catch ( e ) {
      nonnativeSelectorCache( expr, true );
    }
  }

  return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

  // Set document vars if needed
  // Support: IE 11+, Edge 17 - 18+
  // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  // two documents; shallow comparisons work.
  // eslint-disable-next-line eqeqeq
  if ( ( context.ownerDocument || context ) != document ) {
    setDocument( context );
  }
  return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

  // Set document vars if needed
  // Support: IE 11+, Edge 17 - 18+
  // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
  // two documents; shallow comparisons work.
  // eslint-disable-next-line eqeqeq
  if ( ( elem.ownerDocument || elem ) != document ) {
    setDocument( elem );
  }

  var fn = Expr.attrHandle[ name.toLowerCase() ],

    // Don't get fooled by Object.prototype properties (jQuery #13807)
    val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
      fn( elem, name, !documentIsHTML ) :
      undefined;

  return val !== undefined ?
    val :
    support.attributes || !documentIsHTML ?
      elem.getAttribute( name ) :
      ( val = elem.getAttributeNode( name ) ) && val.specified ?
        val.value :
        null;
};

Sizzle.escape = function( sel ) {
  return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
  throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
  var elem,
    duplicates = [],
    j = 0,
    i = 0;

  // Unless we *know* we can detect duplicates, assume their presence
  hasDuplicate = !support.detectDuplicates;
  sortInput = !support.sortStable && results.slice( 0 );
  results.sort( sortOrder );

  if ( hasDuplicate ) {
    while ( ( elem = results[ i++ ] ) ) {
      if ( elem === results[ i ] ) {
        j = duplicates.push( i );
      }
    }
    while ( j-- ) {
      results.splice( duplicates[ j ], 1 );
    }
  }

  // Clear input after sorting to release objects
  // See https://github.com/jquery/sizzle/pull/225
  sortInput = null;

  return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
  var node,
    ret = "",
    i = 0,
    nodeType = elem.nodeType;

  if ( !nodeType ) {

    // If no nodeType, this is expected to be an array
    while ( ( node = elem[ i++ ] ) ) {

      // Do not traverse comment nodes
      ret += getText( node );
    }
  } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

    // Use textContent for elements
    // innerText usage removed for consistency of new lines (jQuery #11153)
    if ( typeof elem.textContent === "string" ) {
      return elem.textContent;
    } else {

      // Traverse its children
      for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
        ret += getText( elem );
      }
    }
  } else if ( nodeType === 3 || nodeType === 4 ) {
    return elem.nodeValue;
  }

  // Do not include comment or processing instruction nodes

  return ret;
};

Expr = Sizzle.selectors = {

  // Can be adjusted by the user
  cacheLength: 50,

  createPseudo: markFunction,

  match: matchExpr,

  attrHandle: {},

  find: {},

  relative: {
    ">": { dir: "parentNode", first: true },
    " ": { dir: "parentNode" },
    "+": { dir: "previousSibling", first: true },
    "~": { dir: "previousSibling" }
  },

  preFilter: {
    "ATTR": function( match ) {
      match[ 1 ] = match[ 1 ].replace( runescape, funescape );

      // Move the given value to match[3] whether quoted or unquoted
      match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
        match[ 5 ] || "" ).replace( runescape, funescape );

      if ( match[ 2 ] === "~=" ) {
        match[ 3 ] = " " + match[ 3 ] + " ";
      }

      return match.slice( 0, 4 );
    },

    "CHILD": function( match ) {

      /* matches from matchExpr["CHILD"]
        1 type (only|nth|...)
        2 what (child|of-type)
        3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
        4 xn-component of xn+y argument ([+-]?\d*n|)
        5 sign of xn-component
        6 x of xn-component
        7 sign of y-component
        8 y of y-component
      */
      match[ 1 ] = match[ 1 ].toLowerCase();

      if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

        // nth-* requires argument
        if ( !match[ 3 ] ) {
          Sizzle.error( match[ 0 ] );
        }

        // numeric x and y parameters for Expr.filter.CHILD
        // remember that false/true cast respectively to 0/1
        match[ 4 ] = +( match[ 4 ] ?
          match[ 5 ] + ( match[ 6 ] || 1 ) :
          2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
        match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

        // other types prohibit arguments
      } else if ( match[ 3 ] ) {
        Sizzle.error( match[ 0 ] );
      }

      return match;
    },

    "PSEUDO": function( match ) {
      var excess,
        unquoted = !match[ 6 ] && match[ 2 ];

      if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
        return null;
      }

      // Accept quoted arguments as-is
      if ( match[ 3 ] ) {
        match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

      // Strip excess characters from unquoted arguments
      } else if ( unquoted && rpseudo.test( unquoted ) &&

        // Get excess from tokenize (recursively)
        ( excess = tokenize( unquoted, true ) ) &&

        // advance to the next closing parenthesis
        ( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

        // excess is a negative index
        match[ 0 ] = match[ 0 ].slice( 0, excess );
        match[ 2 ] = unquoted.slice( 0, excess );
      }

      // Return only captures needed by the pseudo filter method (type and argument)
      return match.slice( 0, 3 );
    }
  },

  filter: {

    "TAG": function( nodeNameSelector ) {
      var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
      return nodeNameSelector === "*" ?
        function() {
          return true;
        } :
        function( elem ) {
          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
        };
    },

    "CLASS": function( className ) {
      var pattern = classCache[ className + " " ];

      return pattern ||
        ( pattern = new RegExp( "(^|" + whitespace +
          ")" + className + "(" + whitespace + "|$)" ) ) && classCache(
            className, function( elem ) {
              return pattern.test(
                typeof elem.className === "string" && elem.className ||
                typeof elem.getAttribute !== "undefined" &&
                  elem.getAttribute( "class" ) ||
                ""
              );
        } );
    },

    "ATTR": function( name, operator, check ) {
      return function( elem ) {
        var result = Sizzle.attr( elem, name );

        if ( result == null ) {
          return operator === "!=";
        }
        if ( !operator ) {
          return true;
        }

        result += "";

        /* eslint-disable max-len */

        return operator === "=" ? result === check :
          operator === "!=" ? result !== check :
          operator === "^=" ? check && result.indexOf( check ) === 0 :
          operator === "*=" ? check && result.indexOf( check ) > -1 :
          operator === "$=" ? check && result.slice( -check.length ) === check :
          operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
          operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
          false;
        /* eslint-enable max-len */

      };
    },

    "CHILD": function( type, what, _argument, first, last ) {
      var simple = type.slice( 0, 3 ) !== "nth",
        forward = type.slice( -4 ) !== "last",
        ofType = what === "of-type";

      return first === 1 && last === 0 ?

        // Shortcut for :nth-*(n)
        function( elem ) {
          return !!elem.parentNode;
        } :

        function( elem, _context, xml ) {
          var cache, uniqueCache, outerCache, node, nodeIndex, start,
            dir = simple !== forward ? "nextSibling" : "previousSibling",
            parent = elem.parentNode,
            name = ofType && elem.nodeName.toLowerCase(),
            useCache = !xml && !ofType,
            diff = false;

          if ( parent ) {

            // :(first|last|only)-(child|of-type)
            if ( simple ) {
              while ( dir ) {
                node = elem;
                while ( ( node = node[ dir ] ) ) {
                  if ( ofType ?
                    node.nodeName.toLowerCase() === name :
                    node.nodeType === 1 ) {

                    return false;
                  }
                }

                // Reverse direction for :only-* (if we haven't yet done so)
                start = dir = type === "only" && !start && "nextSibling";
              }
              return true;
            }

            start = [ forward ? parent.firstChild : parent.lastChild ];

            // non-xml :nth-child(...) stores cache data on `parent`
            if ( forward && useCache ) {

              // Seek `elem` from a previously-cached index

              // ...in a gzip-friendly way
              node = parent;
              outerCache = node[ expando ] || ( node[ expando ] = {} );

              // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)
              uniqueCache = outerCache[ node.uniqueID ] ||
                ( outerCache[ node.uniqueID ] = {} );

              cache = uniqueCache[ type ] || [];
              nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
              diff = nodeIndex && cache[ 2 ];
              node = nodeIndex && parent.childNodes[ nodeIndex ];

              while ( ( node = ++nodeIndex && node && node[ dir ] ||

                // Fallback to seeking `elem` from the start
                ( diff = nodeIndex = 0 ) || start.pop() ) ) {

                // When found, cache indexes on `parent` and break
                if ( node.nodeType === 1 && ++diff && node === elem ) {
                  uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
                  break;
                }
              }

            } else {

              // Use previously-cached element index if available
              if ( useCache ) {

                // ...in a gzip-friendly way
                node = elem;
                outerCache = node[ expando ] || ( node[ expando ] = {} );

                // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)
                uniqueCache = outerCache[ node.uniqueID ] ||
                  ( outerCache[ node.uniqueID ] = {} );

                cache = uniqueCache[ type ] || [];
                nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
                diff = nodeIndex;
              }

              // xml :nth-child(...)
              // or :nth-last-child(...) or :nth(-last)?-of-type(...)
              if ( diff === false ) {

                // Use the same loop as above to seek `elem` from the start
                while ( ( node = ++nodeIndex && node && node[ dir ] ||
                  ( diff = nodeIndex = 0 ) || start.pop() ) ) {

                  if ( ( ofType ?
                    node.nodeName.toLowerCase() === name :
                    node.nodeType === 1 ) &&
                    ++diff ) {

                    // Cache the index of each encountered element
                    if ( useCache ) {
                      outerCache = node[ expando ] ||
                        ( node[ expando ] = {} );

                      // Support: IE <9 only
                      // Defend against cloned attroperties (jQuery gh-1709)
                      uniqueCache = outerCache[ node.uniqueID ] ||
                        ( outerCache[ node.uniqueID ] = {} );

                      uniqueCache[ type ] = [ dirruns, diff ];
                    }

                    if ( node === elem ) {
                      break;
                    }
                  }
                }
              }
            }

            // Incorporate the offset, then check against cycle size
            diff -= last;
            return diff === first || ( diff % first === 0 && diff / first >= 0 );
          }
        };
    },

    "PSEUDO": function( pseudo, argument ) {

      // pseudo-class names are case-insensitive
      // http://www.w3.org/TR/selectors/#pseudo-classes
      // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
      // Remember that setFilters inherits from pseudos
      var args,
        fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
          Sizzle.error( "unsupported pseudo: " + pseudo );

      // The user may use createPseudo to indicate that
      // arguments are needed to create the filter function
      // just as Sizzle does
      if ( fn[ expando ] ) {
        return fn( argument );
      }

      // But maintain support for old signatures
      if ( fn.length > 1 ) {
        args = [ pseudo, pseudo, "", argument ];
        return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
          markFunction( function( seed, matches ) {
            var idx,
              matched = fn( seed, argument ),
              i = matched.length;
            while ( i-- ) {
              idx = indexOf( seed, matched[ i ] );
              seed[ idx ] = !( matches[ idx ] = matched[ i ] );
            }
          } ) :
          function( elem ) {
            return fn( elem, 0, args );
          };
      }

      return fn;
    }
  },

  pseudos: {

    // Potentially complex pseudos
    "not": markFunction( function( selector ) {

      // Trim the selector passed to compile
      // to avoid treating leading and trailing
      // spaces as combinators
      var input = [],
        results = [],
        matcher = compile( selector.replace( rtrim, "$1" ) );

      return matcher[ expando ] ?
        markFunction( function( seed, matches, _context, xml ) {
          var elem,
            unmatched = matcher( seed, null, xml, [] ),
            i = seed.length;

          // Match elements unmatched by `matcher`
          while ( i-- ) {
            if ( ( elem = unmatched[ i ] ) ) {
              seed[ i ] = !( matches[ i ] = elem );
            }
          }
        } ) :
        function( elem, _context, xml ) {
          input[ 0 ] = elem;
          matcher( input, null, xml, results );

          // Don't keep the element (issue #299)
          input[ 0 ] = null;
          return !results.pop();
        };
    } ),

    "has": markFunction( function( selector ) {
      return function( elem ) {
        return Sizzle( selector, elem ).length > 0;
      };
    } ),

    "contains": markFunction( function( text ) {
      text = text.replace( runescape, funescape );
      return function( elem ) {
        return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
      };
    } ),

    // "Whether an element is represented by a :lang() selector
    // is based solely on the element's language value
    // being equal to the identifier C,
    // or beginning with the identifier C immediately followed by "-".
    // The matching of C against the element's language value is performed case-insensitively.
    // The identifier C does not have to be a valid language name."
    // http://www.w3.org/TR/selectors/#lang-pseudo
    "lang": markFunction( function( lang ) {

      // lang value must be a valid identifier
      if ( !ridentifier.test( lang || "" ) ) {
        Sizzle.error( "unsupported lang: " + lang );
      }
      lang = lang.replace( runescape, funescape ).toLowerCase();
      return function( elem ) {
        var elemLang;
        do {
          if ( ( elemLang = documentIsHTML ?
            elem.lang :
            elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

            elemLang = elemLang.toLowerCase();
            return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
          }
        } while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
        return false;
      };
    } ),

    // Miscellaneous
    "target": function( elem ) {
      var hash = window.location && window.location.hash;
      return hash && hash.slice( 1 ) === elem.id;
    },

    "root": function( elem ) {
      return elem === docElem;
    },

    "focus": function( elem ) {
      return elem === document.activeElement &&
        ( !document.hasFocus || document.hasFocus() ) &&
        !!( elem.type || elem.href || ~elem.tabIndex );
    },

    // Boolean properties
    "enabled": createDisabledPseudo( false ),
    "disabled": createDisabledPseudo( true ),

    "checked": function( elem ) {

      // In CSS3, :checked should return both checked and selected elements
      // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
      var nodeName = elem.nodeName.toLowerCase();
      return ( nodeName === "input" && !!elem.checked ) ||
        ( nodeName === "option" && !!elem.selected );
    },

    "selected": function( elem ) {

      // Accessing this property makes selected-by-default
      // options in Safari work properly
      if ( elem.parentNode ) {
        // eslint-disable-next-line no-unused-expressions
        elem.parentNode.selectedIndex;
      }

      return elem.selected === true;
    },

    // Contents
    "empty": function( elem ) {

      // http://www.w3.org/TR/selectors/#empty-pseudo
      // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
      //   but not by others (comment: 8; processing instruction: 7; etc.)
      // nodeType < 6 works because attributes (2) do not appear as children
      for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
        if ( elem.nodeType < 6 ) {
          return false;
        }
      }
      return true;
    },

    "parent": function( elem ) {
      return !Expr.pseudos[ "empty" ]( elem );
    },

    // Element/input types
    "header": function( elem ) {
      return rheader.test( elem.nodeName );
    },

    "input": function( elem ) {
      return rinputs.test( elem.nodeName );
    },

    "button": function( elem ) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === "button" || name === "button";
    },

    "text": function( elem ) {
      var attr;
      return elem.nodeName.toLowerCase() === "input" &&
        elem.type === "text" &&

        // Support: IE<8
        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
        ( ( attr = elem.getAttribute( "type" ) ) == null ||
          attr.toLowerCase() === "text" );
    },

    // Position-in-collection
    "first": createPositionalPseudo( function() {
      return [ 0 ];
    } ),

    "last": createPositionalPseudo( function( _matchIndexes, length ) {
      return [ length - 1 ];
    } ),

    "eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
      return [ argument < 0 ? argument + length : argument ];
    } ),

    "even": createPositionalPseudo( function( matchIndexes, length ) {
      var i = 0;
      for ( ; i < length; i += 2 ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    } ),

    "odd": createPositionalPseudo( function( matchIndexes, length ) {
      var i = 1;
      for ( ; i < length; i += 2 ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    } ),

    "lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
      var i = argument < 0 ?
        argument + length :
        argument > length ?
          length :
          argument;
      for ( ; --i >= 0; ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    } ),

    "gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
      var i = argument < 0 ? argument + length : argument;
      for ( ; ++i < length; ) {
        matchIndexes.push( i );
      }
      return matchIndexes;
    } )
  }
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
  Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
  Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
  var matched, match, tokens, type,
    soFar, groups, preFilters,
    cached = tokenCache[ selector + " " ];

  if ( cached ) {
    return parseOnly ? 0 : cached.slice( 0 );
  }

  soFar = selector;
  groups = [];
  preFilters = Expr.preFilter;

  while ( soFar ) {

    // Comma and first run
    if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
      if ( match ) {

        // Don't consume trailing commas as valid
        soFar = soFar.slice( match[ 0 ].length ) || soFar;
      }
      groups.push( ( tokens = [] ) );
    }

    matched = false;

    // Combinators
    if ( ( match = rcombinators.exec( soFar ) ) ) {
      matched = match.shift();
      tokens.push( {
        value: matched,

        // Cast descendant combinators to space
        type: match[ 0 ].replace( rtrim, " " )
      } );
      soFar = soFar.slice( matched.length );
    }

    // Filters
    for ( type in Expr.filter ) {
      if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
        ( match = preFilters[ type ]( match ) ) ) ) {
        matched = match.shift();
        tokens.push( {
          value: matched,
          type: type,
          matches: match
        } );
        soFar = soFar.slice( matched.length );
      }
    }

    if ( !matched ) {
      break;
    }
  }

  // Return the length of the invalid excess
  // if we're just parsing
  // Otherwise, throw an error or return tokens
  return parseOnly ?
    soFar.length :
    soFar ?
      Sizzle.error( selector ) :

      // Cache the tokens
      tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
  var i = 0,
    len = tokens.length,
    selector = "";
  for ( ; i < len; i++ ) {
    selector += tokens[ i ].value;
  }
  return selector;
}

function addCombinator( matcher, combinator, base ) {
  var dir = combinator.dir,
    skip = combinator.next,
    key = skip || dir,
    checkNonElements = base && key === "parentNode",
    doneName = done++;

  return combinator.first ?

    // Check against closest ancestor/preceding element
    function( elem, context, xml ) {
      while ( ( elem = elem[ dir ] ) ) {
        if ( elem.nodeType === 1 || checkNonElements ) {
          return matcher( elem, context, xml );
        }
      }
      return false;
    } :

    // Check against all ancestor/preceding elements
    function( elem, context, xml ) {
      var oldCache, uniqueCache, outerCache,
        newCache = [ dirruns, doneName ];

      // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
      if ( xml ) {
        while ( ( elem = elem[ dir ] ) ) {
          if ( elem.nodeType === 1 || checkNonElements ) {
            if ( matcher( elem, context, xml ) ) {
              return true;
            }
          }
        }
      } else {
        while ( ( elem = elem[ dir ] ) ) {
          if ( elem.nodeType === 1 || checkNonElements ) {
            outerCache = elem[ expando ] || ( elem[ expando ] = {} );

            // Support: IE <9 only
            // Defend against cloned attroperties (jQuery gh-1709)
            uniqueCache = outerCache[ elem.uniqueID ] ||
              ( outerCache[ elem.uniqueID ] = {} );

            if ( skip && skip === elem.nodeName.toLowerCase() ) {
              elem = elem[ dir ] || elem;
            } else if ( ( oldCache = uniqueCache[ key ] ) &&
              oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

              // Assign to newCache so results back-propagate to previous elements
              return ( newCache[ 2 ] = oldCache[ 2 ] );
            } else {

              // Reuse newcache so results back-propagate to previous elements
              uniqueCache[ key ] = newCache;

              // A match means we're done; a fail means we have to keep checking
              if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
}

function elementMatcher( matchers ) {
  return matchers.length > 1 ?
    function( elem, context, xml ) {
      var i = matchers.length;
      while ( i-- ) {
        if ( !matchers[ i ]( elem, context, xml ) ) {
          return false;
        }
      }
      return true;
    } :
    matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
  var i = 0,
    len = contexts.length;
  for ( ; i < len; i++ ) {
    Sizzle( selector, contexts[ i ], results );
  }
  return results;
}

function condense( unmatched, map, filter, context, xml ) {
  var elem,
    newUnmatched = [],
    i = 0,
    len = unmatched.length,
    mapped = map != null;

  for ( ; i < len; i++ ) {
    if ( ( elem = unmatched[ i ] ) ) {
      if ( !filter || filter( elem, context, xml ) ) {
        newUnmatched.push( elem );
        if ( mapped ) {
          map.push( i );
        }
      }
    }
  }

  return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
  if ( postFilter && !postFilter[ expando ] ) {
    postFilter = setMatcher( postFilter );
  }
  if ( postFinder && !postFinder[ expando ] ) {
    postFinder = setMatcher( postFinder, postSelector );
  }
  return markFunction( function( seed, results, context, xml ) {
    var temp, i, elem,
      preMap = [],
      postMap = [],
      preexisting = results.length,

      // Get initial elements from seed or context
      elems = seed || multipleContexts(
        selector || "*",
        context.nodeType ? [ context ] : context,
        []
      ),

      // Prefilter to get matcher input, preserving a map for seed-results synchronization
      matcherIn = preFilter && ( seed || !selector ) ?
        condense( elems, preMap, preFilter, context, xml ) :
        elems,

      matcherOut = matcher ?

        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

          // ...intermediate processing is necessary
          [] :

          // ...otherwise use results directly
          results :
        matcherIn;

    // Find primary matches
    if ( matcher ) {
      matcher( matcherIn, matcherOut, context, xml );
    }

    // Apply postFilter
    if ( postFilter ) {
      temp = condense( matcherOut, postMap );
      postFilter( temp, [], context, xml );

      // Un-match failing elements by moving them back to matcherIn
      i = temp.length;
      while ( i-- ) {
        if ( ( elem = temp[ i ] ) ) {
          matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
        }
      }
    }

    if ( seed ) {
      if ( postFinder || preFilter ) {
        if ( postFinder ) {

          // Get the final matcherOut by condensing this intermediate into postFinder contexts
          temp = [];
          i = matcherOut.length;
          while ( i-- ) {
            if ( ( elem = matcherOut[ i ] ) ) {

              // Restore matcherIn since elem is not yet a final match
              temp.push( ( matcherIn[ i ] = elem ) );
            }
          }
          postFinder( null, ( matcherOut = [] ), temp, xml );
        }

        // Move matched elements from seed to results to keep them synchronized
        i = matcherOut.length;
        while ( i-- ) {
          if ( ( elem = matcherOut[ i ] ) &&
            ( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

            seed[ temp ] = !( results[ temp ] = elem );
          }
        }
      }

    // Add elements to results, through postFinder if defined
    } else {
      matcherOut = condense(
        matcherOut === results ?
          matcherOut.splice( preexisting, matcherOut.length ) :
          matcherOut
      );
      if ( postFinder ) {
        postFinder( null, results, matcherOut, xml );
      } else {
        push.apply( results, matcherOut );
      }
    }
  } );
}

function matcherFromTokens( tokens ) {
  var checkContext, matcher, j,
    len = tokens.length,
    leadingRelative = Expr.relative[ tokens[ 0 ].type ],
    implicitRelative = leadingRelative || Expr.relative[ " " ],
    i = leadingRelative ? 1 : 0,

    // The foundational matcher ensures that elements are reachable from top-level context(s)
    matchContext = addCombinator( function( elem ) {
      return elem === checkContext;
    }, implicitRelative, true ),
    matchAnyContext = addCombinator( function( elem ) {
      return indexOf( checkContext, elem ) > -1;
    }, implicitRelative, true ),
    matchers = [ function( elem, context, xml ) {
      var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
        ( checkContext = context ).nodeType ?
          matchContext( elem, context, xml ) :
          matchAnyContext( elem, context, xml ) );

      // Avoid hanging onto element (issue #299)
      checkContext = null;
      return ret;
    } ];

  for ( ; i < len; i++ ) {
    if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
      matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
    } else {
      matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

      // Return special upon seeing a positional matcher
      if ( matcher[ expando ] ) {

        // Find the next relative operator (if any) for proper handling
        j = ++i;
        for ( ; j < len; j++ ) {
          if ( Expr.relative[ tokens[ j ].type ] ) {
            break;
          }
        }
        return setMatcher(
          i > 1 && elementMatcher( matchers ),
          i > 1 && toSelector(

          // If the preceding token was a descendant combinator, insert an implicit any-element `*`
          tokens
            .slice( 0, i - 1 )
            .concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
          ).replace( rtrim, "$1" ),
          matcher,
          i < j && matcherFromTokens( tokens.slice( i, j ) ),
          j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
          j < len && toSelector( tokens )
        );
      }
      matchers.push( matcher );
    }
  }

  return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
  var bySet = setMatchers.length > 0,
    byElement = elementMatchers.length > 0,
    superMatcher = function( seed, context, xml, results, outermost ) {
      var elem, j, matcher,
        matchedCount = 0,
        i = "0",
        unmatched = seed && [],
        setMatched = [],
        contextBackup = outermostContext,

        // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

        // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
        len = elems.length;

      if ( outermost ) {

        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        outermostContext = context == document || context || outermost;
      }

      // Add elements passing elementMatchers directly to results
      // Support: IE<9, Safari
      // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
      for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
        if ( byElement && elem ) {
          j = 0;

          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if ( !context && elem.ownerDocument != document ) {
            setDocument( elem );
            xml = !documentIsHTML;
          }
          while ( ( matcher = elementMatchers[ j++ ] ) ) {
            if ( matcher( elem, context || document, xml ) ) {
              results.push( elem );
              break;
            }
          }
          if ( outermost ) {
            dirruns = dirrunsUnique;
          }
        }

        // Track unmatched elements for set filters
        if ( bySet ) {

          // They will have gone through all possible matchers
          if ( ( elem = !matcher && elem ) ) {
            matchedCount--;
          }

          // Lengthen the array for every element, matched or not
          if ( seed ) {
            unmatched.push( elem );
          }
        }
      }

      // `i` is now the count of elements visited above, and adding it to `matchedCount`
      // makes the latter nonnegative.
      matchedCount += i;

      // Apply set filters to unmatched elements
      // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
      // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
      // no element matchers and no seed.
      // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
      // case, which will result in a "00" `matchedCount` that differs from `i` but is also
      // numerically zero.
      if ( bySet && i !== matchedCount ) {
        j = 0;
        while ( ( matcher = setMatchers[ j++ ] ) ) {
          matcher( unmatched, setMatched, context, xml );
        }

        if ( seed ) {

          // Reintegrate element matches to eliminate the need for sorting
          if ( matchedCount > 0 ) {
            while ( i-- ) {
              if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
                setMatched[ i ] = pop.call( results );
              }
            }
          }

          // Discard index placeholder values to get only actual matches
          setMatched = condense( setMatched );
        }

        // Add matches to results
        push.apply( results, setMatched );

        // Seedless set matches succeeding multiple successful matchers stipulate sorting
        if ( outermost && !seed && setMatched.length > 0 &&
          ( matchedCount + setMatchers.length ) > 1 ) {

          Sizzle.uniqueSort( results );
        }
      }

      // Override manipulation of globals by nested matchers
      if ( outermost ) {
        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      }

      return unmatched;
    };

  return bySet ?
    markFunction( superMatcher ) :
    superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
  var i,
    setMatchers = [],
    elementMatchers = [],
    cached = compilerCache[ selector + " " ];

  if ( !cached ) {

    // Generate a function of recursive functions that can be used to check each element
    if ( !match ) {
      match = tokenize( selector );
    }
    i = match.length;
    while ( i-- ) {
      cached = matcherFromTokens( match[ i ] );
      if ( cached[ expando ] ) {
        setMatchers.push( cached );
      } else {
        elementMatchers.push( cached );
      }
    }

    // Cache the compiled function
    cached = compilerCache(
      selector,
      matcherFromGroupMatchers( elementMatchers, setMatchers )
    );

    // Save selector and tokenization
    cached.selector = selector;
  }
  return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
  var i, tokens, token, type, find,
    compiled = typeof selector === "function" && selector,
    match = !seed && tokenize( ( selector = compiled.selector || selector ) );

  results = results || [];

  // Try to minimize operations if there is only one selector in the list and no seed
  // (the latter of which guarantees us context)
  if ( match.length === 1 ) {

    // Reduce context if the leading compound selector is an ID
    tokens = match[ 0 ] = match[ 0 ].slice( 0 );
    if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
      context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

      context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
        .replace( runescape, funescape ), context ) || [] )[ 0 ];
      if ( !context ) {
        return results;

      // Precompiled matchers will still verify ancestry, so step up a level
      } else if ( compiled ) {
        context = context.parentNode;
      }

      selector = selector.slice( tokens.shift().value.length );
    }

    // Fetch a seed set for right-to-left matching
    i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
    while ( i-- ) {
      token = tokens[ i ];

      // Abort if we hit a combinator
      if ( Expr.relative[ ( type = token.type ) ] ) {
        break;
      }
      if ( ( find = Expr.find[ type ] ) ) {

        // Search, expanding context for leading sibling combinators
        if ( ( seed = find(
          token.matches[ 0 ].replace( runescape, funescape ),
          rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
            context
        ) ) ) {

          // If seed is empty or no tokens remain, we can return early
          tokens.splice( i, 1 );
          selector = seed.length && toSelector( tokens );
          if ( !selector ) {
            push.apply( results, seed );
            return results;
          }

          break;
        }
      }
    }
  }

  // Compile and execute a filtering function if one is not provided
  // Provide `match` to avoid retokenization if we modified the selector above
  ( compiled || compile( selector, match ) )(
    seed,
    context,
    !documentIsHTML,
    results,
    !context || rsibling.test( selector ) && testContext( context.parentNode ) || context
  );
  return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

  // Should return 1, but returns 4 (following)
  return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
  el.innerHTML = "<a href='#'></a>";
  return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
  addHandle( "type|href|height|width", function( elem, name, isXML ) {
    if ( !isXML ) {
      return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
    }
  } );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
  el.innerHTML = "<input/>";
  el.firstChild.setAttribute( "value", "" );
  return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
  addHandle( "value", function( elem, _name, isXML ) {
    if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
      return elem.defaultValue;
    }
  } );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
  return el.getAttribute( "disabled" ) == null;
} ) ) {
  addHandle( booleans, function( elem, name, isXML ) {
    var val;
    if ( !isXML ) {
      return elem[ name ] === true ? name.toLowerCase() :
        ( val = elem.getAttributeNode( name ) ) && val.specified ?
          val.value :
          null;
    }
  } );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
  var matched = [],
    truncate = until !== undefined;

  while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
    if ( elem.nodeType === 1 ) {
      if ( truncate && jQuery( elem ).is( until ) ) {
        break;
      }
      matched.push( elem );
    }
  }
  return matched;
};


var siblings = function( n, elem ) {
  var matched = [];

  for ( ; n; n = n.nextSibling ) {
    if ( n.nodeType === 1 && n !== elem ) {
      matched.push( n );
    }
  }

  return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
  if ( isFunction( qualifier ) ) {
    return jQuery.grep( elements, function( elem, i ) {
      return !!qualifier.call( elem, i, elem ) !== not;
    } );
  }

  // Single element
  if ( qualifier.nodeType ) {
    return jQuery.grep( elements, function( elem ) {
      return ( elem === qualifier ) !== not;
    } );
  }

  // Arraylike of elements (jQuery, arguments, Array)
  if ( typeof qualifier !== "string" ) {
    return jQuery.grep( elements, function( elem ) {
      return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
    } );
  }

  // Filtered directly for both simple and complex selectors
  return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
  var elem = elems[ 0 ];

  if ( not ) {
    expr = ":not(" + expr + ")";
  }

  if ( elems.length === 1 && elem.nodeType === 1 ) {
    return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
  }

  return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
    return elem.nodeType === 1;
  } ) );
};

jQuery.fn.extend( {
  find: function( selector ) {
    var i, ret,
      len = this.length,
      self = this;

    if ( typeof selector !== "string" ) {
      return this.pushStack( jQuery( selector ).filter( function() {
        for ( i = 0; i < len; i++ ) {
          if ( jQuery.contains( self[ i ], this ) ) {
            return true;
          }
        }
      } ) );
    }

    ret = this.pushStack( [] );

    for ( i = 0; i < len; i++ ) {
      jQuery.find( selector, self[ i ], ret );
    }

    return len > 1 ? jQuery.uniqueSort( ret ) : ret;
  },
  filter: function( selector ) {
    return this.pushStack( winnow( this, selector || [], false ) );
  },
  not: function( selector ) {
    return this.pushStack( winnow( this, selector || [], true ) );
  },
  is: function( selector ) {
    return !!winnow(
      this,

      // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test( selector ) ?
        jQuery( selector ) :
        selector || [],
      false
    ).length;
  }
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

  // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

  init = jQuery.fn.init = function( selector, context, root ) {
    var match, elem;

    // HANDLE: $(""), $(null), $(undefined), $(false)
    if ( !selector ) {
      return this;
    }

    // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)
    root = root || rootjQuery;

    // Handle HTML strings
    if ( typeof selector === "string" ) {
      if ( selector[ 0 ] === "<" &&
        selector[ selector.length - 1 ] === ">" &&
        selector.length >= 3 ) {

        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [ null, selector, null ];

      } else {
        match = rquickExpr.exec( selector );
      }

      // Match html or make sure no context is specified for #id
      if ( match && ( match[ 1 ] || !context ) ) {

        // HANDLE: $(html) -> $(array)
        if ( match[ 1 ] ) {
          context = context instanceof jQuery ? context[ 0 ] : context;

          // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present
          jQuery.merge( this, jQuery.parseHTML(
            match[ 1 ],
            context && context.nodeType ? context.ownerDocument || context : document,
            true
          ) );

          // HANDLE: $(html, props)
          if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
            for ( match in context ) {

              // Properties of context are called as methods if possible
              if ( isFunction( this[ match ] ) ) {
                this[ match ]( context[ match ] );

              // ...and otherwise set as attributes
              } else {
                this.attr( match, context[ match ] );
              }
            }
          }

          return this;

        // HANDLE: $(#id)
        } else {
          elem = document.getElementById( match[ 2 ] );

          if ( elem ) {

            // Inject the element directly into the jQuery object
            this[ 0 ] = elem;
            this.length = 1;
          }
          return this;
        }

      // HANDLE: $(expr, $(...))
      } else if ( !context || context.jquery ) {
        return ( context || root ).find( selector );

      // HANDLE: $(expr, context)
      // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor( context ).find( selector );
      }

    // HANDLE: $(DOMElement)
    } else if ( selector.nodeType ) {
      this[ 0 ] = selector;
      this.length = 1;
      return this;

    // HANDLE: $(function)
    // Shortcut for document ready
    } else if ( isFunction( selector ) ) {
      return root.ready !== undefined ?
        root.ready( selector ) :

        // Execute immediately if ready is not present
        selector( jQuery );
    }

    return jQuery.makeArray( selector, this );
  };

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

  // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };

jQuery.fn.extend( {
  has: function( target ) {
    var targets = jQuery( target, this ),
      l = targets.length;

    return this.filter( function() {
      var i = 0;
      for ( ; i < l; i++ ) {
        if ( jQuery.contains( this, targets[ i ] ) ) {
          return true;
        }
      }
    } );
  },

  closest: function( selectors, context ) {
    var cur,
      i = 0,
      l = this.length,
      matched = [],
      targets = typeof selectors !== "string" && jQuery( selectors );

    // Positional selectors never match, since there's no _selection_ context
    if ( !rneedsContext.test( selectors ) ) {
      for ( ; i < l; i++ ) {
        for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

          // Always skip document fragments
          if ( cur.nodeType < 11 && ( targets ?
            targets.index( cur ) > -1 :

            // Don't pass non-elements to Sizzle
            cur.nodeType === 1 &&
              jQuery.find.matchesSelector( cur, selectors ) ) ) {

            matched.push( cur );
            break;
          }
        }
      }
    }

    return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
  },

  // Determine the position of an element within the set
  index: function( elem ) {

    // No argument, return index in parent
    if ( !elem ) {
      return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
    }

    // Index in selector
    if ( typeof elem === "string" ) {
      return indexOf.call( jQuery( elem ), this[ 0 ] );
    }

    // Locate the position of the desired element
    return indexOf.call( this,

      // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[ 0 ] : elem
    );
  },

  add: function( selector, context ) {
    return this.pushStack(
      jQuery.uniqueSort(
        jQuery.merge( this.get(), jQuery( selector, context ) )
      )
    );
  },

  addBack: function( selector ) {
    return this.add( selector == null ?
      this.prevObject : this.prevObject.filter( selector )
    );
  }
} );

function sibling( cur, dir ) {
  while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
  return cur;
}

jQuery.each( {
  parent: function( elem ) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },
  parents: function( elem ) {
    return dir( elem, "parentNode" );
  },
  parentsUntil: function( elem, _i, until ) {
    return dir( elem, "parentNode", until );
  },
  next: function( elem ) {
    return sibling( elem, "nextSibling" );
  },
  prev: function( elem ) {
    return sibling( elem, "previousSibling" );
  },
  nextAll: function( elem ) {
    return dir( elem, "nextSibling" );
  },
  prevAll: function( elem ) {
    return dir( elem, "previousSibling" );
  },
  nextUntil: function( elem, _i, until ) {
    return dir( elem, "nextSibling", until );
  },
  prevUntil: function( elem, _i, until ) {
    return dir( elem, "previousSibling", until );
  },
  siblings: function( elem ) {
    return siblings( ( elem.parentNode || {} ).firstChild, elem );
  },
  children: function( elem ) {
    return siblings( elem.firstChild );
  },
  contents: function( elem ) {
    if ( elem.contentDocument != null &&

      // Support: IE 11+
      // <object> elements with no `data` attribute has an object
      // `contentDocument` with a `null` prototype.
      getProto( elem.contentDocument ) ) {

      return elem.contentDocument;
    }

    // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
    // Treat the template element as a regular one in browsers that
    // don't support it.
    if ( nodeName( elem, "template" ) ) {
      elem = elem.content || elem;
    }

    return jQuery.merge( [], elem.childNodes );
  }
}, function( name, fn ) {
  jQuery.fn[ name ] = function( until, selector ) {
    var matched = jQuery.map( this, fn, until );

    if ( name.slice( -5 ) !== "Until" ) {
      selector = until;
    }

    if ( selector && typeof selector === "string" ) {
      matched = jQuery.filter( selector, matched );
    }

    if ( this.length > 1 ) {

      // Remove duplicates
      if ( !guaranteedUnique[ name ] ) {
        jQuery.uniqueSort( matched );
      }

      // Reverse order for parents* and prev-derivatives
      if ( rparentsprev.test( name ) ) {
        matched.reverse();
      }
    }

    return this.pushStack( matched );
  };
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
  var object = {};
  jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
    object[ flag ] = true;
  } );
  return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  options: an optional list of space-separated options that will change how
 *      the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *  once:     will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:     will keep track of previous values and will call any callback added
 *          after the list has been fired right away with the latest "memorized"
 *          values (like a Deferred)
 *
 *  unique:     will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:  interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

  // Convert options from String-formatted to Object-formatted if needed
  // (we check in cache first)
  options = typeof options === "string" ?
    createOptions( options ) :
    jQuery.extend( {}, options );

  var // Flag to know if list is currently firing
    firing,

    // Last fire value for non-forgettable lists
    memory,

    // Flag to know if list was already fired
    fired,

    // Flag to prevent firing
    locked,

    // Actual callback list
    list = [],

    // Queue of execution data for repeatable lists
    queue = [],

    // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,

    // Fire callbacks
    fire = function() {

      // Enforce single-firing
      locked = locked || options.once;

      // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes
      fired = firing = true;
      for ( ; queue.length; firingIndex = -1 ) {
        memory = queue.shift();
        while ( ++firingIndex < list.length ) {

          // Run callback and check for early termination
          if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
            options.stopOnFalse ) {

            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      }

      // Forget the data if we're done with it
      if ( !options.memory ) {
        memory = false;
      }

      firing = false;

      // Clean up if we're done firing for good
      if ( locked ) {

        // Keep an empty list if we have data for future add calls
        if ( memory ) {
          list = [];

        // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },

    // Actual Callbacks object
    self = {

      // Add a callback or a collection of callbacks to the list
      add: function() {
        if ( list ) {

          // If we have memory from a past run, we should fire after adding
          if ( memory && !firing ) {
            firingIndex = list.length - 1;
            queue.push( memory );
          }

          ( function add( args ) {
            jQuery.each( args, function( _, arg ) {
              if ( isFunction( arg ) ) {
                if ( !options.unique || !self.has( arg ) ) {
                  list.push( arg );
                }
              } else if ( arg && arg.length && toType( arg ) !== "string" ) {

                // Inspect recursively
                add( arg );
              }
            } );
          } )( arguments );

          if ( memory && !firing ) {
            fire();
          }
        }
        return this;
      },

      // Remove a callback from the list
      remove: function() {
        jQuery.each( arguments, function( _, arg ) {
          var index;
          while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
            list.splice( index, 1 );

            // Handle firing indexes
            if ( index <= firingIndex ) {
              firingIndex--;
            }
          }
        } );
        return this;
      },

      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function( fn ) {
        return fn ?
          jQuery.inArray( fn, list ) > -1 :
          list.length > 0;
      },

      // Remove all callbacks from the list
      empty: function() {
        if ( list ) {
          list = [];
        }
        return this;
      },

      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function() {
        locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function() {
        return !list;
      },

      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function() {
        locked = queue = [];
        if ( !memory && !firing ) {
          list = memory = "";
        }
        return this;
      },
      locked: function() {
        return !!locked;
      },

      // Call all callbacks with the given context and arguments
      fireWith: function( context, args ) {
        if ( !locked ) {
          args = args || [];
          args = [ context, args.slice ? args.slice() : args ];
          queue.push( args );
          if ( !firing ) {
            fire();
          }
        }
        return this;
      },

      // Call all the callbacks with the given arguments
      fire: function() {
        self.fireWith( this, arguments );
        return this;
      },

      // To know if the callbacks have already been called at least once
      fired: function() {
        return !!fired;
      }
    };

  return self;
};


function Identity( v ) {
  return v;
}
function Thrower( ex ) {
  throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
  var method;

  try {

    // Check for promise aspect first to privilege synchronous behavior
    if ( value && isFunction( ( method = value.promise ) ) ) {
      method.call( value ).done( resolve ).fail( reject );

    // Other thenables
    } else if ( value && isFunction( ( method = value.then ) ) ) {
      method.call( value, resolve, reject );

    // Other non-thenables
    } else {

      // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
      // * false: [ value ].slice( 0 ) => resolve( value )
      // * true: [ value ].slice( 1 ) => resolve()
      resolve.apply( undefined, [ value ].slice( noValue ) );
    }

  // For Promises/A+, convert exceptions into rejections
  // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
  // Deferred#then to conditionally suppress rejection.
  } catch ( value ) {

    // Support: Android 4.0 only
    // Strict mode functions invoked without .call/.apply get global-object context
    reject.apply( undefined, [ value ] );
  }
}

jQuery.extend( {

  Deferred: function( func ) {
    var tuples = [

        // action, add listener, callbacks,
        // ... .then handlers, argument index, [final state]
        [ "notify", "progress", jQuery.Callbacks( "memory" ),
          jQuery.Callbacks( "memory" ), 2 ],
        [ "resolve", "done", jQuery.Callbacks( "once memory" ),
          jQuery.Callbacks( "once memory" ), 0, "resolved" ],
        [ "reject", "fail", jQuery.Callbacks( "once memory" ),
          jQuery.Callbacks( "once memory" ), 1, "rejected" ]
      ],
      state = "pending",
      promise = {
        state: function() {
          return state;
        },
        always: function() {
          deferred.done( arguments ).fail( arguments );
          return this;
        },
        "catch": function( fn ) {
          return promise.then( null, fn );
        },

        // Keep pipe for back-compat
        pipe: function( /* fnDone, fnFail, fnProgress */ ) {
          var fns = arguments;

          return jQuery.Deferred( function( newDefer ) {
            jQuery.each( tuples, function( _i, tuple ) {

              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

              // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })
              deferred[ tuple[ 1 ] ]( function() {
                var returned = fn && fn.apply( this, arguments );
                if ( returned && isFunction( returned.promise ) ) {
                  returned.promise()
                    .progress( newDefer.notify )
                    .done( newDefer.resolve )
                    .fail( newDefer.reject );
                } else {
                  newDefer[ tuple[ 0 ] + "With" ](
                    this,
                    fn ? [ returned ] : arguments
                  );
                }
              } );
            } );
            fns = null;
          } ).promise();
        },
        then: function( onFulfilled, onRejected, onProgress ) {
          var maxDepth = 0;
          function resolve( depth, deferred, handler, special ) {
            return function() {
              var that = this,
                args = arguments,
                mightThrow = function() {
                  var returned, then;

                  // Support: Promises/A+ section 2.3.3.3.3
                  // https://promisesaplus.com/#point-59
                  // Ignore double-resolution attempts
                  if ( depth < maxDepth ) {
                    return;
                  }

                  returned = handler.apply( that, args );

                  // Support: Promises/A+ section 2.3.1
                  // https://promisesaplus.com/#point-48
                  if ( returned === deferred.promise() ) {
                    throw new TypeError( "Thenable self-resolution" );
                  }

                  // Support: Promises/A+ sections 2.3.3.1, 3.5
                  // https://promisesaplus.com/#point-54
                  // https://promisesaplus.com/#point-75
                  // Retrieve `then` only once
                  then = returned &&

                    // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    ( typeof returned === "object" ||
                      typeof returned === "function" ) &&
                    returned.then;

                  // Handle a returned thenable
                  if ( isFunction( then ) ) {

                    // Special processors (notify) just wait for resolution
                    if ( special ) {
                      then.call(
                        returned,
                        resolve( maxDepth, deferred, Identity, special ),
                        resolve( maxDepth, deferred, Thrower, special )
                      );

                    // Normal processors (resolve) also hook into progress
                    } else {

                      // ...and disregard older resolution values
                      maxDepth++;

                      then.call(
                        returned,
                        resolve( maxDepth, deferred, Identity, special ),
                        resolve( maxDepth, deferred, Thrower, special ),
                        resolve( maxDepth, deferred, Identity,
                          deferred.notifyWith )
                      );
                    }

                  // Handle all other returned values
                  } else {

                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if ( handler !== Identity ) {
                      that = undefined;
                      args = [ returned ];
                    }

                    // Process the value(s)
                    // Default process is resolve
                    ( special || deferred.resolveWith )( that, args );
                  }
                },

                // Only normal processors (resolve) catch and reject exceptions
                process = special ?
                  mightThrow :
                  function() {
                    try {
                      mightThrow();
                    } catch ( e ) {

                      if ( jQuery.Deferred.exceptionHook ) {
                        jQuery.Deferred.exceptionHook( e,
                          process.stackTrace );
                      }

                      // Support: Promises/A+ section 2.3.3.3.4.1
                      // https://promisesaplus.com/#point-61
                      // Ignore post-resolution exceptions
                      if ( depth + 1 >= maxDepth ) {

                        // Only substitute handlers pass on context
                        // and multiple values (non-spec behavior)
                        if ( handler !== Thrower ) {
                          that = undefined;
                          args = [ e ];
                        }

                        deferred.rejectWith( that, args );
                      }
                    }
                  };

              // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors
              if ( depth ) {
                process();
              } else {

                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if ( jQuery.Deferred.getStackHook ) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }
                window.setTimeout( process );
              }
            };
          }

          return jQuery.Deferred( function( newDefer ) {

            // progress_handlers.add( ... )
            tuples[ 0 ][ 3 ].add(
              resolve(
                0,
                newDefer,
                isFunction( onProgress ) ?
                  onProgress :
                  Identity,
                newDefer.notifyWith
              )
            );

            // fulfilled_handlers.add( ... )
            tuples[ 1 ][ 3 ].add(
              resolve(
                0,
                newDefer,
                isFunction( onFulfilled ) ?
                  onFulfilled :
                  Identity
              )
            );

            // rejected_handlers.add( ... )
            tuples[ 2 ][ 3 ].add(
              resolve(
                0,
                newDefer,
                isFunction( onRejected ) ?
                  onRejected :
                  Thrower
              )
            );
          } ).promise();
        },

        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function( obj ) {
          return obj != null ? jQuery.extend( obj, promise ) : promise;
        }
      },
      deferred = {};

    // Add list-specific methods
    jQuery.each( tuples, function( i, tuple ) {
      var list = tuple[ 2 ],
        stateString = tuple[ 5 ];

      // promise.progress = list.add
      // promise.done = list.add
      // promise.fail = list.add
      promise[ tuple[ 1 ] ] = list.add;

      // Handle state
      if ( stateString ) {
        list.add(
          function() {

            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            state = stateString;
          },

          // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[ 3 - i ][ 2 ].disable,

          // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[ 3 - i ][ 3 ].disable,

          // progress_callbacks.lock
          tuples[ 0 ][ 2 ].lock,

          // progress_handlers.lock
          tuples[ 0 ][ 3 ].lock
        );
      }

      // progress_handlers.fire
      // fulfilled_handlers.fire
      // rejected_handlers.fire
      list.add( tuple[ 3 ].fire );

      // deferred.notify = function() { deferred.notifyWith(...) }
      // deferred.resolve = function() { deferred.resolveWith(...) }
      // deferred.reject = function() { deferred.rejectWith(...) }
      deferred[ tuple[ 0 ] ] = function() {
        deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
        return this;
      };

      // deferred.notifyWith = list.fireWith
      // deferred.resolveWith = list.fireWith
      // deferred.rejectWith = list.fireWith
      deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
    } );

    // Make the deferred a promise
    promise.promise( deferred );

    // Call given func if any
    if ( func ) {
      func.call( deferred, deferred );
    }

    // All done!
    return deferred;
  },

  // Deferred helper
  when: function( singleValue ) {
    var

      // count of uncompleted subordinates
      remaining = arguments.length,

      // count of unprocessed arguments
      i = remaining,

      // subordinate fulfillment data
      resolveContexts = Array( i ),
      resolveValues = slice.call( arguments ),

      // the master Deferred
      master = jQuery.Deferred(),

      // subordinate callback factory
      updateFunc = function( i ) {
        return function( value ) {
          resolveContexts[ i ] = this;
          resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
          if ( !( --remaining ) ) {
            master.resolveWith( resolveContexts, resolveValues );
          }
        };
      };

    // Single- and empty arguments are adopted like Promise.resolve
    if ( remaining <= 1 ) {
      adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
        !remaining );

      // Use .then() to unwrap secondary thenables (cf. gh-3000)
      if ( master.state() === "pending" ||
        isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

        return master.then();
      }
    }

    // Multiple arguments are aggregated like Promise.all array elements
    while ( i-- ) {
      adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
    }

    return master.promise();
  }
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

  // Support: IE 8 - 9 only
  // Console exists when dev tools are open, which can happen at any time
  if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
    window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
  }
};




jQuery.readyException = function( error ) {
  window.setTimeout( function() {
    throw error;
  } );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

  readyList
    .then( fn )

    // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    .catch( function( error ) {
      jQuery.readyException( error );
    } );

  return this;
};

jQuery.extend( {

  // Is the DOM ready to be used? Set to true once it occurs.
  isReady: false,

  // A counter to track how many items to wait for before
  // the ready event fires. See #6781
  readyWait: 1,

  // Handle when the DOM is ready
  ready: function( wait ) {

    // Abort if there are pending holds or we're already ready
    if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
      return;
    }

    // Remember that the DOM is ready
    jQuery.isReady = true;

    // If a normal DOM Ready event fired, decrement, and wait if need be
    if ( wait !== true && --jQuery.readyWait > 0 ) {
      return;
    }

    // If there are functions bound, to execute
    readyList.resolveWith( document, [ jQuery ] );
  }
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
  document.removeEventListener( "DOMContentLoaded", completed );
  window.removeEventListener( "load", completed );
  jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
  ( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

  // Handle it asynchronously to allow scripts the opportunity to delay ready
  window.setTimeout( jQuery.ready );

} else {

  // Use the handy event callback
  document.addEventListener( "DOMContentLoaded", completed );

  // A fallback to window.onload, that will always work
  window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
  var i = 0,
    len = elems.length,
    bulk = key == null;

  // Sets many values
  if ( toType( key ) === "object" ) {
    chainable = true;
    for ( i in key ) {
      access( elems, fn, i, key[ i ], true, emptyGet, raw );
    }

  // Sets one value
  } else if ( value !== undefined ) {
    chainable = true;

    if ( !isFunction( value ) ) {
      raw = true;
    }

    if ( bulk ) {

      // Bulk operations run against the entire set
      if ( raw ) {
        fn.call( elems, value );
        fn = null;

      // ...except when executing function values
      } else {
        bulk = fn;
        fn = function( elem, _key, value ) {
          return bulk.call( jQuery( elem ), value );
        };
      }
    }

    if ( fn ) {
      for ( ; i < len; i++ ) {
        fn(
          elems[ i ], key, raw ?
          value :
          value.call( elems[ i ], i, fn( elems[ i ], key ) )
        );
      }
    }
  }

  if ( chainable ) {
    return elems;
  }

  // Gets
  if ( bulk ) {
    return fn.call( elems );
  }

  return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
  rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
  return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
  return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

  // Accepts only:
  //  - Node
  //    - Node.ELEMENT_NODE
  //    - Node.DOCUMENT_NODE
  //  - Object
  //    - Any
  return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
  this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

  cache: function( owner ) {

    // Check if the owner object already has a cache
    var value = owner[ this.expando ];

    // If not, create one
    if ( !value ) {
      value = {};

      // We can accept data for non-element nodes in modern browsers,
      // but we should not, see #8335.
      // Always return an empty object.
      if ( acceptData( owner ) ) {

        // If it is a node unlikely to be stringify-ed or looped over
        // use plain assignment
        if ( owner.nodeType ) {
          owner[ this.expando ] = value;

        // Otherwise secure it in a non-enumerable property
        // configurable must be true to allow the property to be
        // deleted when data is removed
        } else {
          Object.defineProperty( owner, this.expando, {
            value: value,
            configurable: true
          } );
        }
      }
    }

    return value;
  },
  set: function( owner, data, value ) {
    var prop,
      cache = this.cache( owner );

    // Handle: [ owner, key, value ] args
    // Always use camelCase key (gh-2257)
    if ( typeof data === "string" ) {
      cache[ camelCase( data ) ] = value;

    // Handle: [ owner, { properties } ] args
    } else {

      // Copy the properties one-by-one to the cache object
      for ( prop in data ) {
        cache[ camelCase( prop ) ] = data[ prop ];
      }
    }
    return cache;
  },
  get: function( owner, key ) {
    return key === undefined ?
      this.cache( owner ) :

      // Always use camelCase key (gh-2257)
      owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
  },
  access: function( owner, key, value ) {

    // In cases where either:
    //
    //   1. No key was specified
    //   2. A string key was specified, but no value provided
    //
    // Take the "read" path and allow the get method to determine
    // which value to return, respectively either:
    //
    //   1. The entire cache object
    //   2. The data stored at the key
    //
    if ( key === undefined ||
        ( ( key && typeof key === "string" ) && value === undefined ) ) {

      return this.get( owner, key );
    }

    // When the key is not a string, or both a key and value
    // are specified, set or extend (existing objects) with either:
    //
    //   1. An object of properties
    //   2. A key and value
    //
    this.set( owner, key, value );

    // Since the "set" path can have two possible entry points
    // return the expected data based on which path was taken[*]
    return value !== undefined ? value : key;
  },
  remove: function( owner, key ) {
    var i,
      cache = owner[ this.expando ];

    if ( cache === undefined ) {
      return;
    }

    if ( key !== undefined ) {

      // Support array or space separated string of keys
      if ( Array.isArray( key ) ) {

        // If key is an array of keys...
        // We always set camelCase keys, so remove that.
        key = key.map( camelCase );
      } else {
        key = camelCase( key );

        // If a key with the spaces exists, use it.
        // Otherwise, create an array by matching non-whitespace
        key = key in cache ?
          [ key ] :
          ( key.match( rnothtmlwhite ) || [] );
      }

      i = key.length;

      while ( i-- ) {
        delete cache[ key[ i ] ];
      }
    }

    // Remove the expando if there's no more data
    if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

      // Support: Chrome <=35 - 45
      // Webkit & Blink performance suffers when deleting properties
      // from DOM nodes, so set to undefined instead
      // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
      if ( owner.nodeType ) {
        owner[ this.expando ] = undefined;
      } else {
        delete owner[ this.expando ];
      }
    }
  },
  hasData: function( owner ) {
    var cache = owner[ this.expando ];
    return cache !== undefined && !jQuery.isEmptyObject( cache );
  }
};
var dataPriv = new Data();

var dataUser = new Data();



//  Implementation Summary
//
//  1. Enforce API surface and semantic compatibility with 1.9.x branch
//  2. Improve the module's maintainability by reducing the storage
//    paths to a single mechanism.
//  3. Use the same single mechanism to support "private" and "user" data.
//  4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//  5. Avoid exposing implementation details on user objects (eg. expando properties)
//  6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
  rmultiDash = /[A-Z]/g;

function getData( data ) {
  if ( data === "true" ) {
    return true;
  }

  if ( data === "false" ) {
    return false;
  }

  if ( data === "null" ) {
    return null;
  }

  // Only convert to a number if it doesn't change the string
  if ( data === +data + "" ) {
    return +data;
  }

  if ( rbrace.test( data ) ) {
    return JSON.parse( data );
  }

  return data;
}

function dataAttr( elem, key, data ) {
  var name;

  // If nothing was found internally, try to fetch any
  // data from the HTML5 data-* attribute
  if ( data === undefined && elem.nodeType === 1 ) {
    name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
    data = elem.getAttribute( name );

    if ( typeof data === "string" ) {
      try {
        data = getData( data );
      } catch ( e ) {}

      // Make sure we set the data so it isn't changed later
      dataUser.set( elem, key, data );
    } else {
      data = undefined;
    }
  }
  return data;
}

jQuery.extend( {
  hasData: function( elem ) {
    return dataUser.hasData( elem ) || dataPriv.hasData( elem );
  },

  data: function( elem, name, data ) {
    return dataUser.access( elem, name, data );
  },

  removeData: function( elem, name ) {
    dataUser.remove( elem, name );
  },

  // TODO: Now that all calls to _data and _removeData have been replaced
  // with direct calls to dataPriv methods, these can be deprecated.
  _data: function( elem, name, data ) {
    return dataPriv.access( elem, name, data );
  },

  _removeData: function( elem, name ) {
    dataPriv.remove( elem, name );
  }
} );

jQuery.fn.extend( {
  data: function( key, value ) {
    var i, name, data,
      elem = this[ 0 ],
      attrs = elem && elem.attributes;

    // Gets all values
    if ( key === undefined ) {
      if ( this.length ) {
        data = dataUser.get( elem );

        if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
          i = attrs.length;
          while ( i-- ) {

            // Support: IE 11 only
            // The attrs elements can be null (#14894)
            if ( attrs[ i ] ) {
              name = attrs[ i ].name;
              if ( name.indexOf( "data-" ) === 0 ) {
                name = camelCase( name.slice( 5 ) );
                dataAttr( elem, name, data[ name ] );
              }
            }
          }
          dataPriv.set( elem, "hasDataAttrs", true );
        }
      }

      return data;
    }

    // Sets multiple values
    if ( typeof key === "object" ) {
      return this.each( function() {
        dataUser.set( this, key );
      } );
    }

    return access( this, function( value ) {
      var data;

      // The calling jQuery object (element matches) is not empty
      // (and therefore has an element appears at this[ 0 ]) and the
      // `value` parameter was not undefined. An empty jQuery object
      // will result in `undefined` for elem = this[ 0 ] which will
      // throw an exception if an attempt to read a data cache is made.
      if ( elem && value === undefined ) {

        // Attempt to get data from the cache
        // The key will always be camelCased in Data
        data = dataUser.get( elem, key );
        if ( data !== undefined ) {
          return data;
        }

        // Attempt to "discover" the data in
        // HTML5 custom data-* attrs
        data = dataAttr( elem, key );
        if ( data !== undefined ) {
          return data;
        }

        // We tried really hard, but the data doesn't exist.
        return;
      }

      // Set the data...
      this.each( function() {

        // We always store the camelCased key
        dataUser.set( this, key, value );
      } );
    }, null, value, arguments.length > 1, null, true );
  },

  removeData: function( key ) {
    return this.each( function() {
      dataUser.remove( this, key );
    } );
  }
} );


jQuery.extend( {
  queue: function( elem, type, data ) {
    var queue;

    if ( elem ) {
      type = ( type || "fx" ) + "queue";
      queue = dataPriv.get( elem, type );

      // Speed up dequeue by getting out quickly if this is just a lookup
      if ( data ) {
        if ( !queue || Array.isArray( data ) ) {
          queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
        } else {
          queue.push( data );
        }
      }
      return queue || [];
    }
  },

  dequeue: function( elem, type ) {
    type = type || "fx";

    var queue = jQuery.queue( elem, type ),
      startLength = queue.length,
      fn = queue.shift(),
      hooks = jQuery._queueHooks( elem, type ),
      next = function() {
        jQuery.dequeue( elem, type );
      };

    // If the fx queue is dequeued, always remove the progress sentinel
    if ( fn === "inprogress" ) {
      fn = queue.shift();
      startLength--;
    }

    if ( fn ) {

      // Add a progress sentinel to prevent the fx queue from being
      // automatically dequeued
      if ( type === "fx" ) {
        queue.unshift( "inprogress" );
      }

      // Clear up the last queue stop function
      delete hooks.stop;
      fn.call( elem, next, hooks );
    }

    if ( !startLength && hooks ) {
      hooks.empty.fire();
    }
  },

  // Not public - generate a queueHooks object, or return the current one
  _queueHooks: function( elem, type ) {
    var key = type + "queueHooks";
    return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
      empty: jQuery.Callbacks( "once memory" ).add( function() {
        dataPriv.remove( elem, [ type + "queue", key ] );
      } )
    } );
  }
} );

jQuery.fn.extend( {
  queue: function( type, data ) {
    var setter = 2;

    if ( typeof type !== "string" ) {
      data = type;
      type = "fx";
      setter--;
    }

    if ( arguments.length < setter ) {
      return jQuery.queue( this[ 0 ], type );
    }

    return data === undefined ?
      this :
      this.each( function() {
        var queue = jQuery.queue( this, type, data );

        // Ensure a hooks for this queue
        jQuery._queueHooks( this, type );

        if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
          jQuery.dequeue( this, type );
        }
      } );
  },
  dequeue: function( type ) {
    return this.each( function() {
      jQuery.dequeue( this, type );
    } );
  },
  clearQueue: function( type ) {
    return this.queue( type || "fx", [] );
  },

  // Get a promise resolved when queues of a certain type
  // are emptied (fx is the type by default)
  promise: function( type, obj ) {
    var tmp,
      count = 1,
      defer = jQuery.Deferred(),
      elements = this,
      i = this.length,
      resolve = function() {
        if ( !( --count ) ) {
          defer.resolveWith( elements, [ elements ] );
        }
      };

    if ( typeof type !== "string" ) {
      obj = type;
      type = undefined;
    }
    type = type || "fx";

    while ( i-- ) {
      tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
      if ( tmp && tmp.empty ) {
        count++;
        tmp.empty.add( resolve );
      }
    }
    resolve();
    return defer.promise( obj );
  }
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



  var isAttached = function( elem ) {
      return jQuery.contains( elem.ownerDocument, elem );
    },
    composed = { composed: true };

  // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  // Check attachment across shadow DOM boundaries when possible (gh-3504)
  // Support: iOS 10.0-10.2 only
  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  // leading to errors. We need to check for `getRootNode`.
  if ( documentElement.getRootNode ) {
    isAttached = function( elem ) {
      return jQuery.contains( elem.ownerDocument, elem ) ||
        elem.getRootNode( composed ) === elem.ownerDocument;
    };
  }
var isHiddenWithinTree = function( elem, el ) {

    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;

    // Inline style trumps all
    return elem.style.display === "none" ||
      elem.style.display === "" &&

      // Otherwise, check computed style
      // Support: Firefox <=43 - 45
      // Disconnected elements can have computed display: none, so first confirm that elem is
      // in the document.
      isAttached( elem ) &&

      jQuery.css( elem, "display" ) === "none";
  };



function adjustCSS( elem, prop, valueParts, tween ) {
  var adjusted, scale,
    maxIterations = 20,
    currentValue = tween ?
      function() {
        return tween.cur();
      } :
      function() {
        return jQuery.css( elem, prop, "" );
      },
    initial = currentValue(),
    unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

    // Starting value computation is required for potential unit mismatches
    initialInUnit = elem.nodeType &&
      ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
      rcssNum.exec( jQuery.css( elem, prop ) );

  if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

    // Support: Firefox <=54
    // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
    initial = initial / 2;

    // Trust units reported by jQuery.css
    unit = unit || initialInUnit[ 3 ];

    // Iteratively approximate from a nonzero starting point
    initialInUnit = +initial || 1;

    while ( maxIterations-- ) {

      // Evaluate and update our best guess (doubling guesses that zero out).
      // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
      jQuery.style( elem, prop, initialInUnit + unit );
      if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
        maxIterations = 0;
      }
      initialInUnit = initialInUnit / scale;

    }

    initialInUnit = initialInUnit * 2;
    jQuery.style( elem, prop, initialInUnit + unit );

    // Make sure we update the tween properties later on
    valueParts = valueParts || [];
  }

  if ( valueParts ) {
    initialInUnit = +initialInUnit || +initial || 0;

    // Apply relative offset (+=/-=) if specified
    adjusted = valueParts[ 1 ] ?
      initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
      +valueParts[ 2 ];
    if ( tween ) {
      tween.unit = unit;
      tween.start = initialInUnit;
      tween.end = adjusted;
    }
  }
  return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
  var temp,
    doc = elem.ownerDocument,
    nodeName = elem.nodeName,
    display = defaultDisplayMap[ nodeName ];

  if ( display ) {
    return display;
  }

  temp = doc.body.appendChild( doc.createElement( nodeName ) );
  display = jQuery.css( temp, "display" );

  temp.parentNode.removeChild( temp );

  if ( display === "none" ) {
    display = "block";
  }
  defaultDisplayMap[ nodeName ] = display;

  return display;
}

function showHide( elements, show ) {
  var display, elem,
    values = [],
    index = 0,
    length = elements.length;

  // Determine new display value for elements that need to change
  for ( ; index < length; index++ ) {
    elem = elements[ index ];
    if ( !elem.style ) {
      continue;
    }

    display = elem.style.display;
    if ( show ) {

      // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
      // check is required in this first loop unless we have a nonempty display value (either
      // inline or about-to-be-restored)
      if ( display === "none" ) {
        values[ index ] = dataPriv.get( elem, "display" ) || null;
        if ( !values[ index ] ) {
          elem.style.display = "";
        }
      }
      if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
        values[ index ] = getDefaultDisplay( elem );
      }
    } else {
      if ( display !== "none" ) {
        values[ index ] = "none";

        // Remember what we're overwriting
        dataPriv.set( elem, "display", display );
      }
    }
  }

  // Set the display of the elements in a second loop to avoid constant reflow
  for ( index = 0; index < length; index++ ) {
    if ( values[ index ] != null ) {
      elements[ index ].style.display = values[ index ];
    }
  }

  return elements;
}

jQuery.fn.extend( {
  show: function() {
    return showHide( this, true );
  },
  hide: function() {
    return showHide( this );
  },
  toggle: function( state ) {
    if ( typeof state === "boolean" ) {
      return state ? this.show() : this.hide();
    }

    return this.each( function() {
      if ( isHiddenWithinTree( this ) ) {
        jQuery( this ).show();
      } else {
        jQuery( this ).hide();
      }
    } );
  }
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
  var fragment = document.createDocumentFragment(),
    div = fragment.appendChild( document.createElement( "div" ) ),
    input = document.createElement( "input" );

  // Support: Android 4.0 - 4.3 only
  // Check state lost if the name is set (#11217)
  // Support: Windows Web Apps (WWA)
  // `name` and `type` must use .setAttribute for WWA (#14901)
  input.setAttribute( "type", "radio" );
  input.setAttribute( "checked", "checked" );
  input.setAttribute( "name", "t" );

  div.appendChild( input );

  // Support: Android <=4.1 only
  // Older WebKit doesn't clone checked state correctly in fragments
  support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

  // Support: IE <=11 only
  // Make sure textarea (and checkbox) defaultValue is properly cloned
  div.innerHTML = "<textarea>x</textarea>";
  support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

  // Support: IE <=9 only
  // IE <=9 replaces <option> tags with their contents when inserted outside of
  // the select element.
  div.innerHTML = "<option></option>";
  support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

  // XHTML parsers do not magically insert elements in the
  // same way that tag soup parsers do. So we cannot shorten
  // this by omitting <tbody> or other required elements.
  thead: [ 1, "<table>", "</table>" ],
  col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
  tr: [ 2, "<table><tbody>", "</tbody></table>" ],
  td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

  _default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
  wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

  // Support: IE <=9 - 11 only
  // Use typeof to avoid zero-argument method invocation on host objects (#15151)
  var ret;

  if ( typeof context.getElementsByTagName !== "undefined" ) {
    ret = context.getElementsByTagName( tag || "*" );

  } else if ( typeof context.querySelectorAll !== "undefined" ) {
    ret = context.querySelectorAll( tag || "*" );

  } else {
    ret = [];
  }

  if ( tag === undefined || tag && nodeName( context, tag ) ) {
    return jQuery.merge( [ context ], ret );
  }

  return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
  var i = 0,
    l = elems.length;

  for ( ; i < l; i++ ) {
    dataPriv.set(
      elems[ i ],
      "globalEval",
      !refElements || dataPriv.get( refElements[ i ], "globalEval" )
    );
  }
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
  var elem, tmp, tag, wrap, attached, j,
    fragment = context.createDocumentFragment(),
    nodes = [],
    i = 0,
    l = elems.length;

  for ( ; i < l; i++ ) {
    elem = elems[ i ];

    if ( elem || elem === 0 ) {

      // Add nodes directly
      if ( toType( elem ) === "object" ) {

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

      // Convert non-html into a text node
      } else if ( !rhtml.test( elem ) ) {
        nodes.push( context.createTextNode( elem ) );

      // Convert html into DOM nodes
      } else {
        tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

        // Deserialize a standard representation
        tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
        wrap = wrapMap[ tag ] || wrapMap._default;
        tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

        // Descend through wrappers to the right content
        j = wrap[ 0 ];
        while ( j-- ) {
          tmp = tmp.lastChild;
        }

        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        jQuery.merge( nodes, tmp.childNodes );

        // Remember the top-level container
        tmp = fragment.firstChild;

        // Ensure the created nodes are orphaned (#12392)
        tmp.textContent = "";
      }
    }
  }

  // Remove wrapper from fragment
  fragment.textContent = "";

  i = 0;
  while ( ( elem = nodes[ i++ ] ) ) {

    // Skip elements already in the context collection (trac-4087)
    if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
      if ( ignored ) {
        ignored.push( elem );
      }
      continue;
    }

    attached = isAttached( elem );

    // Append to fragment
    tmp = getAll( fragment.appendChild( elem ), "script" );

    // Preserve script evaluation history
    if ( attached ) {
      setGlobalEval( tmp );
    }

    // Capture executables
    if ( scripts ) {
      j = 0;
      while ( ( elem = tmp[ j++ ] ) ) {
        if ( rscriptType.test( elem.type || "" ) ) {
          scripts.push( elem );
        }
      }
    }
  }

  return fragment;
}


var
  rkeyEvent = /^key/,
  rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
  rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
  return true;
}

function returnFalse() {
  return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
  return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
  try {
    return document.activeElement;
  } catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
  var origFn, type;

  // Types can be a map of types/handlers
  if ( typeof types === "object" ) {

    // ( types-Object, selector, data )
    if ( typeof selector !== "string" ) {

      // ( types-Object, data )
      data = data || selector;
      selector = undefined;
    }
    for ( type in types ) {
      on( elem, type, selector, data, types[ type ], one );
    }
    return elem;
  }

  if ( data == null && fn == null ) {

    // ( types, fn )
    fn = selector;
    data = selector = undefined;
  } else if ( fn == null ) {
    if ( typeof selector === "string" ) {

      // ( types, selector, fn )
      fn = data;
      data = undefined;
    } else {

      // ( types, data, fn )
      fn = data;
      data = selector;
      selector = undefined;
    }
  }
  if ( fn === false ) {
    fn = returnFalse;
  } else if ( !fn ) {
    return elem;
  }

  if ( one === 1 ) {
    origFn = fn;
    fn = function( event ) {

      // Can use an empty set, since event contains the info
      jQuery().off( event );
      return origFn.apply( this, arguments );
    };

    // Use same guid so caller can remove using origFn
    fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
  }
  return elem.each( function() {
    jQuery.event.add( this, types, fn, data, selector );
  } );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

  global: {},

  add: function( elem, types, handler, data, selector ) {

    var handleObjIn, eventHandle, tmp,
      events, t, handleObj,
      special, handlers, type, namespaces, origType,
      elemData = dataPriv.get( elem );

    // Only attach events to objects that accept data
    if ( !acceptData( elem ) ) {
      return;
    }

    // Caller can pass in an object of custom data in lieu of the handler
    if ( handler.handler ) {
      handleObjIn = handler;
      handler = handleObjIn.handler;
      selector = handleObjIn.selector;
    }

    // Ensure that invalid selectors throw exceptions at attach time
    // Evaluate against documentElement in case elem is a non-element node (e.g., document)
    if ( selector ) {
      jQuery.find.matchesSelector( documentElement, selector );
    }

    // Make sure that the handler has a unique ID, used to find/remove it later
    if ( !handler.guid ) {
      handler.guid = jQuery.guid++;
    }

    // Init the element's event structure and main handler, if this is the first
    if ( !( events = elemData.events ) ) {
      events = elemData.events = Object.create( null );
    }
    if ( !( eventHandle = elemData.handle ) ) {
      eventHandle = elemData.handle = function( e ) {

        // Discard the second event of a jQuery.event.trigger() and
        // when an event is called after a page has unloaded
        return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
          jQuery.event.dispatch.apply( elem, arguments ) : undefined;
      };
    }

    // Handle multiple events separated by a space
    types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
    t = types.length;
    while ( t-- ) {
      tmp = rtypenamespace.exec( types[ t ] ) || [];
      type = origType = tmp[ 1 ];
      namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

      // There *must* be a type, no attaching namespace-only handlers
      if ( !type ) {
        continue;
      }

      // If event changes its type, use the special event handlers for the changed type
      special = jQuery.event.special[ type ] || {};

      // If selector defined, determine special event api type, otherwise given type
      type = ( selector ? special.delegateType : special.bindType ) || type;

      // Update special based on newly reset type
      special = jQuery.event.special[ type ] || {};

      // handleObj is passed to all event handlers
      handleObj = jQuery.extend( {
        type: type,
        origType: origType,
        data: data,
        handler: handler,
        guid: handler.guid,
        selector: selector,
        needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
        namespace: namespaces.join( "." )
      }, handleObjIn );

      // Init the event handler queue if we're the first
      if ( !( handlers = events[ type ] ) ) {
        handlers = events[ type ] = [];
        handlers.delegateCount = 0;

        // Only use addEventListener if the special events handler returns false
        if ( !special.setup ||
          special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

          if ( elem.addEventListener ) {
            elem.addEventListener( type, eventHandle );
          }
        }
      }

      if ( special.add ) {
        special.add.call( elem, handleObj );

        if ( !handleObj.handler.guid ) {
          handleObj.handler.guid = handler.guid;
        }
      }

      // Add to the element's handler list, delegates in front
      if ( selector ) {
        handlers.splice( handlers.delegateCount++, 0, handleObj );
      } else {
        handlers.push( handleObj );
      }

      // Keep track of which events have ever been used, for event optimization
      jQuery.event.global[ type ] = true;
    }

  },

  // Detach an event or set of events from an element
  remove: function( elem, types, handler, selector, mappedTypes ) {

    var j, origCount, tmp,
      events, t, handleObj,
      special, handlers, type, namespaces, origType,
      elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

    if ( !elemData || !( events = elemData.events ) ) {
      return;
    }

    // Once for each type.namespace in types; type may be omitted
    types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
    t = types.length;
    while ( t-- ) {
      tmp = rtypenamespace.exec( types[ t ] ) || [];
      type = origType = tmp[ 1 ];
      namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

      // Unbind all events (on this namespace, if provided) for the element
      if ( !type ) {
        for ( type in events ) {
          jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
        }
        continue;
      }

      special = jQuery.event.special[ type ] || {};
      type = ( selector ? special.delegateType : special.bindType ) || type;
      handlers = events[ type ] || [];
      tmp = tmp[ 2 ] &&
        new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

      // Remove matching events
      origCount = j = handlers.length;
      while ( j-- ) {
        handleObj = handlers[ j ];

        if ( ( mappedTypes || origType === handleObj.origType ) &&
          ( !handler || handler.guid === handleObj.guid ) &&
          ( !tmp || tmp.test( handleObj.namespace ) ) &&
          ( !selector || selector === handleObj.selector ||
            selector === "**" && handleObj.selector ) ) {
          handlers.splice( j, 1 );

          if ( handleObj.selector ) {
            handlers.delegateCount--;
          }
          if ( special.remove ) {
            special.remove.call( elem, handleObj );
          }
        }
      }

      // Remove generic event handler if we removed something and no more handlers exist
      // (avoids potential for endless recursion during removal of special event handlers)
      if ( origCount && !handlers.length ) {
        if ( !special.teardown ||
          special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

          jQuery.removeEvent( elem, type, elemData.handle );
        }

        delete events[ type ];
      }
    }

    // Remove data and the expando if it's no longer used
    if ( jQuery.isEmptyObject( events ) ) {
      dataPriv.remove( elem, "handle events" );
    }
  },

  dispatch: function( nativeEvent ) {

    var i, j, ret, matched, handleObj, handlerQueue,
      args = new Array( arguments.length ),

      // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix( nativeEvent ),

      handlers = (
          dataPriv.get( this, "events" ) || Object.create( null )
        )[ event.type ] || [],
      special = jQuery.event.special[ event.type ] || {};

    // Use the fix-ed jQuery.Event rather than the (read-only) native event
    args[ 0 ] = event;

    for ( i = 1; i < arguments.length; i++ ) {
      args[ i ] = arguments[ i ];
    }

    event.delegateTarget = this;

    // Call the preDispatch hook for the mapped type, and let it bail if desired
    if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
      return;
    }

    // Determine handlers
    handlerQueue = jQuery.event.handlers.call( this, event, handlers );

    // Run delegates first; they may want to stop propagation beneath us
    i = 0;
    while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
      event.currentTarget = matched.elem;

      j = 0;
      while ( ( handleObj = matched.handlers[ j++ ] ) &&
        !event.isImmediatePropagationStopped() ) {

        // If the event is namespaced, then each handler is only invoked if it is
        // specially universal or its namespaces are a superset of the event's.
        if ( !event.rnamespace || handleObj.namespace === false ||
          event.rnamespace.test( handleObj.namespace ) ) {

          event.handleObj = handleObj;
          event.data = handleObj.data;

          ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
            handleObj.handler ).apply( matched.elem, args );

          if ( ret !== undefined ) {
            if ( ( event.result = ret ) === false ) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }

    // Call the postDispatch hook for the mapped type
    if ( special.postDispatch ) {
      special.postDispatch.call( this, event );
    }

    return event.result;
  },

  handlers: function( event, handlers ) {
    var i, handleObj, sel, matchedHandlers, matchedSelectors,
      handlerQueue = [],
      delegateCount = handlers.delegateCount,
      cur = event.target;

    // Find delegate handlers
    if ( delegateCount &&

      // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType &&

      // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !( event.type === "click" && event.button >= 1 ) ) {

      for ( ; cur !== this; cur = cur.parentNode || this ) {

        // Don't check non-elements (#13208)
        // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
        if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
          matchedHandlers = [];
          matchedSelectors = {};
          for ( i = 0; i < delegateCount; i++ ) {
            handleObj = handlers[ i ];

            // Don't conflict with Object.prototype properties (#13203)
            sel = handleObj.selector + " ";

            if ( matchedSelectors[ sel ] === undefined ) {
              matchedSelectors[ sel ] = handleObj.needsContext ?
                jQuery( sel, this ).index( cur ) > -1 :
                jQuery.find( sel, this, null, [ cur ] ).length;
            }
            if ( matchedSelectors[ sel ] ) {
              matchedHandlers.push( handleObj );
            }
          }
          if ( matchedHandlers.length ) {
            handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
          }
        }
      }
    }

    // Add the remaining (directly-bound) handlers
    cur = this;
    if ( delegateCount < handlers.length ) {
      handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
    }

    return handlerQueue;
  },

  addProp: function( name, hook ) {
    Object.defineProperty( jQuery.Event.prototype, name, {
      enumerable: true,
      configurable: true,

      get: isFunction( hook ) ?
        function() {
          if ( this.originalEvent ) {
              return hook( this.originalEvent );
          }
        } :
        function() {
          if ( this.originalEvent ) {
              return this.originalEvent[ name ];
          }
        },

      set: function( value ) {
        Object.defineProperty( this, name, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: value
        } );
      }
    } );
  },

  fix: function( originalEvent ) {
    return originalEvent[ jQuery.expando ] ?
      originalEvent :
      new jQuery.Event( originalEvent );
  },

  special: {
    load: {

      // Prevent triggered image.load events from bubbling to window.load
      noBubble: true
    },
    click: {

      // Utilize native event to ensure correct state for checkable inputs
      setup: function( data ) {

        // For mutual compressibility with _default, replace `this` access with a local var.
        // `|| data` is dead code meant only to preserve the variable through minification.
        var el = this || data;

        // Claim the first handler
        if ( rcheckableType.test( el.type ) &&
          el.click && nodeName( el, "input" ) ) {

          // dataPriv.set( el, "click", ... )
          leverageNative( el, "click", returnTrue );
        }

        // Return false to allow normal processing in the caller
        return false;
      },
      trigger: function( data ) {

        // For mutual compressibility with _default, replace `this` access with a local var.
        // `|| data` is dead code meant only to preserve the variable through minification.
        var el = this || data;

        // Force setup before triggering a click
        if ( rcheckableType.test( el.type ) &&
          el.click && nodeName( el, "input" ) ) {

          leverageNative( el, "click" );
        }

        // Return non-false to allow normal event-path propagation
        return true;
      },

      // For cross-browser consistency, suppress native .click() on links
      // Also prevent it if we're currently inside a leveraged native-event stack
      _default: function( event ) {
        var target = event.target;
        return rcheckableType.test( target.type ) &&
          target.click && nodeName( target, "input" ) &&
          dataPriv.get( target, "click" ) ||
          nodeName( target, "a" );
      }
    },

    beforeunload: {
      postDispatch: function( event ) {

        // Support: Firefox 20+
        // Firefox doesn't alert if the returnValue field is not set.
        if ( event.result !== undefined && event.originalEvent ) {
          event.originalEvent.returnValue = event.result;
        }
      }
    }
  }
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

  // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
  if ( !expectSync ) {
    if ( dataPriv.get( el, type ) === undefined ) {
      jQuery.event.add( el, type, returnTrue );
    }
    return;
  }

  // Register the controller as a special universal handler for all event namespaces
  dataPriv.set( el, type, false );
  jQuery.event.add( el, type, {
    namespace: false,
    handler: function( event ) {
      var notAsync, result,
        saved = dataPriv.get( this, type );

      if ( ( event.isTrigger & 1 ) && this[ type ] ) {

        // Interrupt processing of the outer synthetic .trigger()ed event
        // Saved data should be false in such cases, but might be a leftover capture object
        // from an async native handler (gh-4350)
        if ( !saved.length ) {

          // Store arguments for use when handling the inner native event
          // There will always be at least one argument (an event object), so this array
          // will not be confused with a leftover capture object.
          saved = slice.call( arguments );
          dataPriv.set( this, type, saved );

          // Trigger the native event and capture its result
          // Support: IE <=9 - 11+
          // focus() and blur() are asynchronous
          notAsync = expectSync( this, type );
          this[ type ]();
          result = dataPriv.get( this, type );
          if ( saved !== result || notAsync ) {
            dataPriv.set( this, type, false );
          } else {
            result = {};
          }
          if ( saved !== result ) {

            // Cancel the outer synthetic event
            event.stopImmediatePropagation();
            event.preventDefault();
            return result.value;
          }

        // If this is an inner synthetic event for an event with a bubbling surrogate
        // (focus or blur), assume that the surrogate already propagated from triggering the
        // native event and prevent that from happening again here.
        // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
        // bubbling surrogate propagates *after* the non-bubbling base), but that seems
        // less bad than duplication.
        } else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
          event.stopPropagation();
        }

      // If this is a native event triggered above, everything is now in order
      // Fire an inner synthetic event with the original arguments
      } else if ( saved.length ) {

        // ...and capture the result
        dataPriv.set( this, type, {
          value: jQuery.event.trigger(

            // Support: IE <=9 - 11+
            // Extend with the prototype to reset the above stopImmediatePropagation()
            jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
            saved.slice( 1 ),
            this
          )
        } );

        // Abort handling of the native event
        event.stopImmediatePropagation();
      }
    }
  } );
}

jQuery.removeEvent = function( elem, type, handle ) {

  // This "if" is needed for plain objects
  if ( elem.removeEventListener ) {
    elem.removeEventListener( type, handle );
  }
};

jQuery.Event = function( src, props ) {

  // Allow instantiation without the 'new' keyword
  if ( !( this instanceof jQuery.Event ) ) {
    return new jQuery.Event( src, props );
  }

  // Event object
  if ( src && src.type ) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = src.defaultPrevented ||
        src.defaultPrevented === undefined &&

        // Support: Android <=2.3 only
        src.returnValue === false ?
      returnTrue :
      returnFalse;

    // Create target properties
    // Support: Safari <=6 - 7 only
    // Target should not be a text node (#504, #13143)
    this.target = ( src.target && src.target.nodeType === 3 ) ?
      src.target.parentNode :
      src.target;

    this.currentTarget = src.currentTarget;
    this.relatedTarget = src.relatedTarget;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if ( props ) {
    jQuery.extend( this, props );
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || Date.now();

  // Mark it as fixed
  this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
  constructor: jQuery.Event,
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse,
  isSimulated: false,

  preventDefault: function() {
    var e = this.originalEvent;

    this.isDefaultPrevented = returnTrue;

    if ( e && !this.isSimulated ) {
      e.preventDefault();
    }
  },
  stopPropagation: function() {
    var e = this.originalEvent;

    this.isPropagationStopped = returnTrue;

    if ( e && !this.isSimulated ) {
      e.stopPropagation();
    }
  },
  stopImmediatePropagation: function() {
    var e = this.originalEvent;

    this.isImmediatePropagationStopped = returnTrue;

    if ( e && !this.isSimulated ) {
      e.stopImmediatePropagation();
    }

    this.stopPropagation();
  }
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
  altKey: true,
  bubbles: true,
  cancelable: true,
  changedTouches: true,
  ctrlKey: true,
  detail: true,
  eventPhase: true,
  metaKey: true,
  pageX: true,
  pageY: true,
  shiftKey: true,
  view: true,
  "char": true,
  code: true,
  charCode: true,
  key: true,
  keyCode: true,
  button: true,
  buttons: true,
  clientX: true,
  clientY: true,
  offsetX: true,
  offsetY: true,
  pointerId: true,
  pointerType: true,
  screenX: true,
  screenY: true,
  targetTouches: true,
  toElement: true,
  touches: true,

  which: function( event ) {
    var button = event.button;

    // Add which for key events
    if ( event.which == null && rkeyEvent.test( event.type ) ) {
      return event.charCode != null ? event.charCode : event.keyCode;
    }

    // Add which for click: 1 === left; 2 === middle; 3 === right
    if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
      if ( button & 1 ) {
        return 1;
      }

      if ( button & 2 ) {
        return 3;
      }

      if ( button & 4 ) {
        return 2;
      }

      return 0;
    }

    return event.which;
  }
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
  jQuery.event.special[ type ] = {

    // Utilize native event if possible so blur/focus sequence is correct
    setup: function() {

      // Claim the first handler
      // dataPriv.set( this, "focus", ... )
      // dataPriv.set( this, "blur", ... )
      leverageNative( this, type, expectSync );

      // Return false to allow normal processing in the caller
      return false;
    },
    trigger: function() {

      // Force setup before trigger
      leverageNative( this, type );

      // Return non-false to allow normal event-path propagation
      return true;
    },

    delegateType: delegateType
  };
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
}, function( orig, fix ) {
  jQuery.event.special[ orig ] = {
    delegateType: fix,
    bindType: fix,

    handle: function( event ) {
      var ret,
        target = this,
        related = event.relatedTarget,
        handleObj = event.handleObj;

      // For mouseenter/leave call the handler if related is outside the target.
      // NB: No relatedTarget if the mouse left/entered the browser window
      if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
        event.type = handleObj.origType;
        ret = handleObj.handler.apply( this, arguments );
        event.type = fix;
      }
      return ret;
    }
  };
} );

jQuery.fn.extend( {

  on: function( types, selector, data, fn ) {
    return on( this, types, selector, data, fn );
  },
  one: function( types, selector, data, fn ) {
    return on( this, types, selector, data, fn, 1 );
  },
  off: function( types, selector, fn ) {
    var handleObj, type;
    if ( types && types.preventDefault && types.handleObj ) {

      // ( event )  dispatched jQuery.Event
      handleObj = types.handleObj;
      jQuery( types.delegateTarget ).off(
        handleObj.namespace ?
          handleObj.origType + "." + handleObj.namespace :
          handleObj.origType,
        handleObj.selector,
        handleObj.handler
      );
      return this;
    }
    if ( typeof types === "object" ) {

      // ( types-object [, selector] )
      for ( type in types ) {
        this.off( type, selector, types[ type ] );
      }
      return this;
    }
    if ( selector === false || typeof selector === "function" ) {

      // ( types [, fn] )
      fn = selector;
      selector = undefined;
    }
    if ( fn === false ) {
      fn = returnFalse;
    }
    return this.each( function() {
      jQuery.event.remove( this, types, fn, selector );
    } );
  }
} );


var

  // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,

  // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
  rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
  if ( nodeName( elem, "table" ) &&
    nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

    return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
  }

  return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
  elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
  return elem;
}
function restoreScript( elem ) {
  if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
    elem.type = elem.type.slice( 5 );
  } else {
    elem.removeAttribute( "type" );
  }

  return elem;
}

function cloneCopyEvent( src, dest ) {
  var i, l, type, pdataOld, udataOld, udataCur, events;

  if ( dest.nodeType !== 1 ) {
    return;
  }

  // 1. Copy private data: events, handlers, etc.
  if ( dataPriv.hasData( src ) ) {
    pdataOld = dataPriv.get( src );
    events = pdataOld.events;

    if ( events ) {
      dataPriv.remove( dest, "handle events" );

      for ( type in events ) {
        for ( i = 0, l = events[ type ].length; i < l; i++ ) {
          jQuery.event.add( dest, type, events[ type ][ i ] );
        }
      }
    }
  }

  // 2. Copy user data
  if ( dataUser.hasData( src ) ) {
    udataOld = dataUser.access( src );
    udataCur = jQuery.extend( {}, udataOld );

    dataUser.set( dest, udataCur );
  }
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
  var nodeName = dest.nodeName.toLowerCase();

  // Fails to persist the checked state of a cloned checkbox or radio button.
  if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
    dest.checked = src.checked;

  // Fails to return the selected option to the default selected state when cloning options
  } else if ( nodeName === "input" || nodeName === "textarea" ) {
    dest.defaultValue = src.defaultValue;
  }
}

function domManip( collection, args, callback, ignored ) {

  // Flatten any nested arrays
  args = flat( args );

  var fragment, first, scripts, hasScripts, node, doc,
    i = 0,
    l = collection.length,
    iNoClone = l - 1,
    value = args[ 0 ],
    valueIsFunction = isFunction( value );

  // We can't cloneNode fragments that contain checked, in WebKit
  if ( valueIsFunction ||
      ( l > 1 && typeof value === "string" &&
        !support.checkClone && rchecked.test( value ) ) ) {
    return collection.each( function( index ) {
      var self = collection.eq( index );
      if ( valueIsFunction ) {
        args[ 0 ] = value.call( this, index, self.html() );
      }
      domManip( self, args, callback, ignored );
    } );
  }

  if ( l ) {
    fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
    first = fragment.firstChild;

    if ( fragment.childNodes.length === 1 ) {
      fragment = first;
    }

    // Require either new content or an interest in ignored elements to invoke the callback
    if ( first || ignored ) {
      scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
      hasScripts = scripts.length;

      // Use the original fragment for the last item
      // instead of the first because it can end up
      // being emptied incorrectly in certain situations (#8070).
      for ( ; i < l; i++ ) {
        node = fragment;

        if ( i !== iNoClone ) {
          node = jQuery.clone( node, true, true );

          // Keep references to cloned scripts for later restoration
          if ( hasScripts ) {

            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge( scripts, getAll( node, "script" ) );
          }
        }

        callback.call( collection[ i ], node, i );
      }

      if ( hasScripts ) {
        doc = scripts[ scripts.length - 1 ].ownerDocument;

        // Reenable scripts
        jQuery.map( scripts, restoreScript );

        // Evaluate executable scripts on first document insertion
        for ( i = 0; i < hasScripts; i++ ) {
          node = scripts[ i ];
          if ( rscriptType.test( node.type || "" ) &&
            !dataPriv.access( node, "globalEval" ) &&
            jQuery.contains( doc, node ) ) {

            if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

              // Optional AJAX dependency, but won't run scripts if not present
              if ( jQuery._evalUrl && !node.noModule ) {
                jQuery._evalUrl( node.src, {
                  nonce: node.nonce || node.getAttribute( "nonce" )
                }, doc );
              }
            } else {
              DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
            }
          }
        }
      }
    }
  }

  return collection;
}

function remove( elem, selector, keepData ) {
  var node,
    nodes = selector ? jQuery.filter( selector, elem ) : elem,
    i = 0;

  for ( ; ( node = nodes[ i ] ) != null; i++ ) {
    if ( !keepData && node.nodeType === 1 ) {
      jQuery.cleanData( getAll( node ) );
    }

    if ( node.parentNode ) {
      if ( keepData && isAttached( node ) ) {
        setGlobalEval( getAll( node, "script" ) );
      }
      node.parentNode.removeChild( node );
    }
  }

  return elem;
}

jQuery.extend( {
  htmlPrefilter: function( html ) {
    return html;
  },

  clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    var i, l, srcElements, destElements,
      clone = elem.cloneNode( true ),
      inPage = isAttached( elem );

    // Fix IE cloning issues
    if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
        !jQuery.isXMLDoc( elem ) ) {

      // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
      destElements = getAll( clone );
      srcElements = getAll( elem );

      for ( i = 0, l = srcElements.length; i < l; i++ ) {
        fixInput( srcElements[ i ], destElements[ i ] );
      }
    }

    // Copy the events from the original to the clone
    if ( dataAndEvents ) {
      if ( deepDataAndEvents ) {
        srcElements = srcElements || getAll( elem );
        destElements = destElements || getAll( clone );

        for ( i = 0, l = srcElements.length; i < l; i++ ) {
          cloneCopyEvent( srcElements[ i ], destElements[ i ] );
        }
      } else {
        cloneCopyEvent( elem, clone );
      }
    }

    // Preserve script evaluation history
    destElements = getAll( clone, "script" );
    if ( destElements.length > 0 ) {
      setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
    }

    // Return the cloned set
    return clone;
  },

  cleanData: function( elems ) {
    var data, elem, type,
      special = jQuery.event.special,
      i = 0;

    for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
      if ( acceptData( elem ) ) {
        if ( ( data = elem[ dataPriv.expando ] ) ) {
          if ( data.events ) {
            for ( type in data.events ) {
              if ( special[ type ] ) {
                jQuery.event.remove( elem, type );

              // This is a shortcut to avoid jQuery.event.remove's overhead
              } else {
                jQuery.removeEvent( elem, type, data.handle );
              }
            }
          }

          // Support: Chrome <=35 - 45+
          // Assign undefined instead of using delete, see Data#remove
          elem[ dataPriv.expando ] = undefined;
        }
        if ( elem[ dataUser.expando ] ) {

          // Support: Chrome <=35 - 45+
          // Assign undefined instead of using delete, see Data#remove
          elem[ dataUser.expando ] = undefined;
        }
      }
    }
  }
} );

jQuery.fn.extend( {
  detach: function( selector ) {
    return remove( this, selector, true );
  },

  remove: function( selector ) {
    return remove( this, selector );
  },

  text: function( value ) {
    return access( this, function( value ) {
      return value === undefined ?
        jQuery.text( this ) :
        this.empty().each( function() {
          if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
            this.textContent = value;
          }
        } );
    }, null, value, arguments.length );
  },

  append: function() {
    return domManip( this, arguments, function( elem ) {
      if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
        var target = manipulationTarget( this, elem );
        target.appendChild( elem );
      }
    } );
  },

  prepend: function() {
    return domManip( this, arguments, function( elem ) {
      if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
        var target = manipulationTarget( this, elem );
        target.insertBefore( elem, target.firstChild );
      }
    } );
  },

  before: function() {
    return domManip( this, arguments, function( elem ) {
      if ( this.parentNode ) {
        this.parentNode.insertBefore( elem, this );
      }
    } );
  },

  after: function() {
    return domManip( this, arguments, function( elem ) {
      if ( this.parentNode ) {
        this.parentNode.insertBefore( elem, this.nextSibling );
      }
    } );
  },

  empty: function() {
    var elem,
      i = 0;

    for ( ; ( elem = this[ i ] ) != null; i++ ) {
      if ( elem.nodeType === 1 ) {

        // Prevent memory leaks
        jQuery.cleanData( getAll( elem, false ) );

        // Remove any remaining nodes
        elem.textContent = "";
      }
    }

    return this;
  },

  clone: function( dataAndEvents, deepDataAndEvents ) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

    return this.map( function() {
      return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    } );
  },

  html: function( value ) {
    return access( this, function( value ) {
      var elem = this[ 0 ] || {},
        i = 0,
        l = this.length;

      if ( value === undefined && elem.nodeType === 1 ) {
        return elem.innerHTML;
      }

      // See if we can take a shortcut and just use innerHTML
      if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
        !wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

        value = jQuery.htmlPrefilter( value );

        try {
          for ( ; i < l; i++ ) {
            elem = this[ i ] || {};

            // Remove element nodes and prevent memory leaks
            if ( elem.nodeType === 1 ) {
              jQuery.cleanData( getAll( elem, false ) );
              elem.innerHTML = value;
            }
          }

          elem = 0;

        // If using innerHTML throws an exception, use the fallback method
        } catch ( e ) {}
      }

      if ( elem ) {
        this.empty().append( value );
      }
    }, null, value, arguments.length );
  },

  replaceWith: function() {
    var ignored = [];

    // Make the changes, replacing each non-ignored context element with the new content
    return domManip( this, arguments, function( elem ) {
      var parent = this.parentNode;

      if ( jQuery.inArray( this, ignored ) < 0 ) {
        jQuery.cleanData( getAll( this ) );
        if ( parent ) {
          parent.replaceChild( elem, this );
        }
      }

    // Force callback invocation
    }, ignored );
  }
} );

jQuery.each( {
  appendTo: "append",
  prependTo: "prepend",
  insertBefore: "before",
  insertAfter: "after",
  replaceAll: "replaceWith"
}, function( name, original ) {
  jQuery.fn[ name ] = function( selector ) {
    var elems,
      ret = [],
      insert = jQuery( selector ),
      last = insert.length - 1,
      i = 0;

    for ( ; i <= last; i++ ) {
      elems = i === last ? this : this.clone( true );
      jQuery( insert[ i ] )[ original ]( elems );

      // Support: Android <=4.0 only, PhantomJS 1 only
      // .get() because push.apply(_, arraylike) throws on ancient WebKit
      push.apply( ret, elems.get() );
    }

    return this.pushStack( ret );
  };
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if ( !view || !view.opener ) {
      view = window;
    }

    return view.getComputedStyle( elem );
  };

var swap = function( elem, options, callback ) {
  var ret, name,
    old = {};

  // Remember the old values, and insert the new ones
  for ( name in options ) {
    old[ name ] = elem.style[ name ];
    elem.style[ name ] = options[ name ];
  }

  ret = callback.call( elem );

  // Revert the old values
  for ( name in options ) {
    elem.style[ name ] = old[ name ];
  }

  return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

  // Executing both pixelPosition & boxSizingReliable tests require only one layout
  // so they're executed at the same time to save the second computation.
  function computeStyleTests() {

    // This is a singleton, we need to execute it only once
    if ( !div ) {
      return;
    }

    container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
      "margin-top:1px;padding:0;border:0";
    div.style.cssText =
      "position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
      "margin:auto;border:1px;padding:1px;" +
      "width:60%;top:1%";
    documentElement.appendChild( container ).appendChild( div );

    var divStyle = window.getComputedStyle( div );
    pixelPositionVal = divStyle.top !== "1%";

    // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
    reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

    // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
    // Some styles come back with percentage values, even though they shouldn't
    div.style.right = "60%";
    pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

    // Support: IE 9 - 11 only
    // Detect misreporting of content dimensions for box-sizing:border-box elements
    boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

    // Support: IE 9 only
    // Detect overflow:scroll screwiness (gh-3699)
    // Support: Chrome <=64
    // Don't get tricked when zoom affects offsetWidth (gh-4029)
    div.style.position = "absolute";
    scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

    documentElement.removeChild( container );

    // Nullify the div so it wouldn't be stored in the memory and
    // it will also be a sign that checks already performed
    div = null;
  }

  function roundPixelMeasures( measure ) {
    return Math.round( parseFloat( measure ) );
  }

  var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
    reliableTrDimensionsVal, reliableMarginLeftVal,
    container = document.createElement( "div" ),
    div = document.createElement( "div" );

  // Finish early in limited (non-browser) environments
  if ( !div.style ) {
    return;
  }

  // Support: IE <=9 - 11 only
  // Style of cloned element affects source element cloned (#8908)
  div.style.backgroundClip = "content-box";
  div.cloneNode( true ).style.backgroundClip = "";
  support.clearCloneStyle = div.style.backgroundClip === "content-box";

  jQuery.extend( support, {
    boxSizingReliable: function() {
      computeStyleTests();
      return boxSizingReliableVal;
    },
    pixelBoxStyles: function() {
      computeStyleTests();
      return pixelBoxStylesVal;
    },
    pixelPosition: function() {
      computeStyleTests();
      return pixelPositionVal;
    },
    reliableMarginLeft: function() {
      computeStyleTests();
      return reliableMarginLeftVal;
    },
    scrollboxSize: function() {
      computeStyleTests();
      return scrollboxSizeVal;
    },

    // Support: IE 9 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Behavior in IE 9 is more subtle than in newer versions & it passes
    // some versions of this test; make sure not to make it pass there!
    reliableTrDimensions: function() {
      var table, tr, trChild, trStyle;
      if ( reliableTrDimensionsVal == null ) {
        table = document.createElement( "table" );
        tr = document.createElement( "tr" );
        trChild = document.createElement( "div" );

        table.style.cssText = "position:absolute;left:-11111px";
        tr.style.height = "1px";
        trChild.style.height = "9px";

        documentElement
          .appendChild( table )
          .appendChild( tr )
          .appendChild( trChild );

        trStyle = window.getComputedStyle( tr );
        reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

        documentElement.removeChild( table );
      }
      return reliableTrDimensionsVal;
    }
  } );
} )();


function curCSS( elem, name, computed ) {
  var width, minWidth, maxWidth, ret,

    // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;

  computed = computed || getStyles( elem );

  // getPropertyValue is needed for:
  //   .css('filter') (IE 9 only, #12537)
  //   .css('--customProperty) (#3144)
  if ( computed ) {
    ret = computed.getPropertyValue( name ) || computed[ name ];

    if ( ret === "" && !isAttached( elem ) ) {
      ret = jQuery.style( elem, name );
    }

    // A tribute to the "awesome hack by Dean Edwards"
    // Android Browser returns percentage for some values,
    // but width seems to be reliably pixels.
    // This is against the CSSOM draft spec:
    // https://drafts.csswg.org/cssom/#resolved-values
    if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

      // Remember the original values
      width = style.width;
      minWidth = style.minWidth;
      maxWidth = style.maxWidth;

      // Put in the new values to get a computed value out
      style.minWidth = style.maxWidth = style.width = ret;
      ret = computed.width;

      // Revert the changed values
      style.width = width;
      style.minWidth = minWidth;
      style.maxWidth = maxWidth;
    }
  }

  return ret !== undefined ?

    // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" :
    ret;
}


function addGetHookIf( conditionFn, hookFn ) {

  // Define the hook, we'll check on the first run if it's really needed.
  return {
    get: function() {
      if ( conditionFn() ) {

        // Hook not needed (or it's not possible to use it due
        // to missing dependency), remove it.
        delete this.get;
        return;
      }

      // Hook needed; redefine it so that the support test is not executed again.
      return ( this.get = hookFn ).apply( this, arguments );
    }
  };
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
  emptyStyle = document.createElement( "div" ).style,
  vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

  // Check for vendor prefixed names
  var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
    i = cssPrefixes.length;

  while ( i-- ) {
    name = cssPrefixes[ i ] + capName;
    if ( name in emptyStyle ) {
      return name;
    }
  }
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
  var final = jQuery.cssProps[ name ] || vendorProps[ name ];

  if ( final ) {
    return final;
  }
  if ( name in emptyStyle ) {
    return name;
  }
  return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

  // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
  rcustomProp = /^--/,
  cssShow = { position: "absolute", visibility: "hidden", display: "block" },
  cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  };

function setPositiveNumber( _elem, value, subtract ) {

  // Any relative (+/-) values have already been
  // normalized at this point
  var matches = rcssNum.exec( value );
  return matches ?

    // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
    value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
  var i = dimension === "width" ? 1 : 0,
    extra = 0,
    delta = 0;

  // Adjustment may not be necessary
  if ( box === ( isBorderBox ? "border" : "content" ) ) {
    return 0;
  }

  for ( ; i < 4; i += 2 ) {

    // Both box models exclude margin
    if ( box === "margin" ) {
      delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
    }

    // If we get here with a content-box, we're seeking "padding" or "border" or "margin"
    if ( !isBorderBox ) {

      // Add padding
      delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

      // For "border" or "margin", add border
      if ( box !== "padding" ) {
        delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

      // But still keep track of it otherwise
      } else {
        extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
      }

    // If we get here with a border-box (content + padding + border), we're seeking "content" or
    // "padding" or "margin"
    } else {

      // For "content", subtract padding
      if ( box === "content" ) {
        delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
      }

      // For "content" or "padding", subtract border
      if ( box !== "margin" ) {
        delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
      }
    }
  }

  // Account for positive content-box scroll gutter when requested by providing computedVal
  if ( !isBorderBox && computedVal >= 0 ) {

    // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
    // Assuming integer scroll gutter, subtract the rest and round down
    delta += Math.max( 0, Math.ceil(
      elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
      computedVal -
      delta -
      extra -
      0.5

    // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
    // Use an explicit zero to avoid NaN (gh-3964)
    ) ) || 0;
  }

  return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

  // Start with computed style
  var styles = getStyles( elem ),

    // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
    // Fake content-box until we know it's needed to know the true value.
    boxSizingNeeded = !support.boxSizingReliable() || extra,
    isBorderBox = boxSizingNeeded &&
      jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
    valueIsBorderBox = isBorderBox,

    val = curCSS( elem, dimension, styles ),
    offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

  // Support: Firefox <=54
  // Return a confounding non-pixel value or feign ignorance, as appropriate.
  if ( rnumnonpx.test( val ) ) {
    if ( !extra ) {
      return val;
    }
    val = "auto";
  }


  // Support: IE 9 - 11 only
  // Use offsetWidth/offsetHeight for when box sizing is unreliable.
  // In those cases, the computed value can be trusted to be border-box.
  if ( ( !support.boxSizingReliable() && isBorderBox ||

    // Support: IE 10 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
    !support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

    // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    val === "auto" ||

    // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    !parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

    // Make sure the element is visible & connected
    elem.getClientRects().length ) {

    isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

    // Where available, offsetWidth/offsetHeight approximate border box dimensions.
    // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
    // retrieved value as a content box dimension.
    valueIsBorderBox = offsetProp in elem;
    if ( valueIsBorderBox ) {
      val = elem[ offsetProp ];
    }
  }

  // Normalize "" and auto
  val = parseFloat( val ) || 0;

  // Adjust for the element's box model
  return ( val +
    boxModelAdjustment(
      elem,
      dimension,
      extra || ( isBorderBox ? "border" : "content" ),
      valueIsBorderBox,
      styles,

      // Provide the current computed size to request scroll gutter calculation (gh-3589)
      val
    )
  ) + "px";
}

jQuery.extend( {

  // Add in style property hooks for overriding the default
  // behavior of getting and setting a style property
  cssHooks: {
    opacity: {
      get: function( elem, computed ) {
        if ( computed ) {

          // We should always get a number back from opacity
          var ret = curCSS( elem, "opacity" );
          return ret === "" ? "1" : ret;
        }
      }
    }
  },

  // Don't automatically add "px" to these possibly-unitless properties
  cssNumber: {
    "animationIterationCount": true,
    "columnCount": true,
    "fillOpacity": true,
    "flexGrow": true,
    "flexShrink": true,
    "fontWeight": true,
    "gridArea": true,
    "gridColumn": true,
    "gridColumnEnd": true,
    "gridColumnStart": true,
    "gridRow": true,
    "gridRowEnd": true,
    "gridRowStart": true,
    "lineHeight": true,
    "opacity": true,
    "order": true,
    "orphans": true,
    "widows": true,
    "zIndex": true,
    "zoom": true
  },

  // Add in properties whose names you wish to fix before
  // setting or getting the value
  cssProps: {},

  // Get and set the style property on a DOM Node
  style: function( elem, name, value, extra ) {

    // Don't set styles on text and comment nodes
    if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
      return;
    }

    // Make sure that we're working with the right name
    var ret, type, hooks,
      origName = camelCase( name ),
      isCustomProp = rcustomProp.test( name ),
      style = elem.style;

    // Make sure that we're working with the right name. We don't
    // want to query the value if it is a CSS custom property
    // since they are user-defined.
    if ( !isCustomProp ) {
      name = finalPropName( origName );
    }

    // Gets hook for the prefixed version, then unprefixed version
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // Check if we're setting a value
    if ( value !== undefined ) {
      type = typeof value;

      // Convert "+=" or "-=" to relative numbers (#7345)
      if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
        value = adjustCSS( elem, name, ret );

        // Fixes bug #9237
        type = "number";
      }

      // Make sure that null and NaN values aren't set (#7116)
      if ( value == null || value !== value ) {
        return;
      }

      // If a number was passed in, add the unit (except for certain CSS properties)
      // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
      // "px" to a few hardcoded values.
      if ( type === "number" && !isCustomProp ) {
        value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
      }

      // background-* props affect original clone's values
      if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
        style[ name ] = "inherit";
      }

      // If a hook was provided, use that value, otherwise just set the specified value
      if ( !hooks || !( "set" in hooks ) ||
        ( value = hooks.set( elem, value, extra ) ) !== undefined ) {

        if ( isCustomProp ) {
          style.setProperty( name, value );
        } else {
          style[ name ] = value;
        }
      }

    } else {

      // If a hook was provided get the non-computed value from there
      if ( hooks && "get" in hooks &&
        ( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

        return ret;
      }

      // Otherwise just get the value from the style object
      return style[ name ];
    }
  },

  css: function( elem, name, extra, styles ) {
    var val, num, hooks,
      origName = camelCase( name ),
      isCustomProp = rcustomProp.test( name );

    // Make sure that we're working with the right name. We don't
    // want to modify the value if it is a CSS custom property
    // since they are user-defined.
    if ( !isCustomProp ) {
      name = finalPropName( origName );
    }

    // Try prefixed name followed by the unprefixed name
    hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

    // If a hook was provided get the computed value from there
    if ( hooks && "get" in hooks ) {
      val = hooks.get( elem, true, extra );
    }

    // Otherwise, if a way to get the computed value exists, use that
    if ( val === undefined ) {
      val = curCSS( elem, name, styles );
    }

    // Convert "normal" to computed value
    if ( val === "normal" && name in cssNormalTransform ) {
      val = cssNormalTransform[ name ];
    }

    // Make numeric if forced or a qualifier was provided and val looks numeric
    if ( extra === "" || extra ) {
      num = parseFloat( val );
      return extra === true || isFinite( num ) ? num || 0 : val;
    }

    return val;
  }
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
  jQuery.cssHooks[ dimension ] = {
    get: function( elem, computed, extra ) {
      if ( computed ) {

        // Certain elements can have dimension info if we invisibly show them
        // but it must have a current display style that would benefit
        return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

          // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          ( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
            swap( elem, cssShow, function() {
              return getWidthOrHeight( elem, dimension, extra );
            } ) :
            getWidthOrHeight( elem, dimension, extra );
      }
    },

    set: function( elem, value, extra ) {
      var matches,
        styles = getStyles( elem ),

        // Only read styles.position if the test has a chance to fail
        // to avoid forcing a reflow.
        scrollboxSizeBuggy = !support.scrollboxSize() &&
          styles.position === "absolute",

        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
        boxSizingNeeded = scrollboxSizeBuggy || extra,
        isBorderBox = boxSizingNeeded &&
          jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
        subtract = extra ?
          boxModelAdjustment(
            elem,
            dimension,
            extra,
            isBorderBox,
            styles
          ) :
          0;

      // Account for unreliable border-box dimensions by comparing offset* to computed and
      // faking a content-box to get border and padding (gh-3699)
      if ( isBorderBox && scrollboxSizeBuggy ) {
        subtract -= Math.ceil(
          elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
          parseFloat( styles[ dimension ] ) -
          boxModelAdjustment( elem, dimension, "border", false, styles ) -
          0.5
        );
      }

      // Convert to pixels if value adjustment is needed
      if ( subtract && ( matches = rcssNum.exec( value ) ) &&
        ( matches[ 3 ] || "px" ) !== "px" ) {

        elem.style[ dimension ] = value;
        value = jQuery.css( elem, dimension );
      }

      return setPositiveNumber( elem, value, subtract );
    }
  };
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
  function( elem, computed ) {
    if ( computed ) {
      return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
        elem.getBoundingClientRect().left -
          swap( elem, { marginLeft: 0 }, function() {
            return elem.getBoundingClientRect().left;
          } )
        ) + "px";
    }
  }
);

// These hooks are used by animate to expand properties
jQuery.each( {
  margin: "",
  padding: "",
  border: "Width"
}, function( prefix, suffix ) {
  jQuery.cssHooks[ prefix + suffix ] = {
    expand: function( value ) {
      var i = 0,
        expanded = {},

        // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split( " " ) : [ value ];

      for ( ; i < 4; i++ ) {
        expanded[ prefix + cssExpand[ i ] + suffix ] =
          parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
      }

      return expanded;
    }
  };

  if ( prefix !== "margin" ) {
    jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
  }
} );

jQuery.fn.extend( {
  css: function( name, value ) {
    return access( this, function( elem, name, value ) {
      var styles, len,
        map = {},
        i = 0;

      if ( Array.isArray( name ) ) {
        styles = getStyles( elem );
        len = name.length;

        for ( ; i < len; i++ ) {
          map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
        }

        return map;
      }

      return value !== undefined ?
        jQuery.style( elem, name, value ) :
        jQuery.css( elem, name );
    }, name, value, arguments.length > 1 );
  }
} );


function Tween( elem, options, prop, end, easing ) {
  return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
  constructor: Tween,
  init: function( elem, options, prop, end, easing, unit ) {
    this.elem = elem;
    this.prop = prop;
    this.easing = easing || jQuery.easing._default;
    this.options = options;
    this.start = this.now = this.cur();
    this.end = end;
    this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
  },
  cur: function() {
    var hooks = Tween.propHooks[ this.prop ];

    return hooks && hooks.get ?
      hooks.get( this ) :
      Tween.propHooks._default.get( this );
  },
  run: function( percent ) {
    var eased,
      hooks = Tween.propHooks[ this.prop ];

    if ( this.options.duration ) {
      this.pos = eased = jQuery.easing[ this.easing ](
        percent, this.options.duration * percent, 0, 1, this.options.duration
      );
    } else {
      this.pos = eased = percent;
    }
    this.now = ( this.end - this.start ) * eased + this.start;

    if ( this.options.step ) {
      this.options.step.call( this.elem, this.now, this );
    }

    if ( hooks && hooks.set ) {
      hooks.set( this );
    } else {
      Tween.propHooks._default.set( this );
    }
    return this;
  }
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
  _default: {
    get: function( tween ) {
      var result;

      // Use a property on the element directly when it is not a DOM element,
      // or when there is no matching style property that exists.
      if ( tween.elem.nodeType !== 1 ||
        tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
        return tween.elem[ tween.prop ];
      }

      // Passing an empty string as a 3rd parameter to .css will automatically
      // attempt a parseFloat and fallback to a string if the parse fails.
      // Simple values such as "10px" are parsed to Float;
      // complex values such as "rotate(1rad)" are returned as-is.
      result = jQuery.css( tween.elem, tween.prop, "" );

      // Empty strings, null, undefined and "auto" are converted to 0.
      return !result || result === "auto" ? 0 : result;
    },
    set: function( tween ) {

      // Use step hook for back compat.
      // Use cssHook if its there.
      // Use .style if available and use plain properties where available.
      if ( jQuery.fx.step[ tween.prop ] ) {
        jQuery.fx.step[ tween.prop ]( tween );
      } else if ( tween.elem.nodeType === 1 && (
          jQuery.cssHooks[ tween.prop ] ||
          tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
        jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
      } else {
        tween.elem[ tween.prop ] = tween.now;
      }
    }
  }
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
  set: function( tween ) {
    if ( tween.elem.nodeType && tween.elem.parentNode ) {
      tween.elem[ tween.prop ] = tween.now;
    }
  }
};

jQuery.easing = {
  linear: function( p ) {
    return p;
  },
  swing: function( p ) {
    return 0.5 - Math.cos( p * Math.PI ) / 2;
  },
  _default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
  fxNow, inProgress,
  rfxtypes = /^(?:toggle|show|hide)$/,
  rrun = /queueHooks$/;

function schedule() {
  if ( inProgress ) {
    if ( document.hidden === false && window.requestAnimationFrame ) {
      window.requestAnimationFrame( schedule );
    } else {
      window.setTimeout( schedule, jQuery.fx.interval );
    }

    jQuery.fx.tick();
  }
}

// Animations created synchronously will run synchronously
function createFxNow() {
  window.setTimeout( function() {
    fxNow = undefined;
  } );
  return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
  var which,
    i = 0,
    attrs = { height: type };

  // If we include width, step value is 1 to do all cssExpand values,
  // otherwise step value is 2 to skip over Left and Right
  includeWidth = includeWidth ? 1 : 0;
  for ( ; i < 4; i += 2 - includeWidth ) {
    which = cssExpand[ i ];
    attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
  }

  if ( includeWidth ) {
    attrs.opacity = attrs.width = type;
  }

  return attrs;
}

function createTween( value, prop, animation ) {
  var tween,
    collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
    index = 0,
    length = collection.length;
  for ( ; index < length; index++ ) {
    if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

      // We're done with this property
      return tween;
    }
  }
}

function defaultPrefilter( elem, props, opts ) {
  var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
    isBox = "width" in props || "height" in props,
    anim = this,
    orig = {},
    style = elem.style,
    hidden = elem.nodeType && isHiddenWithinTree( elem ),
    dataShow = dataPriv.get( elem, "fxshow" );

  // Queue-skipping animations hijack the fx hooks
  if ( !opts.queue ) {
    hooks = jQuery._queueHooks( elem, "fx" );
    if ( hooks.unqueued == null ) {
      hooks.unqueued = 0;
      oldfire = hooks.empty.fire;
      hooks.empty.fire = function() {
        if ( !hooks.unqueued ) {
          oldfire();
        }
      };
    }
    hooks.unqueued++;

    anim.always( function() {

      // Ensure the complete handler is called before this completes
      anim.always( function() {
        hooks.unqueued--;
        if ( !jQuery.queue( elem, "fx" ).length ) {
          hooks.empty.fire();
        }
      } );
    } );
  }

  // Detect show/hide animations
  for ( prop in props ) {
    value = props[ prop ];
    if ( rfxtypes.test( value ) ) {
      delete props[ prop ];
      toggle = toggle || value === "toggle";
      if ( value === ( hidden ? "hide" : "show" ) ) {

        // Pretend to be hidden if this is a "show" and
        // there is still data from a stopped show/hide
        if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
          hidden = true;

        // Ignore all other no-op show/hide data
        } else {
          continue;
        }
      }
      orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
    }
  }

  // Bail out if this is a no-op like .hide().hide()
  propTween = !jQuery.isEmptyObject( props );
  if ( !propTween && jQuery.isEmptyObject( orig ) ) {
    return;
  }

  // Restrict "overflow" and "display" styles during box animations
  if ( isBox && elem.nodeType === 1 ) {

    // Support: IE <=9 - 11, Edge 12 - 15
    // Record all 3 overflow attributes because IE does not infer the shorthand
    // from identically-valued overflowX and overflowY and Edge just mirrors
    // the overflowX value there.
    opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

    // Identify a display type, preferring old show/hide data over the CSS cascade
    restoreDisplay = dataShow && dataShow.display;
    if ( restoreDisplay == null ) {
      restoreDisplay = dataPriv.get( elem, "display" );
    }
    display = jQuery.css( elem, "display" );
    if ( display === "none" ) {
      if ( restoreDisplay ) {
        display = restoreDisplay;
      } else {

        // Get nonempty value(s) by temporarily forcing visibility
        showHide( [ elem ], true );
        restoreDisplay = elem.style.display || restoreDisplay;
        display = jQuery.css( elem, "display" );
        showHide( [ elem ] );
      }
    }

    // Animate inline elements as inline-block
    if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
      if ( jQuery.css( elem, "float" ) === "none" ) {

        // Restore the original display value at the end of pure show/hide animations
        if ( !propTween ) {
          anim.done( function() {
            style.display = restoreDisplay;
          } );
          if ( restoreDisplay == null ) {
            display = style.display;
            restoreDisplay = display === "none" ? "" : display;
          }
        }
        style.display = "inline-block";
      }
    }
  }

  if ( opts.overflow ) {
    style.overflow = "hidden";
    anim.always( function() {
      style.overflow = opts.overflow[ 0 ];
      style.overflowX = opts.overflow[ 1 ];
      style.overflowY = opts.overflow[ 2 ];
    } );
  }

  // Implement show/hide animations
  propTween = false;
  for ( prop in orig ) {

    // General show/hide setup for this element animation
    if ( !propTween ) {
      if ( dataShow ) {
        if ( "hidden" in dataShow ) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
      }

      // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
      if ( toggle ) {
        dataShow.hidden = !hidden;
      }

      // Show elements before animating them
      if ( hidden ) {
        showHide( [ elem ], true );
      }

      /* eslint-disable no-loop-func */

      anim.done( function() {

      /* eslint-enable no-loop-func */

        // The final step of a "hide" animation is actually hiding the element
        if ( !hidden ) {
          showHide( [ elem ] );
        }
        dataPriv.remove( elem, "fxshow" );
        for ( prop in orig ) {
          jQuery.style( elem, prop, orig[ prop ] );
        }
      } );
    }

    // Per-property setup
    propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
    if ( !( prop in dataShow ) ) {
      dataShow[ prop ] = propTween.start;
      if ( hidden ) {
        propTween.end = propTween.start;
        propTween.start = 0;
      }
    }
  }
}

function propFilter( props, specialEasing ) {
  var index, name, easing, value, hooks;

  // camelCase, specialEasing and expand cssHook pass
  for ( index in props ) {
    name = camelCase( index );
    easing = specialEasing[ name ];
    value = props[ index ];
    if ( Array.isArray( value ) ) {
      easing = value[ 1 ];
      value = props[ index ] = value[ 0 ];
    }

    if ( index !== name ) {
      props[ name ] = value;
      delete props[ index ];
    }

    hooks = jQuery.cssHooks[ name ];
    if ( hooks && "expand" in hooks ) {
      value = hooks.expand( value );
      delete props[ name ];

      // Not quite $.extend, this won't overwrite existing keys.
      // Reusing 'index' because we have the correct "name"
      for ( index in value ) {
        if ( !( index in props ) ) {
          props[ index ] = value[ index ];
          specialEasing[ index ] = easing;
        }
      }
    } else {
      specialEasing[ name ] = easing;
    }
  }
}

function Animation( elem, properties, options ) {
  var result,
    stopped,
    index = 0,
    length = Animation.prefilters.length,
    deferred = jQuery.Deferred().always( function() {

      // Don't match elem in the :animated selector
      delete tick.elem;
    } ),
    tick = function() {
      if ( stopped ) {
        return false;
      }
      var currentTime = fxNow || createFxNow(),
        remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

        // Support: Android 2.3 only
        // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
        temp = remaining / animation.duration || 0,
        percent = 1 - temp,
        index = 0,
        length = animation.tweens.length;

      for ( ; index < length; index++ ) {
        animation.tweens[ index ].run( percent );
      }

      deferred.notifyWith( elem, [ animation, percent, remaining ] );

      // If there's more to do, yield
      if ( percent < 1 && length ) {
        return remaining;
      }

      // If this was an empty animation, synthesize a final progress notification
      if ( !length ) {
        deferred.notifyWith( elem, [ animation, 1, 0 ] );
      }

      // Resolve the animation and report its conclusion
      deferred.resolveWith( elem, [ animation ] );
      return false;
    },
    animation = deferred.promise( {
      elem: elem,
      props: jQuery.extend( {}, properties ),
      opts: jQuery.extend( true, {
        specialEasing: {},
        easing: jQuery.easing._default
      }, options ),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function( prop, end ) {
        var tween = jQuery.Tween( elem, animation.opts, prop, end,
            animation.opts.specialEasing[ prop ] || animation.opts.easing );
        animation.tweens.push( tween );
        return tween;
      },
      stop: function( gotoEnd ) {
        var index = 0,

          // If we are going to the end, we want to run all the tweens
          // otherwise we skip this part
          length = gotoEnd ? animation.tweens.length : 0;
        if ( stopped ) {
          return this;
        }
        stopped = true;
        for ( ; index < length; index++ ) {
          animation.tweens[ index ].run( 1 );
        }

        // Resolve when we played the last frame; otherwise, reject
        if ( gotoEnd ) {
          deferred.notifyWith( elem, [ animation, 1, 0 ] );
          deferred.resolveWith( elem, [ animation, gotoEnd ] );
        } else {
          deferred.rejectWith( elem, [ animation, gotoEnd ] );
        }
        return this;
      }
    } ),
    props = animation.props;

  propFilter( props, animation.opts.specialEasing );

  for ( ; index < length; index++ ) {
    result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
    if ( result ) {
      if ( isFunction( result.stop ) ) {
        jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
          result.stop.bind( result );
      }
      return result;
    }
  }

  jQuery.map( props, createTween, animation );

  if ( isFunction( animation.opts.start ) ) {
    animation.opts.start.call( elem, animation );
  }

  // Attach callbacks from options
  animation
    .progress( animation.opts.progress )
    .done( animation.opts.done, animation.opts.complete )
    .fail( animation.opts.fail )
    .always( animation.opts.always );

  jQuery.fx.timer(
    jQuery.extend( tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    } )
  );

  return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

  tweeners: {
    "*": [ function( prop, value ) {
      var tween = this.createTween( prop, value );
      adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
      return tween;
    } ]
  },

  tweener: function( props, callback ) {
    if ( isFunction( props ) ) {
      callback = props;
      props = [ "*" ];
    } else {
      props = props.match( rnothtmlwhite );
    }

    var prop,
      index = 0,
      length = props.length;

    for ( ; index < length; index++ ) {
      prop = props[ index ];
      Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
      Animation.tweeners[ prop ].unshift( callback );
    }
  },

  prefilters: [ defaultPrefilter ],

  prefilter: function( callback, prepend ) {
    if ( prepend ) {
      Animation.prefilters.unshift( callback );
    } else {
      Animation.prefilters.push( callback );
    }
  }
} );

jQuery.speed = function( speed, easing, fn ) {
  var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
    complete: fn || !fn && easing ||
      isFunction( speed ) && speed,
    duration: speed,
    easing: fn && easing || easing && !isFunction( easing ) && easing
  };

  // Go to the end state if fx are off
  if ( jQuery.fx.off ) {
    opt.duration = 0;

  } else {
    if ( typeof opt.duration !== "number" ) {
      if ( opt.duration in jQuery.fx.speeds ) {
        opt.duration = jQuery.fx.speeds[ opt.duration ];

      } else {
        opt.duration = jQuery.fx.speeds._default;
      }
    }
  }

  // Normalize opt.queue - true/undefined/null -> "fx"
  if ( opt.queue == null || opt.queue === true ) {
    opt.queue = "fx";
  }

  // Queueing
  opt.old = opt.complete;

  opt.complete = function() {
    if ( isFunction( opt.old ) ) {
      opt.old.call( this );
    }

    if ( opt.queue ) {
      jQuery.dequeue( this, opt.queue );
    }
  };

  return opt;
};

jQuery.fn.extend( {
  fadeTo: function( speed, to, easing, callback ) {

    // Show any hidden elements after setting opacity to 0
    return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

      // Animate to the value specified
      .end().animate( { opacity: to }, speed, easing, callback );
  },
  animate: function( prop, speed, easing, callback ) {
    var empty = jQuery.isEmptyObject( prop ),
      optall = jQuery.speed( speed, easing, callback ),
      doAnimation = function() {

        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation( this, jQuery.extend( {}, prop ), optall );

        // Empty animations, or finishing resolves immediately
        if ( empty || dataPriv.get( this, "finish" ) ) {
          anim.stop( true );
        }
      };
      doAnimation.finish = doAnimation;

    return empty || optall.queue === false ?
      this.each( doAnimation ) :
      this.queue( optall.queue, doAnimation );
  },
  stop: function( type, clearQueue, gotoEnd ) {
    var stopQueue = function( hooks ) {
      var stop = hooks.stop;
      delete hooks.stop;
      stop( gotoEnd );
    };

    if ( typeof type !== "string" ) {
      gotoEnd = clearQueue;
      clearQueue = type;
      type = undefined;
    }
    if ( clearQueue ) {
      this.queue( type || "fx", [] );
    }

    return this.each( function() {
      var dequeue = true,
        index = type != null && type + "queueHooks",
        timers = jQuery.timers,
        data = dataPriv.get( this );

      if ( index ) {
        if ( data[ index ] && data[ index ].stop ) {
          stopQueue( data[ index ] );
        }
      } else {
        for ( index in data ) {
          if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
            stopQueue( data[ index ] );
          }
        }
      }

      for ( index = timers.length; index--; ) {
        if ( timers[ index ].elem === this &&
          ( type == null || timers[ index ].queue === type ) ) {

          timers[ index ].anim.stop( gotoEnd );
          dequeue = false;
          timers.splice( index, 1 );
        }
      }

      // Start the next in the queue if the last step wasn't forced.
      // Timers currently will call their complete callbacks, which
      // will dequeue but only if they were gotoEnd.
      if ( dequeue || !gotoEnd ) {
        jQuery.dequeue( this, type );
      }
    } );
  },
  finish: function( type ) {
    if ( type !== false ) {
      type = type || "fx";
    }
    return this.each( function() {
      var index,
        data = dataPriv.get( this ),
        queue = data[ type + "queue" ],
        hooks = data[ type + "queueHooks" ],
        timers = jQuery.timers,
        length = queue ? queue.length : 0;

      // Enable finishing flag on private data
      data.finish = true;

      // Empty the queue first
      jQuery.queue( this, type, [] );

      if ( hooks && hooks.stop ) {
        hooks.stop.call( this, true );
      }

      // Look for any active animations, and finish them
      for ( index = timers.length; index--; ) {
        if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
          timers[ index ].anim.stop( true );
          timers.splice( index, 1 );
        }
      }

      // Look for any animations in the old queue and finish them
      for ( index = 0; index < length; index++ ) {
        if ( queue[ index ] && queue[ index ].finish ) {
          queue[ index ].finish.call( this );
        }
      }

      // Turn off finishing flag
      delete data.finish;
    } );
  }
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
  var cssFn = jQuery.fn[ name ];
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return speed == null || typeof speed === "boolean" ?
      cssFn.apply( this, arguments ) :
      this.animate( genFx( name, true ), speed, easing, callback );
  };
} );

// Generate shortcuts for custom animations
jQuery.each( {
  slideDown: genFx( "show" ),
  slideUp: genFx( "hide" ),
  slideToggle: genFx( "toggle" ),
  fadeIn: { opacity: "show" },
  fadeOut: { opacity: "hide" },
  fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
  jQuery.fn[ name ] = function( speed, easing, callback ) {
    return this.animate( props, speed, easing, callback );
  };
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
  var timer,
    i = 0,
    timers = jQuery.timers;

  fxNow = Date.now();

  for ( ; i < timers.length; i++ ) {
    timer = timers[ i ];

    // Run the timer and safely remove it when done (allowing for external removal)
    if ( !timer() && timers[ i ] === timer ) {
      timers.splice( i--, 1 );
    }
  }

  if ( !timers.length ) {
    jQuery.fx.stop();
  }
  fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
  jQuery.timers.push( timer );
  jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
  if ( inProgress ) {
    return;
  }

  inProgress = true;
  schedule();
};

jQuery.fx.stop = function() {
  inProgress = null;
};

jQuery.fx.speeds = {
  slow: 600,
  fast: 200,

  // Default speed
  _default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
  time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
  type = type || "fx";

  return this.queue( type, function( next, hooks ) {
    var timeout = window.setTimeout( next, time );
    hooks.stop = function() {
      window.clearTimeout( timeout );
    };
  } );
};


( function() {
  var input = document.createElement( "input" ),
    select = document.createElement( "select" ),
    opt = select.appendChild( document.createElement( "option" ) );

  input.type = "checkbox";

  // Support: Android <=4.3 only
  // Default value for a checkbox should be "on"
  support.checkOn = input.value !== "";

  // Support: IE <=11 only
  // Must access selectedIndex to make default options select
  support.optSelected = opt.selected;

  // Support: IE <=11 only
  // An input loses its value after becoming a radio
  input = document.createElement( "input" );
  input.value = "t";
  input.type = "radio";
  support.radioValue = input.value === "t";
} )();


var boolHook,
  attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
  attr: function( name, value ) {
    return access( this, jQuery.attr, name, value, arguments.length > 1 );
  },

  removeAttr: function( name ) {
    return this.each( function() {
      jQuery.removeAttr( this, name );
    } );
  }
} );

jQuery.extend( {
  attr: function( elem, name, value ) {
    var ret, hooks,
      nType = elem.nodeType;

    // Don't get/set attributes on text, comment and attribute nodes
    if ( nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    // Fallback to prop when attributes are not supported
    if ( typeof elem.getAttribute === "undefined" ) {
      return jQuery.prop( elem, name, value );
    }

    // Attribute hooks are determined by the lowercase version
    // Grab necessary hook if one is defined
    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
      hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
        ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
    }

    if ( value !== undefined ) {
      if ( value === null ) {
        jQuery.removeAttr( elem, name );
        return;
      }

      if ( hooks && "set" in hooks &&
        ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
        return ret;
      }

      elem.setAttribute( name, value + "" );
      return value;
    }

    if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
      return ret;
    }

    ret = jQuery.find.attr( elem, name );

    // Non-existent attributes return null, we normalize to undefined
    return ret == null ? undefined : ret;
  },

  attrHooks: {
    type: {
      set: function( elem, value ) {
        if ( !support.radioValue && value === "radio" &&
          nodeName( elem, "input" ) ) {
          var val = elem.value;
          elem.setAttribute( "type", value );
          if ( val ) {
            elem.value = val;
          }
          return value;
        }
      }
    }
  },

  removeAttr: function( elem, value ) {
    var name,
      i = 0,

      // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match( rnothtmlwhite );

    if ( attrNames && elem.nodeType === 1 ) {
      while ( ( name = attrNames[ i++ ] ) ) {
        elem.removeAttribute( name );
      }
    }
  }
} );

// Hooks for boolean attributes
boolHook = {
  set: function( elem, value, name ) {
    if ( value === false ) {

      // Remove boolean attributes when set to false
      jQuery.removeAttr( elem, name );
    } else {
      elem.setAttribute( name, name );
    }
    return name;
  }
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
  var getter = attrHandle[ name ] || jQuery.find.attr;

  attrHandle[ name ] = function( elem, name, isXML ) {
    var ret, handle,
      lowercaseName = name.toLowerCase();

    if ( !isXML ) {

      // Avoid an infinite loop by temporarily removing this function from the getter
      handle = attrHandle[ lowercaseName ];
      attrHandle[ lowercaseName ] = ret;
      ret = getter( elem, name, isXML ) != null ?
        lowercaseName :
        null;
      attrHandle[ lowercaseName ] = handle;
    }
    return ret;
  };
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
  rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
  prop: function( name, value ) {
    return access( this, jQuery.prop, name, value, arguments.length > 1 );
  },

  removeProp: function( name ) {
    return this.each( function() {
      delete this[ jQuery.propFix[ name ] || name ];
    } );
  }
} );

jQuery.extend( {
  prop: function( elem, name, value ) {
    var ret, hooks,
      nType = elem.nodeType;

    // Don't get/set properties on text, comment and attribute nodes
    if ( nType === 3 || nType === 8 || nType === 2 ) {
      return;
    }

    if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

      // Fix name and attach hooks
      name = jQuery.propFix[ name ] || name;
      hooks = jQuery.propHooks[ name ];
    }

    if ( value !== undefined ) {
      if ( hooks && "set" in hooks &&
        ( ret = hooks.set( elem, value, name ) ) !== undefined ) {
        return ret;
      }

      return ( elem[ name ] = value );
    }

    if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
      return ret;
    }

    return elem[ name ];
  },

  propHooks: {
    tabIndex: {
      get: function( elem ) {

        // Support: IE <=9 - 11 only
        // elem.tabIndex doesn't always return the
        // correct value when it hasn't been explicitly set
        // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
        // Use proper attribute retrieval(#12072)
        var tabindex = jQuery.find.attr( elem, "tabindex" );

        if ( tabindex ) {
          return parseInt( tabindex, 10 );
        }

        if (
          rfocusable.test( elem.nodeName ) ||
          rclickable.test( elem.nodeName ) &&
          elem.href
        ) {
          return 0;
        }

        return -1;
      }
    }
  },

  propFix: {
    "for": "htmlFor",
    "class": "className"
  }
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
  jQuery.propHooks.selected = {
    get: function( elem ) {

      /* eslint no-unused-expressions: "off" */

      var parent = elem.parentNode;
      if ( parent && parent.parentNode ) {
        parent.parentNode.selectedIndex;
      }
      return null;
    },
    set: function( elem ) {

      /* eslint no-unused-expressions: "off" */

      var parent = elem.parentNode;
      if ( parent ) {
        parent.selectedIndex;

        if ( parent.parentNode ) {
          parent.parentNode.selectedIndex;
        }
      }
    }
  };
}

jQuery.each( [
  "tabIndex",
  "readOnly",
  "maxLength",
  "cellSpacing",
  "cellPadding",
  "rowSpan",
  "colSpan",
  "useMap",
  "frameBorder",
  "contentEditable"
], function() {
  jQuery.propFix[ this.toLowerCase() ] = this;
} );




  // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
  function stripAndCollapse( value ) {
    var tokens = value.match( rnothtmlwhite ) || [];
    return tokens.join( " " );
  }


function getClass( elem ) {
  return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
  if ( Array.isArray( value ) ) {
    return value;
  }
  if ( typeof value === "string" ) {
    return value.match( rnothtmlwhite ) || [];
  }
  return [];
}

jQuery.fn.extend( {
  addClass: function( value ) {
    var classes, elem, cur, curValue, clazz, j, finalValue,
      i = 0;

    if ( isFunction( value ) ) {
      return this.each( function( j ) {
        jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
      } );
    }

    classes = classesToArray( value );

    if ( classes.length ) {
      while ( ( elem = this[ i++ ] ) ) {
        curValue = getClass( elem );
        cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

        if ( cur ) {
          j = 0;
          while ( ( clazz = classes[ j++ ] ) ) {
            if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
              cur += clazz + " ";
            }
          }

          // Only assign if different to avoid unneeded rendering.
          finalValue = stripAndCollapse( cur );
          if ( curValue !== finalValue ) {
            elem.setAttribute( "class", finalValue );
          }
        }
      }
    }

    return this;
  },

  removeClass: function( value ) {
    var classes, elem, cur, curValue, clazz, j, finalValue,
      i = 0;

    if ( isFunction( value ) ) {
      return this.each( function( j ) {
        jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
      } );
    }

    if ( !arguments.length ) {
      return this.attr( "class", "" );
    }

    classes = classesToArray( value );

    if ( classes.length ) {
      while ( ( elem = this[ i++ ] ) ) {
        curValue = getClass( elem );

        // This expression is here for better compressibility (see addClass)
        cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

        if ( cur ) {
          j = 0;
          while ( ( clazz = classes[ j++ ] ) ) {

            // Remove *all* instances
            while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
              cur = cur.replace( " " + clazz + " ", " " );
            }
          }

          // Only assign if different to avoid unneeded rendering.
          finalValue = stripAndCollapse( cur );
          if ( curValue !== finalValue ) {
            elem.setAttribute( "class", finalValue );
          }
        }
      }
    }

    return this;
  },

  toggleClass: function( value, stateVal ) {
    var type = typeof value,
      isValidValue = type === "string" || Array.isArray( value );

    if ( typeof stateVal === "boolean" && isValidValue ) {
      return stateVal ? this.addClass( value ) : this.removeClass( value );
    }

    if ( isFunction( value ) ) {
      return this.each( function( i ) {
        jQuery( this ).toggleClass(
          value.call( this, i, getClass( this ), stateVal ),
          stateVal
        );
      } );
    }

    return this.each( function() {
      var className, i, self, classNames;

      if ( isValidValue ) {

        // Toggle individual class names
        i = 0;
        self = jQuery( this );
        classNames = classesToArray( value );

        while ( ( className = classNames[ i++ ] ) ) {

          // Check each className given, space separated list
          if ( self.hasClass( className ) ) {
            self.removeClass( className );
          } else {
            self.addClass( className );
          }
        }

      // Toggle whole class name
      } else if ( value === undefined || type === "boolean" ) {
        className = getClass( this );
        if ( className ) {

          // Store className if set
          dataPriv.set( this, "__className__", className );
        }

        // If the element has a class name or if we're passed `false`,
        // then remove the whole classname (if there was one, the above saved it).
        // Otherwise bring back whatever was previously saved (if anything),
        // falling back to the empty string if nothing was stored.
        if ( this.setAttribute ) {
          this.setAttribute( "class",
            className || value === false ?
            "" :
            dataPriv.get( this, "__className__" ) || ""
          );
        }
      }
    } );
  },

  hasClass: function( selector ) {
    var className, elem,
      i = 0;

    className = " " + selector + " ";
    while ( ( elem = this[ i++ ] ) ) {
      if ( elem.nodeType === 1 &&
        ( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
          return true;
      }
    }

    return false;
  }
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
  val: function( value ) {
    var hooks, ret, valueIsFunction,
      elem = this[ 0 ];

    if ( !arguments.length ) {
      if ( elem ) {
        hooks = jQuery.valHooks[ elem.type ] ||
          jQuery.valHooks[ elem.nodeName.toLowerCase() ];

        if ( hooks &&
          "get" in hooks &&
          ( ret = hooks.get( elem, "value" ) ) !== undefined
        ) {
          return ret;
        }

        ret = elem.value;

        // Handle most common string cases
        if ( typeof ret === "string" ) {
          return ret.replace( rreturn, "" );
        }

        // Handle cases where value is null/undef or number
        return ret == null ? "" : ret;
      }

      return;
    }

    valueIsFunction = isFunction( value );

    return this.each( function( i ) {
      var val;

      if ( this.nodeType !== 1 ) {
        return;
      }

      if ( valueIsFunction ) {
        val = value.call( this, i, jQuery( this ).val() );
      } else {
        val = value;
      }

      // Treat null/undefined as ""; convert numbers to string
      if ( val == null ) {
        val = "";

      } else if ( typeof val === "number" ) {
        val += "";

      } else if ( Array.isArray( val ) ) {
        val = jQuery.map( val, function( value ) {
          return value == null ? "" : value + "";
        } );
      }

      hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

      // If set returns undefined, fall back to normal setting
      if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
        this.value = val;
      }
    } );
  }
} );

jQuery.extend( {
  valHooks: {
    option: {
      get: function( elem ) {

        var val = jQuery.find.attr( elem, "value" );
        return val != null ?
          val :

          // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse( jQuery.text( elem ) );
      }
    },
    select: {
      get: function( elem ) {
        var value, option, i,
          options = elem.options,
          index = elem.selectedIndex,
          one = elem.type === "select-one",
          values = one ? null : [],
          max = one ? index + 1 : options.length;

        if ( index < 0 ) {
          i = max;

        } else {
          i = one ? index : 0;
        }

        // Loop through all the selected options
        for ( ; i < max; i++ ) {
          option = options[ i ];

          // Support: IE <=9 only
          // IE8-9 doesn't update selected after form reset (#2551)
          if ( ( option.selected || i === index ) &&

              // Don't return options that are disabled or in a disabled optgroup
              !option.disabled &&
              ( !option.parentNode.disabled ||
                !nodeName( option.parentNode, "optgroup" ) ) ) {

            // Get the specific value for the option
            value = jQuery( option ).val();

            // We don't need an array for one selects
            if ( one ) {
              return value;
            }

            // Multi-Selects return an array
            values.push( value );
          }
        }

        return values;
      },

      set: function( elem, value ) {
        var optionSet, option,
          options = elem.options,
          values = jQuery.makeArray( value ),
          i = options.length;

        while ( i-- ) {
          option = options[ i ];

          /* eslint-disable no-cond-assign */

          if ( option.selected =
            jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
          ) {
            optionSet = true;
          }

          /* eslint-enable no-cond-assign */
        }

        // Force browsers to behave consistently when non-matching value is set
        if ( !optionSet ) {
          elem.selectedIndex = -1;
        }
        return values;
      }
    }
  }
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
  jQuery.valHooks[ this ] = {
    set: function( elem, value ) {
      if ( Array.isArray( value ) ) {
        return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
      }
    }
  };
  if ( !support.checkOn ) {
    jQuery.valHooks[ this ].get = function( elem ) {
      return elem.getAttribute( "value" ) === null ? "on" : elem.value;
    };
  }
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
  stopPropagationCallback = function( e ) {
    e.stopPropagation();
  };

jQuery.extend( jQuery.event, {

  trigger: function( event, data, elem, onlyHandlers ) {

    var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
      eventPath = [ elem || document ],
      type = hasOwn.call( event, "type" ) ? event.type : event,
      namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

    cur = lastElement = tmp = elem = elem || document;

    // Don't do events on text and comment nodes
    if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
      return;
    }

    // focus/blur morphs to focusin/out; ensure we're not firing them right now
    if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
      return;
    }

    if ( type.indexOf( "." ) > -1 ) {

      // Namespaced trigger; create a regexp to match event type in handle()
      namespaces = type.split( "." );
      type = namespaces.shift();
      namespaces.sort();
    }
    ontype = type.indexOf( ":" ) < 0 && "on" + type;

    // Caller can pass in a jQuery.Event object, Object, or just an event type string
    event = event[ jQuery.expando ] ?
      event :
      new jQuery.Event( type, typeof event === "object" && event );

    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
    event.isTrigger = onlyHandlers ? 2 : 3;
    event.namespace = namespaces.join( "." );
    event.rnamespace = event.namespace ?
      new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
      null;

    // Clean up the event in case it is being reused
    event.result = undefined;
    if ( !event.target ) {
      event.target = elem;
    }

    // Clone any incoming data and prepend the event, creating the handler arg list
    data = data == null ?
      [ event ] :
      jQuery.makeArray( data, [ event ] );

    // Allow special events to draw outside the lines
    special = jQuery.event.special[ type ] || {};
    if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
      return;
    }

    // Determine event propagation path in advance, per W3C events spec (#9951)
    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

      bubbleType = special.delegateType || type;
      if ( !rfocusMorph.test( bubbleType + type ) ) {
        cur = cur.parentNode;
      }
      for ( ; cur; cur = cur.parentNode ) {
        eventPath.push( cur );
        tmp = cur;
      }

      // Only add window if we got to document (e.g., not plain obj or detached DOM)
      if ( tmp === ( elem.ownerDocument || document ) ) {
        eventPath.push( tmp.defaultView || tmp.parentWindow || window );
      }
    }

    // Fire handlers on the event path
    i = 0;
    while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
      lastElement = cur;
      event.type = i > 1 ?
        bubbleType :
        special.bindType || type;

      // jQuery handler
      handle = (
          dataPriv.get( cur, "events" ) || Object.create( null )
        )[ event.type ] &&
        dataPriv.get( cur, "handle" );
      if ( handle ) {
        handle.apply( cur, data );
      }

      // Native handler
      handle = ontype && cur[ ontype ];
      if ( handle && handle.apply && acceptData( cur ) ) {
        event.result = handle.apply( cur, data );
        if ( event.result === false ) {
          event.preventDefault();
        }
      }
    }
    event.type = type;

    // If nobody prevented the default action, do it now
    if ( !onlyHandlers && !event.isDefaultPrevented() ) {

      if ( ( !special._default ||
        special._default.apply( eventPath.pop(), data ) === false ) &&
        acceptData( elem ) ) {

        // Call a native DOM method on the target with the same name as the event.
        // Don't do default actions on window, that's where global variables be (#6170)
        if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

          // Don't re-trigger an onFOO event when we call its FOO() method
          tmp = elem[ ontype ];

          if ( tmp ) {
            elem[ ontype ] = null;
          }

          // Prevent re-triggering of the same event, since we already bubbled it above
          jQuery.event.triggered = type;

          if ( event.isPropagationStopped() ) {
            lastElement.addEventListener( type, stopPropagationCallback );
          }

          elem[ type ]();

          if ( event.isPropagationStopped() ) {
            lastElement.removeEventListener( type, stopPropagationCallback );
          }

          jQuery.event.triggered = undefined;

          if ( tmp ) {
            elem[ ontype ] = tmp;
          }
        }
      }
    }

    return event.result;
  },

  // Piggyback on a donor event to simulate a different one
  // Used only for `focus(in | out)` events
  simulate: function( type, elem, event ) {
    var e = jQuery.extend(
      new jQuery.Event(),
      event,
      {
        type: type,
        isSimulated: true
      }
    );

    jQuery.event.trigger( e, null, elem );
  }

} );

jQuery.fn.extend( {

  trigger: function( type, data ) {
    return this.each( function() {
      jQuery.event.trigger( type, data, this );
    } );
  },
  triggerHandler: function( type, data ) {
    var elem = this[ 0 ];
    if ( elem ) {
      return jQuery.event.trigger( type, data, elem, true );
    }
  }
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
  jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

    // Attach a single capturing handler on the document while someone wants focusin/focusout
    var handler = function( event ) {
      jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
    };

    jQuery.event.special[ fix ] = {
      setup: function() {

        // Handle: regular nodes (via `this.ownerDocument`), window
        // (via `this.document`) & document (via `this`).
        var doc = this.ownerDocument || this.document || this,
          attaches = dataPriv.access( doc, fix );

        if ( !attaches ) {
          doc.addEventListener( orig, handler, true );
        }
        dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
      },
      teardown: function() {
        var doc = this.ownerDocument || this.document || this,
          attaches = dataPriv.access( doc, fix ) - 1;

        if ( !attaches ) {
          doc.removeEventListener( orig, handler, true );
          dataPriv.remove( doc, fix );

        } else {
          dataPriv.access( doc, fix, attaches );
        }
      }
    };
  } );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
  var xml;
  if ( !data || typeof data !== "string" ) {
    return null;
  }

  // Support: IE 9 - 11 only
  // IE throws on parseFromString with invalid input.
  try {
    xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
  } catch ( e ) {
    xml = undefined;
  }

  if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
    jQuery.error( "Invalid XML: " + data );
  }
  return xml;
};


var
  rbracket = /\[\]$/,
  rCRLF = /\r?\n/g,
  rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
  rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
  var name;

  if ( Array.isArray( obj ) ) {

    // Serialize array item.
    jQuery.each( obj, function( i, v ) {
      if ( traditional || rbracket.test( prefix ) ) {

        // Treat each array item as a scalar.
        add( prefix, v );

      } else {

        // Item is non-scalar (array or object), encode its numeric index.
        buildParams(
          prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
          v,
          traditional,
          add
        );
      }
    } );

  } else if ( !traditional && toType( obj ) === "object" ) {

    // Serialize object item.
    for ( name in obj ) {
      buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    }

  } else {

    // Serialize scalar item.
    add( prefix, obj );
  }
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
  var prefix,
    s = [],
    add = function( key, valueOrFunction ) {

      // If value is a function, invoke it and use its return value
      var value = isFunction( valueOrFunction ) ?
        valueOrFunction() :
        valueOrFunction;

      s[ s.length ] = encodeURIComponent( key ) + "=" +
        encodeURIComponent( value == null ? "" : value );
    };

  if ( a == null ) {
    return "";
  }

  // If an array was passed in, assume that it is an array of form elements.
  if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

    // Serialize the form elements
    jQuery.each( a, function() {
      add( this.name, this.value );
    } );

  } else {

    // If traditional, encode the "old" way (the way 1.3.2 or older
    // did it), otherwise encode params recursively.
    for ( prefix in a ) {
      buildParams( prefix, a[ prefix ], traditional, add );
    }
  }

  // Return the resulting serialization
  return s.join( "&" );
};

jQuery.fn.extend( {
  serialize: function() {
    return jQuery.param( this.serializeArray() );
  },
  serializeArray: function() {
    return this.map( function() {

      // Can add propHook for "elements" to filter or add form elements
      var elements = jQuery.prop( this, "elements" );
      return elements ? jQuery.makeArray( elements ) : this;
    } )
    .filter( function() {
      var type = this.type;

      // Use .is( ":disabled" ) so that fieldset[disabled] works
      return this.name && !jQuery( this ).is( ":disabled" ) &&
        rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
        ( this.checked || !rcheckableType.test( type ) );
    } )
    .map( function( _i, elem ) {
      var val = jQuery( this ).val();

      if ( val == null ) {
        return null;
      }

      if ( Array.isArray( val ) ) {
        return jQuery.map( val, function( val ) {
          return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
        } );
      }

      return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    } ).get();
  }
} );


var
  r20 = /%20/g,
  rhash = /#.*$/,
  rantiCache = /([?&])_=[^&]*/,
  rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

  // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
  rnoContent = /^(?:GET|HEAD)$/,
  rprotocol = /^\/\//,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},

  // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat( "*" ),

  // Anchor tag for parsing the document origin
  originAnchor = document.createElement( "a" );
  originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

  // dataTypeExpression is optional and defaults to "*"
  return function( dataTypeExpression, func ) {

    if ( typeof dataTypeExpression !== "string" ) {
      func = dataTypeExpression;
      dataTypeExpression = "*";
    }

    var dataType,
      i = 0,
      dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

    if ( isFunction( func ) ) {

      // For each dataType in the dataTypeExpression
      while ( ( dataType = dataTypes[ i++ ] ) ) {

        // Prepend if requested
        if ( dataType[ 0 ] === "+" ) {
          dataType = dataType.slice( 1 ) || "*";
          ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

        // Otherwise append
        } else {
          ( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
        }
      }
    }
  };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

  var inspected = {},
    seekingTransport = ( structure === transports );

  function inspect( dataType ) {
    var selected;
    inspected[ dataType ] = true;
    jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
      var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
      if ( typeof dataTypeOrTransport === "string" &&
        !seekingTransport && !inspected[ dataTypeOrTransport ] ) {

        options.dataTypes.unshift( dataTypeOrTransport );
        inspect( dataTypeOrTransport );
        return false;
      } else if ( seekingTransport ) {
        return !( selected = dataTypeOrTransport );
      }
    } );
    return selected;
  }

  return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
  var key, deep,
    flatOptions = jQuery.ajaxSettings.flatOptions || {};

  for ( key in src ) {
    if ( src[ key ] !== undefined ) {
      ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
    }
  }
  if ( deep ) {
    jQuery.extend( true, target, deep );
  }

  return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

  var ct, type, finalDataType, firstDataType,
    contents = s.contents,
    dataTypes = s.dataTypes;

  // Remove auto dataType and get content-type in the process
  while ( dataTypes[ 0 ] === "*" ) {
    dataTypes.shift();
    if ( ct === undefined ) {
      ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
    }
  }

  // Check if we're dealing with a known content-type
  if ( ct ) {
    for ( type in contents ) {
      if ( contents[ type ] && contents[ type ].test( ct ) ) {
        dataTypes.unshift( type );
        break;
      }
    }
  }

  // Check to see if we have a response for the expected dataType
  if ( dataTypes[ 0 ] in responses ) {
    finalDataType = dataTypes[ 0 ];
  } else {

    // Try convertible dataTypes
    for ( type in responses ) {
      if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
        finalDataType = type;
        break;
      }
      if ( !firstDataType ) {
        firstDataType = type;
      }
    }

    // Or just use first one
    finalDataType = finalDataType || firstDataType;
  }

  // If we found a dataType
  // We add the dataType to the list if needed
  // and return the corresponding response
  if ( finalDataType ) {
    if ( finalDataType !== dataTypes[ 0 ] ) {
      dataTypes.unshift( finalDataType );
    }
    return responses[ finalDataType ];
  }
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
  var conv2, current, conv, tmp, prev,
    converters = {},

    // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice();

  // Create converters map with lowercased keys
  if ( dataTypes[ 1 ] ) {
    for ( conv in s.converters ) {
      converters[ conv.toLowerCase() ] = s.converters[ conv ];
    }
  }

  current = dataTypes.shift();

  // Convert to each sequential dataType
  while ( current ) {

    if ( s.responseFields[ current ] ) {
      jqXHR[ s.responseFields[ current ] ] = response;
    }

    // Apply the dataFilter if provided
    if ( !prev && isSuccess && s.dataFilter ) {
      response = s.dataFilter( response, s.dataType );
    }

    prev = current;
    current = dataTypes.shift();

    if ( current ) {

      // There's only work to do if current dataType is non-auto
      if ( current === "*" ) {

        current = prev;

      // Convert response if prev dataType is non-auto and differs from current
      } else if ( prev !== "*" && prev !== current ) {

        // Seek a direct converter
        conv = converters[ prev + " " + current ] || converters[ "* " + current ];

        // If none found, seek a pair
        if ( !conv ) {
          for ( conv2 in converters ) {

            // If conv2 outputs current
            tmp = conv2.split( " " );
            if ( tmp[ 1 ] === current ) {

              // If prev can be converted to accepted input
              conv = converters[ prev + " " + tmp[ 0 ] ] ||
                converters[ "* " + tmp[ 0 ] ];
              if ( conv ) {

                // Condense equivalence converters
                if ( conv === true ) {
                  conv = converters[ conv2 ];

                // Otherwise, insert the intermediate dataType
                } else if ( converters[ conv2 ] !== true ) {
                  current = tmp[ 0 ];
                  dataTypes.unshift( tmp[ 1 ] );
                }
                break;
              }
            }
          }
        }

        // Apply converter (if not an equivalence)
        if ( conv !== true ) {

          // Unless errors are allowed to bubble, catch and return them
          if ( conv && s.throws ) {
            response = conv( response );
          } else {
            try {
              response = conv( response );
            } catch ( e ) {
              return {
                state: "parsererror",
                error: conv ? e : "No conversion from " + prev + " to " + current
              };
            }
          }
        }
      }
    }
  }

  return { state: "success", data: response };
}

jQuery.extend( {

  // Counter for holding the number of active queries
  active: 0,

  // Last-Modified header cache for next request
  lastModified: {},
  etag: {},

  ajaxSettings: {
    url: location.href,
    type: "GET",
    isLocal: rlocalProtocol.test( location.protocol ),
    global: true,
    processData: true,
    async: true,
    contentType: "application/x-www-form-urlencoded; charset=UTF-8",

    /*
    timeout: 0,
    data: null,
    dataType: null,
    username: null,
    password: null,
    cache: null,
    throws: false,
    traditional: false,
    headers: {},
    */

    accepts: {
      "*": allTypes,
      text: "text/plain",
      html: "text/html",
      xml: "application/xml, text/xml",
      json: "application/json, text/javascript"
    },

    contents: {
      xml: /\bxml\b/,
      html: /\bhtml/,
      json: /\bjson\b/
    },

    responseFields: {
      xml: "responseXML",
      text: "responseText",
      json: "responseJSON"
    },

    // Data converters
    // Keys separate source (or catchall "*") and destination types with a single space
    converters: {

      // Convert anything to text
      "* text": String,

      // Text to html (true = no transformation)
      "text html": true,

      // Evaluate text as a json expression
      "text json": JSON.parse,

      // Parse text as xml
      "text xml": jQuery.parseXML
    },

    // For options that shouldn't be deep extended:
    // you can add your own custom options here if
    // and when you create one that shouldn't be
    // deep extended (see ajaxExtend)
    flatOptions: {
      url: true,
      context: true
    }
  },

  // Creates a full fledged settings object into target
  // with both ajaxSettings and settings fields.
  // If target is omitted, writes into ajaxSettings.
  ajaxSetup: function( target, settings ) {
    return settings ?

      // Building a settings object
      ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

      // Extending ajaxSettings
      ajaxExtend( jQuery.ajaxSettings, target );
  },

  ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
  ajaxTransport: addToPrefiltersOrTransports( transports ),

  // Main method
  ajax: function( url, options ) {

    // If url is an object, simulate pre-1.5 signature
    if ( typeof url === "object" ) {
      options = url;
      url = undefined;
    }

    // Force options to be an object
    options = options || {};

    var transport,

      // URL without anti-cache param
      cacheURL,

      // Response headers
      responseHeadersString,
      responseHeaders,

      // timeout handle
      timeoutTimer,

      // Url cleanup var
      urlAnchor,

      // Request state (becomes false upon send and true upon completion)
      completed,

      // To know if global events are to be dispatched
      fireGlobals,

      // Loop variable
      i,

      // uncached part of the url
      uncached,

      // Create the final options object
      s = jQuery.ajaxSetup( {}, options ),

      // Callbacks context
      callbackContext = s.context || s,

      // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context &&
        ( callbackContext.nodeType || callbackContext.jquery ) ?
          jQuery( callbackContext ) :
          jQuery.event,

      // Deferreds
      deferred = jQuery.Deferred(),
      completeDeferred = jQuery.Callbacks( "once memory" ),

      // Status-dependent callbacks
      statusCode = s.statusCode || {},

      // Headers (they are sent all at once)
      requestHeaders = {},
      requestHeadersNames = {},

      // Default abort message
      strAbort = "canceled",

      // Fake xhr
      jqXHR = {
        readyState: 0,

        // Builds headers hashtable if needed
        getResponseHeader: function( key ) {
          var match;
          if ( completed ) {
            if ( !responseHeaders ) {
              responseHeaders = {};
              while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
                responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
                  ( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
                    .concat( match[ 2 ] );
              }
            }
            match = responseHeaders[ key.toLowerCase() + " " ];
          }
          return match == null ? null : match.join( ", " );
        },

        // Raw string
        getAllResponseHeaders: function() {
          return completed ? responseHeadersString : null;
        },

        // Caches the header
        setRequestHeader: function( name, value ) {
          if ( completed == null ) {
            name = requestHeadersNames[ name.toLowerCase() ] =
              requestHeadersNames[ name.toLowerCase() ] || name;
            requestHeaders[ name ] = value;
          }
          return this;
        },

        // Overrides response content-type header
        overrideMimeType: function( type ) {
          if ( completed == null ) {
            s.mimeType = type;
          }
          return this;
        },

        // Status-dependent callbacks
        statusCode: function( map ) {
          var code;
          if ( map ) {
            if ( completed ) {

              // Execute the appropriate callbacks
              jqXHR.always( map[ jqXHR.status ] );
            } else {

              // Lazy-add the new callbacks in a way that preserves old ones
              for ( code in map ) {
                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
              }
            }
          }
          return this;
        },

        // Cancel the request
        abort: function( statusText ) {
          var finalText = statusText || strAbort;
          if ( transport ) {
            transport.abort( finalText );
          }
          done( 0, finalText );
          return this;
        }
      };

    // Attach deferreds
    deferred.promise( jqXHR );

    // Add protocol if not provided (prefilters might expect it)
    // Handle falsy url in the settings object (#10093: consistency with old signature)
    // We also use the url parameter if available
    s.url = ( ( url || s.url || location.href ) + "" )
      .replace( rprotocol, location.protocol + "//" );

    // Alias method option to type as per ticket #12004
    s.type = options.method || options.type || s.method || s.type;

    // Extract dataTypes list
    s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

    // A cross-domain request is in order when the origin doesn't match the current origin.
    if ( s.crossDomain == null ) {
      urlAnchor = document.createElement( "a" );

      // Support: IE <=8 - 11, Edge 12 - 15
      // IE throws exception on accessing the href property if url is malformed,
      // e.g. http://example.com:80x/
      try {
        urlAnchor.href = s.url;

        // Support: IE <=8 - 11 only
        // Anchor's host property isn't correctly set when s.url is relative
        urlAnchor.href = urlAnchor.href;
        s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
          urlAnchor.protocol + "//" + urlAnchor.host;
      } catch ( e ) {

        // If there is an error parsing the URL, assume it is crossDomain,
        // it can be rejected by the transport if it is invalid
        s.crossDomain = true;
      }
    }

    // Convert data if not already a string
    if ( s.data && s.processData && typeof s.data !== "string" ) {
      s.data = jQuery.param( s.data, s.traditional );
    }

    // Apply prefilters
    inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

    // If request was aborted inside a prefilter, stop there
    if ( completed ) {
      return jqXHR;
    }

    // We can fire global events as of now if asked to
    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
    fireGlobals = jQuery.event && s.global;

    // Watch for a new set of requests
    if ( fireGlobals && jQuery.active++ === 0 ) {
      jQuery.event.trigger( "ajaxStart" );
    }

    // Uppercase the type
    s.type = s.type.toUpperCase();

    // Determine if request has content
    s.hasContent = !rnoContent.test( s.type );

    // Save the URL in case we're toying with the If-Modified-Since
    // and/or If-None-Match header later on
    // Remove hash to simplify url manipulation
    cacheURL = s.url.replace( rhash, "" );

    // More options handling for requests with no content
    if ( !s.hasContent ) {

      // Remember the hash so we can put it back
      uncached = s.url.slice( cacheURL.length );

      // If data is available and should be processed, append data to url
      if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
        cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

        // #9682: remove data so that it's not used in an eventual retry
        delete s.data;
      }

      // Add or update anti-cache param if needed
      if ( s.cache === false ) {
        cacheURL = cacheURL.replace( rantiCache, "$1" );
        uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
          uncached;
      }

      // Put hash and anti-cache on the URL that will be requested (gh-1732)
      s.url = cacheURL + uncached;

    // Change '%20' to '+' if this is encoded form body content (gh-2658)
    } else if ( s.data && s.processData &&
      ( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
      s.data = s.data.replace( r20, "+" );
    }

    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    if ( s.ifModified ) {
      if ( jQuery.lastModified[ cacheURL ] ) {
        jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
      }
      if ( jQuery.etag[ cacheURL ] ) {
        jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
      }
    }

    // Set the correct header, if data is being sent
    if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
      jqXHR.setRequestHeader( "Content-Type", s.contentType );
    }

    // Set the Accepts header for the server, depending on the dataType
    jqXHR.setRequestHeader(
      "Accept",
      s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
        s.accepts[ s.dataTypes[ 0 ] ] +
          ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
        s.accepts[ "*" ]
    );

    // Check for headers option
    for ( i in s.headers ) {
      jqXHR.setRequestHeader( i, s.headers[ i ] );
    }

    // Allow custom headers/mimetypes and early abort
    if ( s.beforeSend &&
      ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

      // Abort if not done already and return
      return jqXHR.abort();
    }

    // Aborting is no longer a cancellation
    strAbort = "abort";

    // Install callbacks on deferreds
    completeDeferred.add( s.complete );
    jqXHR.done( s.success );
    jqXHR.fail( s.error );

    // Get transport
    transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

    // If no transport, we auto-abort
    if ( !transport ) {
      done( -1, "No Transport" );
    } else {
      jqXHR.readyState = 1;

      // Send global event
      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
      }

      // If request was aborted inside ajaxSend, stop there
      if ( completed ) {
        return jqXHR;
      }

      // Timeout
      if ( s.async && s.timeout > 0 ) {
        timeoutTimer = window.setTimeout( function() {
          jqXHR.abort( "timeout" );
        }, s.timeout );
      }

      try {
        completed = false;
        transport.send( requestHeaders, done );
      } catch ( e ) {

        // Rethrow post-completion exceptions
        if ( completed ) {
          throw e;
        }

        // Propagate others as results
        done( -1, e );
      }
    }

    // Callback for when everything is done
    function done( status, nativeStatusText, responses, headers ) {
      var isSuccess, success, error, response, modified,
        statusText = nativeStatusText;

      // Ignore repeat invocations
      if ( completed ) {
        return;
      }

      completed = true;

      // Clear timeout if it exists
      if ( timeoutTimer ) {
        window.clearTimeout( timeoutTimer );
      }

      // Dereference transport for early garbage collection
      // (no matter how long the jqXHR object will be used)
      transport = undefined;

      // Cache response headers
      responseHeadersString = headers || "";

      // Set readyState
      jqXHR.readyState = status > 0 ? 4 : 0;

      // Determine if successful
      isSuccess = status >= 200 && status < 300 || status === 304;

      // Get response data
      if ( responses ) {
        response = ajaxHandleResponses( s, jqXHR, responses );
      }

      // Use a noop converter for missing script
      if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
        s.converters[ "text script" ] = function() {};
      }

      // Convert no matter what (that way responseXXX fields are always set)
      response = ajaxConvert( s, response, jqXHR, isSuccess );

      // If successful, handle type chaining
      if ( isSuccess ) {

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {
          modified = jqXHR.getResponseHeader( "Last-Modified" );
          if ( modified ) {
            jQuery.lastModified[ cacheURL ] = modified;
          }
          modified = jqXHR.getResponseHeader( "etag" );
          if ( modified ) {
            jQuery.etag[ cacheURL ] = modified;
          }
        }

        // if no content
        if ( status === 204 || s.type === "HEAD" ) {
          statusText = "nocontent";

        // if not modified
        } else if ( status === 304 ) {
          statusText = "notmodified";

        // If we have data, let's convert it
        } else {
          statusText = response.state;
          success = response.data;
          error = response.error;
          isSuccess = !error;
        }
      } else {

        // Extract error from statusText and normalize for non-aborts
        error = statusText;
        if ( status || !statusText ) {
          statusText = "error";
          if ( status < 0 ) {
            status = 0;
          }
        }
      }

      // Set data for the fake xhr object
      jqXHR.status = status;
      jqXHR.statusText = ( nativeStatusText || statusText ) + "";

      // Success/Error
      if ( isSuccess ) {
        deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
      } else {
        deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
      }

      // Status-dependent callbacks
      jqXHR.statusCode( statusCode );
      statusCode = undefined;

      if ( fireGlobals ) {
        globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
          [ jqXHR, s, isSuccess ? success : error ] );
      }

      // Complete
      completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

      if ( fireGlobals ) {
        globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

        // Handle the global AJAX counter
        if ( !( --jQuery.active ) ) {
          jQuery.event.trigger( "ajaxStop" );
        }
      }
    }

    return jqXHR;
  },

  getJSON: function( url, data, callback ) {
    return jQuery.get( url, data, callback, "json" );
  },

  getScript: function( url, callback ) {
    return jQuery.get( url, undefined, callback, "script" );
  }
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
  jQuery[ method ] = function( url, data, callback, type ) {

    // Shift arguments if data argument was omitted
    if ( isFunction( data ) ) {
      type = type || callback;
      callback = data;
      data = undefined;
    }

    // The url can be an options object (which then must have .url)
    return jQuery.ajax( jQuery.extend( {
      url: url,
      type: method,
      dataType: type,
      data: data,
      success: callback
    }, jQuery.isPlainObject( url ) && url ) );
  };
} );

jQuery.ajaxPrefilter( function( s ) {
  var i;
  for ( i in s.headers ) {
    if ( i.toLowerCase() === "content-type" ) {
      s.contentType = s.headers[ i ] || "";
    }
  }
} );


jQuery._evalUrl = function( url, options, doc ) {
  return jQuery.ajax( {
    url: url,

    // Make this explicit, since user can override this through ajaxSetup (#11264)
    type: "GET",
    dataType: "script",
    cache: true,
    async: false,
    global: false,

    // Only evaluate the response if it is successful (gh-4126)
    // dataFilter is not invoked for failure responses, so using it instead
    // of the default converter is kludgy but it works.
    converters: {
      "text script": function() {}
    },
    dataFilter: function( response ) {
      jQuery.globalEval( response, options, doc );
    }
  } );
};


jQuery.fn.extend( {
  wrapAll: function( html ) {
    var wrap;

    if ( this[ 0 ] ) {
      if ( isFunction( html ) ) {
        html = html.call( this[ 0 ] );
      }

      // The elements to wrap the target around
      wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

      if ( this[ 0 ].parentNode ) {
        wrap.insertBefore( this[ 0 ] );
      }

      wrap.map( function() {
        var elem = this;

        while ( elem.firstElementChild ) {
          elem = elem.firstElementChild;
        }

        return elem;
      } ).append( this );
    }

    return this;
  },

  wrapInner: function( html ) {
    if ( isFunction( html ) ) {
      return this.each( function( i ) {
        jQuery( this ).wrapInner( html.call( this, i ) );
      } );
    }

    return this.each( function() {
      var self = jQuery( this ),
        contents = self.contents();

      if ( contents.length ) {
        contents.wrapAll( html );

      } else {
        self.append( html );
      }
    } );
  },

  wrap: function( html ) {
    var htmlIsFunction = isFunction( html );

    return this.each( function( i ) {
      jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
    } );
  },

  unwrap: function( selector ) {
    this.parent( selector ).not( "body" ).each( function() {
      jQuery( this ).replaceWith( this.childNodes );
    } );
    return this;
  }
} );


jQuery.expr.pseudos.hidden = function( elem ) {
  return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
  return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
  try {
    return new window.XMLHttpRequest();
  } catch ( e ) {}
};

var xhrSuccessStatus = {

    // File protocol always yields status code 0, assume 200
    0: 200,

    // Support: IE <=9 only
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
  xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
  var callback, errorCallback;

  // Cross domain only allowed if supported through XMLHttpRequest
  if ( support.cors || xhrSupported && !options.crossDomain ) {
    return {
      send: function( headers, complete ) {
        var i,
          xhr = options.xhr();

        xhr.open(
          options.type,
          options.url,
          options.async,
          options.username,
          options.password
        );

        // Apply custom fields if provided
        if ( options.xhrFields ) {
          for ( i in options.xhrFields ) {
            xhr[ i ] = options.xhrFields[ i ];
          }
        }

        // Override mime type if needed
        if ( options.mimeType && xhr.overrideMimeType ) {
          xhr.overrideMimeType( options.mimeType );
        }

        // X-Requested-With header
        // For cross-domain requests, seeing as conditions for a preflight are
        // akin to a jigsaw puzzle, we simply never set it to be sure.
        // (it can always be set on a per-request basis or even using ajaxSetup)
        // For same-domain requests, won't change header if already provided.
        if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
          headers[ "X-Requested-With" ] = "XMLHttpRequest";
        }

        // Set headers
        for ( i in headers ) {
          xhr.setRequestHeader( i, headers[ i ] );
        }

        // Callback
        callback = function( type ) {
          return function() {
            if ( callback ) {
              callback = errorCallback = xhr.onload =
                xhr.onerror = xhr.onabort = xhr.ontimeout =
                  xhr.onreadystatechange = null;

              if ( type === "abort" ) {
                xhr.abort();
              } else if ( type === "error" ) {

                // Support: IE <=9 only
                // On a manual native abort, IE9 throws
                // errors on any property access that is not readyState
                if ( typeof xhr.status !== "number" ) {
                  complete( 0, "error" );
                } else {
                  complete(

                    // File: protocol always yields status 0; see #8605, #14207
                    xhr.status,
                    xhr.statusText
                  );
                }
              } else {
                complete(
                  xhrSuccessStatus[ xhr.status ] || xhr.status,
                  xhr.statusText,

                  // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  ( xhr.responseType || "text" ) !== "text"  ||
                  typeof xhr.responseText !== "string" ?
                    { binary: xhr.response } :
                    { text: xhr.responseText },
                  xhr.getAllResponseHeaders()
                );
              }
            }
          };
        };

        // Listen to events
        xhr.onload = callback();
        errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

        // Support: IE 9 only
        // Use onreadystatechange to replace onabort
        // to handle uncaught aborts
        if ( xhr.onabort !== undefined ) {
          xhr.onabort = errorCallback;
        } else {
          xhr.onreadystatechange = function() {

            // Check readyState before timeout as it changes
            if ( xhr.readyState === 4 ) {

              // Allow onerror to be called first,
              // but that will not handle a native abort
              // Also, save errorCallback to a variable
              // as xhr.onerror cannot be accessed
              window.setTimeout( function() {
                if ( callback ) {
                  errorCallback();
                }
              } );
            }
          };
        }

        // Create the abort callback
        callback = callback( "abort" );

        try {

          // Do send the request (this may raise an exception)
          xhr.send( options.hasContent && options.data || null );
        } catch ( e ) {

          // #14683: Only rethrow if this hasn't been notified as an error yet
          if ( callback ) {
            throw e;
          }
        }
      },

      abort: function() {
        if ( callback ) {
          callback();
        }
      }
    };
  }
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
  if ( s.crossDomain ) {
    s.contents.script = false;
  }
} );

// Install script dataType
jQuery.ajaxSetup( {
  accepts: {
    script: "text/javascript, application/javascript, " +
      "application/ecmascript, application/x-ecmascript"
  },
  contents: {
    script: /\b(?:java|ecma)script\b/
  },
  converters: {
    "text script": function( text ) {
      jQuery.globalEval( text );
      return text;
    }
  }
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
  if ( s.cache === undefined ) {
    s.cache = false;
  }
  if ( s.crossDomain ) {
    s.type = "GET";
  }
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

  // This transport only deals with cross domain or forced-by-attrs requests
  if ( s.crossDomain || s.scriptAttrs ) {
    var script, callback;
    return {
      send: function( _, complete ) {
        script = jQuery( "<script>" )
          .attr( s.scriptAttrs || {} )
          .prop( { charset: s.scriptCharset, src: s.url } )
          .on( "load error", callback = function( evt ) {
            script.remove();
            callback = null;
            if ( evt ) {
              complete( evt.type === "error" ? 404 : 200, evt.type );
            }
          } );

        // Use native DOM manipulation to avoid our domManip AJAX trickery
        document.head.appendChild( script[ 0 ] );
      },
      abort: function() {
        if ( callback ) {
          callback();
        }
      }
    };
  }
} );




var oldCallbacks = [],
  rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
  jsonp: "callback",
  jsonpCallback: function() {
    var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
    this[ callback ] = true;
    return callback;
  }
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

  var callbackName, overwritten, responseContainer,
    jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
      "url" :
      typeof s.data === "string" &&
        ( s.contentType || "" )
          .indexOf( "application/x-www-form-urlencoded" ) === 0 &&
        rjsonp.test( s.data ) && "data"
    );

  // Handle iff the expected data type is "jsonp" or we have a parameter to set
  if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

    // Get callback name, remembering preexisting value associated with it
    callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
      s.jsonpCallback() :
      s.jsonpCallback;

    // Insert callback into url or form data
    if ( jsonProp ) {
      s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
    } else if ( s.jsonp !== false ) {
      s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
    }

    // Use data converter to retrieve json after script execution
    s.converters[ "script json" ] = function() {
      if ( !responseContainer ) {
        jQuery.error( callbackName + " was not called" );
      }
      return responseContainer[ 0 ];
    };

    // Force json dataType
    s.dataTypes[ 0 ] = "json";

    // Install callback
    overwritten = window[ callbackName ];
    window[ callbackName ] = function() {
      responseContainer = arguments;
    };

    // Clean-up function (fires after converters)
    jqXHR.always( function() {

      // If previous value didn't exist - remove it
      if ( overwritten === undefined ) {
        jQuery( window ).removeProp( callbackName );

      // Otherwise restore preexisting value
      } else {
        window[ callbackName ] = overwritten;
      }

      // Save back as free
      if ( s[ callbackName ] ) {

        // Make sure that re-using the options doesn't screw things around
        s.jsonpCallback = originalSettings.jsonpCallback;

        // Save the callback name for future use
        oldCallbacks.push( callbackName );
      }

      // Call if it was a function and we have a response
      if ( responseContainer && isFunction( overwritten ) ) {
        overwritten( responseContainer[ 0 ] );
      }

      responseContainer = overwritten = undefined;
    } );

    // Delegate to script
    return "script";
  }
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
  var body = document.implementation.createHTMLDocument( "" ).body;
  body.innerHTML = "<form></form><form></form>";
  return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
  if ( typeof data !== "string" ) {
    return [];
  }
  if ( typeof context === "boolean" ) {
    keepScripts = context;
    context = false;
  }

  var base, parsed, scripts;

  if ( !context ) {

    // Stop scripts or inline event handlers from being executed immediately
    // by using document.implementation
    if ( support.createHTMLDocument ) {
      context = document.implementation.createHTMLDocument( "" );

      // Set the base href for the created document
      // so any parsed elements with URLs
      // are based on the document's URL (gh-2965)
      base = context.createElement( "base" );
      base.href = document.location.href;
      context.head.appendChild( base );
    } else {
      context = document;
    }
  }

  parsed = rsingleTag.exec( data );
  scripts = !keepScripts && [];

  // Single tag
  if ( parsed ) {
    return [ context.createElement( parsed[ 1 ] ) ];
  }

  parsed = buildFragment( [ data ], context, scripts );

  if ( scripts && scripts.length ) {
    jQuery( scripts ).remove();
  }

  return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
  var selector, type, response,
    self = this,
    off = url.indexOf( " " );

  if ( off > -1 ) {
    selector = stripAndCollapse( url.slice( off ) );
    url = url.slice( 0, off );
  }

  // If it's a function
  if ( isFunction( params ) ) {

    // We assume that it's the callback
    callback = params;
    params = undefined;

  // Otherwise, build a param string
  } else if ( params && typeof params === "object" ) {
    type = "POST";
  }

  // If we have elements to modify, make the request
  if ( self.length > 0 ) {
    jQuery.ajax( {
      url: url,

      // If "type" variable is undefined, then "GET" method will be used.
      // Make value of this field explicit since
      // user can override it through ajaxSetup method
      type: type || "GET",
      dataType: "html",
      data: params
    } ).done( function( responseText ) {

      // Save response for use in complete callback
      response = arguments;

      self.html( selector ?

        // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

        // Otherwise use the full result
        responseText );

    // If the request succeeds, this function gets "data", "status", "jqXHR"
    // but they are ignored because response was set above.
    // If it fails, this function gets "jqXHR", "status", "error"
    } ).always( callback && function( jqXHR, status ) {
      self.each( function() {
        callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
      } );
    } );
  }

  return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
  return jQuery.grep( jQuery.timers, function( fn ) {
    return elem === fn.elem;
  } ).length;
};




jQuery.offset = {
  setOffset: function( elem, options, i ) {
    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
      position = jQuery.css( elem, "position" ),
      curElem = jQuery( elem ),
      props = {};

    // Set position first, in-case top/left are set even on static elem
    if ( position === "static" ) {
      elem.style.position = "relative";
    }

    curOffset = curElem.offset();
    curCSSTop = jQuery.css( elem, "top" );
    curCSSLeft = jQuery.css( elem, "left" );
    calculatePosition = ( position === "absolute" || position === "fixed" ) &&
      ( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

    // Need to be able to calculate position if either
    // top or left is auto and position is either absolute or fixed
    if ( calculatePosition ) {
      curPosition = curElem.position();
      curTop = curPosition.top;
      curLeft = curPosition.left;

    } else {
      curTop = parseFloat( curCSSTop ) || 0;
      curLeft = parseFloat( curCSSLeft ) || 0;
    }

    if ( isFunction( options ) ) {

      // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
      options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
    }

    if ( options.top != null ) {
      props.top = ( options.top - curOffset.top ) + curTop;
    }
    if ( options.left != null ) {
      props.left = ( options.left - curOffset.left ) + curLeft;
    }

    if ( "using" in options ) {
      options.using.call( elem, props );

    } else {
      if ( typeof props.top === "number" ) {
        props.top += "px";
      }
      if ( typeof props.left === "number" ) {
        props.left += "px";
      }
      curElem.css( props );
    }
  }
};

jQuery.fn.extend( {

  // offset() relates an element's border box to the document origin
  offset: function( options ) {

    // Preserve chaining for setter
    if ( arguments.length ) {
      return options === undefined ?
        this :
        this.each( function( i ) {
          jQuery.offset.setOffset( this, options, i );
        } );
    }

    var rect, win,
      elem = this[ 0 ];

    if ( !elem ) {
      return;
    }

    // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
    // Support: IE <=11 only
    // Running getBoundingClientRect on a
    // disconnected node in IE throws an error
    if ( !elem.getClientRects().length ) {
      return { top: 0, left: 0 };
    }

    // Get document-relative position by adding viewport scroll to viewport-relative gBCR
    rect = elem.getBoundingClientRect();
    win = elem.ownerDocument.defaultView;
    return {
      top: rect.top + win.pageYOffset,
      left: rect.left + win.pageXOffset
    };
  },

  // position() relates an element's margin box to its offset parent's padding box
  // This corresponds to the behavior of CSS absolute positioning
  position: function() {
    if ( !this[ 0 ] ) {
      return;
    }

    var offsetParent, offset, doc,
      elem = this[ 0 ],
      parentOffset = { top: 0, left: 0 };

    // position:fixed elements are offset from the viewport, which itself always has zero offset
    if ( jQuery.css( elem, "position" ) === "fixed" ) {

      // Assume position:fixed implies availability of getBoundingClientRect
      offset = elem.getBoundingClientRect();

    } else {
      offset = this.offset();

      // Account for the *real* offset parent, which can be the document or its root element
      // when a statically positioned element is identified
      doc = elem.ownerDocument;
      offsetParent = elem.offsetParent || doc.documentElement;
      while ( offsetParent &&
        ( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
        jQuery.css( offsetParent, "position" ) === "static" ) {

        offsetParent = offsetParent.parentNode;
      }
      if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

        // Incorporate borders into its offset, since they are outside its content origin
        parentOffset = jQuery( offsetParent ).offset();
        parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
        parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
      }
    }

    // Subtract parent offsets and element margins
    return {
      top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
      left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
    };
  },

  // This method will return documentElement in the following cases:
  // 1) For the element inside the iframe without offsetParent, this method will return
  //    documentElement of the parent window
  // 2) For the hidden or detached element
  // 3) For body or html element, i.e. in case of the html node - it will return itself
  //
  // but those exceptions were never presented as a real life use-cases
  // and might be considered as more preferable results.
  //
  // This logic, however, is not guaranteed and can change at any point in the future
  offsetParent: function() {
    return this.map( function() {
      var offsetParent = this.offsetParent;

      while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
        offsetParent = offsetParent.offsetParent;
      }

      return offsetParent || documentElement;
    } );
  }
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
  var top = "pageYOffset" === prop;

  jQuery.fn[ method ] = function( val ) {
    return access( this, function( elem, method, val ) {

      // Coalesce documents and windows
      var win;
      if ( isWindow( elem ) ) {
        win = elem;
      } else if ( elem.nodeType === 9 ) {
        win = elem.defaultView;
      }

      if ( val === undefined ) {
        return win ? win[ prop ] : elem[ method ];
      }

      if ( win ) {
        win.scrollTo(
          !top ? val : win.pageXOffset,
          top ? val : win.pageYOffset
        );

      } else {
        elem[ method ] = val;
      }
    }, method, val, arguments.length );
  };
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
  jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
    function( elem, computed ) {
      if ( computed ) {
        computed = curCSS( elem, prop );

        // If curCSS returns percentage, fallback to offset
        return rnumnonpx.test( computed ) ?
          jQuery( elem ).position()[ prop ] + "px" :
          computed;
      }
    }
  );
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
  jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
    function( defaultExtra, funcName ) {

    // Margin is only for outerHeight, outerWidth
    jQuery.fn[ funcName ] = function( margin, value ) {
      var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
        extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

      return access( this, function( elem, type, value ) {
        var doc;

        if ( isWindow( elem ) ) {

          // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
          return funcName.indexOf( "outer" ) === 0 ?
            elem[ "inner" + name ] :
            elem.document.documentElement[ "client" + name ];
        }

        // Get document width or height
        if ( elem.nodeType === 9 ) {
          doc = elem.documentElement;

          // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
          // whichever is greatest
          return Math.max(
            elem.body[ "scroll" + name ], doc[ "scroll" + name ],
            elem.body[ "offset" + name ], doc[ "offset" + name ],
            doc[ "client" + name ]
          );
        }

        return value === undefined ?

          // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css( elem, type, extra ) :

          // Set width or height on the element
          jQuery.style( elem, type, value, extra );
      }, type, chainable ? margin : undefined, chainable );
    };
  } );
} );


jQuery.each( [
  "ajaxStart",
  "ajaxStop",
  "ajaxComplete",
  "ajaxError",
  "ajaxSuccess",
  "ajaxSend"
], function( _i, type ) {
  jQuery.fn[ type ] = function( fn ) {
    return this.on( type, fn );
  };
} );




jQuery.fn.extend( {

  bind: function( types, data, fn ) {
    return this.on( types, null, data, fn );
  },
  unbind: function( types, fn ) {
    return this.off( types, null, fn );
  },

  delegate: function( selector, types, data, fn ) {
    return this.on( types, selector, data, fn );
  },
  undelegate: function( selector, types, fn ) {

    // ( namespace ) or ( selector, types [, fn] )
    return arguments.length === 1 ?
      this.off( selector, "**" ) :
      this.off( types, selector || "**", fn );
  },

  hover: function( fnOver, fnOut ) {
    return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
  }
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
  "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
  "change select submit keydown keypress keyup contextmenu" ).split( " " ),
  function( _i, name ) {

    // Handle event binding
    jQuery.fn[ name ] = function( data, fn ) {
      return arguments.length > 0 ?
        this.on( name, null, data, fn ) :
        this.trigger( name );
    };
  } );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
  var tmp, args, proxy;

  if ( typeof context === "string" ) {
    tmp = fn[ context ];
    context = fn;
    fn = tmp;
  }

  // Quick check to determine if target is callable, in the spec
  // this throws a TypeError, but we will just return undefined.
  if ( !isFunction( fn ) ) {
    return undefined;
  }

  // Simulated bind
  args = slice.call( arguments, 2 );
  proxy = function() {
    return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
  };

  // Set the guid of unique handler to the same of original handler, so it can be removed
  proxy.guid = fn.guid = fn.guid || jQuery.guid++;

  return proxy;
};

jQuery.holdReady = function( hold ) {
  if ( hold ) {
    jQuery.readyWait++;
  } else {
    jQuery.ready( true );
  }
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

  // As of jQuery 3.0, isNumeric is limited to
  // strings and numbers (primitives or objects)
  // that can be coerced to finite numbers (gh-2662)
  var type = jQuery.type( obj );
  return ( type === "number" || type === "string" ) &&

    // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
  return text == null ?
    "" :
    ( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
  define( "jquery", [], function() {
    return jQuery;
  } );
}




var

  // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,

  // Map over the $ in case of overwrite
  _$ = window.$;

jQuery.noConflict = function( deep ) {
  if ( window.$ === jQuery ) {
    window.$ = _$;
  }

  if ( deep && window.jQuery === jQuery ) {
    window.jQuery = _jQuery;
  }

  return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
  window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

/*!
 * OOUI v0.40.0
 * https://www.mediawiki.org/wiki/OOUI
 *
 * Copyright 2011–2020 OOUI Team and other contributors.
 * Released under the MIT license
 * http://oojs.mit-license.org
 *
 * Date: 2020-08-03T17:53:06Z
 */
( function ( OO ) {

'use strict';

/**
 * Namespace for all classes, static methods and static properties.
 *
 * @class
 * @singleton
 */
OO.ui = {};

OO.ui.bind = $.proxy;

/**
 * @property {Object}
 */
OO.ui.Keys = {
  UNDEFINED: 0,
  BACKSPACE: 8,
  DELETE: 46,
  LEFT: 37,
  RIGHT: 39,
  UP: 38,
  DOWN: 40,
  ENTER: 13,
  END: 35,
  HOME: 36,
  TAB: 9,
  PAGEUP: 33,
  PAGEDOWN: 34,
  ESCAPE: 27,
  SHIFT: 16,
  SPACE: 32
};

/**
 * Constants for MouseEvent.which
 *
 * @property {Object}
 */
OO.ui.MouseButtons = {
  LEFT: 1,
  MIDDLE: 2,
  RIGHT: 3
};

/**
 * @property {number}
 * @private
 */
OO.ui.elementId = 0;

/**
 * Generate a unique ID for element
 *
 * @return {string} ID
 */
OO.ui.generateElementId = function () {
  OO.ui.elementId++;
  return 'ooui-' + OO.ui.elementId;
};

/**
 * Check if an element is focusable.
 * Inspired by :focusable in jQueryUI v1.11.4 - 2015-04-14
 *
 * @param {jQuery} $element Element to test
 * @return {boolean} Element is focusable
 */
OO.ui.isFocusableElement = function ( $element ) {
  var nodeName,
    element = $element[ 0 ];

  // Anything disabled is not focusable
  if ( element.disabled ) {
    return false;
  }

  // Check if the element is visible
  if ( !(
    // This is quicker than calling $element.is( ':visible' )
    $.expr.pseudos.visible( element ) &&
    // Check that all parents are visible
    !$element.parents().addBack().filter( function () {
      return $.css( this, 'visibility' ) === 'hidden';
    } ).length
  ) ) {
    return false;
  }

  // Check if the element is ContentEditable, which is the string 'true'
  if ( element.contentEditable === 'true' ) {
    return true;
  }

  // Anything with a non-negative numeric tabIndex is focusable.
  // Use .prop to avoid browser bugs
  if ( $element.prop( 'tabIndex' ) >= 0 ) {
    return true;
  }

  // Some element types are naturally focusable
  // (indexOf is much faster than regex in Chrome and about the
  // same in FF: https://jsperf.com/regex-vs-indexof-array2)
  nodeName = element.nodeName.toLowerCase();
  if ( [ 'input', 'select', 'textarea', 'button', 'object' ].indexOf( nodeName ) !== -1 ) {
    return true;
  }

  // Links and areas are focusable if they have an href
  if ( ( nodeName === 'a' || nodeName === 'area' ) && $element.attr( 'href' ) !== undefined ) {
    return true;
  }

  return false;
};

/**
 * Find a focusable child.
 *
 * @param {jQuery} $container Container to search in
 * @param {boolean} [backwards] Search backwards
 * @return {jQuery} Focusable child, or an empty jQuery object if none found
 */
OO.ui.findFocusable = function ( $container, backwards ) {
  var $focusable = $( [] ),
    // $focusableCandidates is a superset of things that
    // could get matched by isFocusableElement
    $focusableCandidates = $container
      .find( 'input, select, textarea, button, object, a, area, [contenteditable], [tabindex]' );

  if ( backwards ) {
    $focusableCandidates = Array.prototype.reverse.call( $focusableCandidates );
  }

  $focusableCandidates.each( function () {
    var $this = $( this );
    if ( OO.ui.isFocusableElement( $this ) ) {
      $focusable = $this;
      return false;
    }
  } );
  return $focusable;
};

/**
 * Get the user's language and any fallback languages.
 *
 * These language codes are used to localize user interface elements in the user's language.
 *
 * In environments that provide a localization system, this function should be overridden to
 * return the user's language(s). The default implementation returns English (en) only.
 *
 * @return {string[]} Language codes, in descending order of priority
 */
OO.ui.getUserLanguages = function () {
  return [ 'en' ];
};

/**
 * Get a value in an object keyed by language code.
 *
 * @param {Object.<string,Mixed>} obj Object keyed by language code
 * @param {string|null} [lang] Language code, if omitted or null defaults to any user language
 * @param {string} [fallback] Fallback code, used if no matching language can be found
 * @return {Mixed} Local value
 */
OO.ui.getLocalValue = function ( obj, lang, fallback ) {
  var i, len, langs;

  // Requested language
  if ( obj[ lang ] ) {
    return obj[ lang ];
  }
  // Known user language
  langs = OO.ui.getUserLanguages();
  for ( i = 0, len = langs.length; i < len; i++ ) {
    lang = langs[ i ];
    if ( obj[ lang ] ) {
      return obj[ lang ];
    }
  }
  // Fallback language
  if ( obj[ fallback ] ) {
    return obj[ fallback ];
  }
  // First existing language
  for ( lang in obj ) {
    return obj[ lang ];
  }

  return undefined;
};

/**
 * Check if a node is contained within another node.
 *
 * Similar to jQuery#contains except a list of containers can be supplied
 * and a boolean argument allows you to include the container in the match list
 *
 * @param {HTMLElement|HTMLElement[]} containers Container node(s) to search in
 * @param {HTMLElement} contained Node to find
 * @param {boolean} [matchContainers] Include the container(s) in the list of nodes to match,
 *  otherwise only match descendants
 * @return {boolean} The node is in the list of target nodes
 */
OO.ui.contains = function ( containers, contained, matchContainers ) {
  var i;
  if ( !Array.isArray( containers ) ) {
    containers = [ containers ];
  }
  for ( i = containers.length - 1; i >= 0; i-- ) {
    if (
      ( matchContainers && contained === containers[ i ] ) ||
      $.contains( containers[ i ], contained )
    ) {
      return true;
    }
  }
  return false;
};

/**
 * Return a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing.
 *
 * Ported from: http://underscorejs.org/underscore.js
 *
 * @param {Function} func Function to debounce
 * @param {number} [wait=0] Wait period in milliseconds
 * @param {boolean} [immediate] Trigger on leading edge
 * @return {Function} Debounced function
 */
OO.ui.debounce = function ( func, wait, immediate ) {
  var timeout;
  return function () {
    var context = this,
      args = arguments,
      later = function () {
        timeout = null;
        if ( !immediate ) {
          func.apply( context, args );
        }
      };
    if ( immediate && !timeout ) {
      func.apply( context, args );
    }
    if ( !timeout || wait ) {
      clearTimeout( timeout );
      timeout = setTimeout( later, wait );
    }
  };
};

/**
 * Puts a console warning with provided message.
 *
 * @param {string} message Message
 */
OO.ui.warnDeprecation = function ( message ) {
  if ( OO.getProp( window, 'console', 'warn' ) !== undefined ) {
    // eslint-disable-next-line no-console
    console.warn( message );
  }
};

/**
 * Returns a function, that, when invoked, will only be triggered at most once
 * during a given window of time. If called again during that window, it will
 * wait until the window ends and then trigger itself again.
 *
 * As it's not knowable to the caller whether the function will actually run
 * when the wrapper is called, return values from the function are entirely
 * discarded.
 *
 * @param {Function} func Function to throttle
 * @param {number} wait Throttle window length, in milliseconds
 * @return {Function} Throttled function
 */
OO.ui.throttle = function ( func, wait ) {
  var context, args, timeout,
    previous = Date.now() - wait,
    run = function () {
      timeout = null;
      previous = Date.now();
      func.apply( context, args );
    };
  return function () {
    // Check how long it's been since the last time the function was
    // called, and whether it's more or less than the requested throttle
    // period. If it's less, run the function immediately. If it's more,
    // set a timeout for the remaining time -- but don't replace an
    // existing timeout, since that'd indefinitely prolong the wait.
    var remaining = Math.max( wait - ( Date.now() - previous ), 0 );
    context = this;
    args = arguments;
    if ( !timeout ) {
      // If time is up, do setTimeout( run, 0 ) so the function
      // always runs asynchronously, just like Promise#then .
      timeout = setTimeout( run, remaining );
    }
  };
};

/**
 * Reconstitute a JavaScript object corresponding to a widget created by
 * the PHP implementation.
 *
 * This is an alias for `OO.ui.Element.static.infuse()`.
 *
 * @param {string|HTMLElement|jQuery} idOrNode
 *   A DOM id (if a string) or node for the widget to infuse.
 * @param {Object} [config] Configuration options
 * @return {OO.ui.Element}
 *   The `OO.ui.Element` corresponding to this (infusable) document node.
 */
OO.ui.infuse = function ( idOrNode, config ) {
  return OO.ui.Element.static.infuse( idOrNode, config );
};

/**
 * Get a localized message.
 *
 * After the message key, message parameters may optionally be passed. In the default
 * implementation, any occurrences of $1 are replaced with the first parameter, $2 with the
 * second parameter, etc.
 * Alternative implementations of OO.ui.msg may use any substitution system they like, as long
 * as they support unnamed, ordered message parameters.
 *
 * In environments that provide a localization system, this function should be overridden to
 * return the message translated in the user's language. The default implementation always
 * returns English messages. An example of doing this with
 * [jQuery.i18n](https://github.com/wikimedia/jquery.i18n) follows.
 *
 *     @example
 *     var i, iLen, button,
 *         messagePath = 'oojs-ui/dist/i18n/',
 *         languages = [ $.i18n().locale, 'ur', 'en' ],
 *         languageMap = {};
 *
 *     for ( i = 0, iLen = languages.length; i < iLen; i++ ) {
 *         languageMap[ languages[ i ] ] = messagePath + languages[ i ].toLowerCase() + '.json';
 *     }
 *
 *     $.i18n().load( languageMap ).done( function() {
 *         // Replace the built-in `msg` only once we've loaded the internationalization.
 *         // OOUI uses `OO.ui.deferMsg` for all initially-loaded messages. So long as
 *         // you put off creating any widgets until this promise is complete, no English
 *         // will be displayed.
 *         OO.ui.msg = $.i18n;
 *
 *         // A button displaying "OK" in the default locale
 *         button = new OO.ui.ButtonWidget( {
 *             label: OO.ui.msg( 'ooui-dialog-message-accept' ),
 *             icon: 'check'
 *         } );
 *         $( document.body ).append( button.$element );
 *
 *         // A button displaying "OK" in Urdu
 *         $.i18n().locale = 'ur';
 *         button = new OO.ui.ButtonWidget( {
 *             label: OO.ui.msg( 'ooui-dialog-message-accept' ),
 *             icon: 'check'
 *         } );
 *         $( document.body ).append( button.$element );
 *     } );
 *
 * @param {string} key Message key
 * @param {...Mixed} [params] Message parameters
 * @return {string} Translated message with parameters substituted
 */
OO.ui.msg = function ( key ) {
  // `OO.ui.msg.messages` is defined in code generated during the build process
  var messages = OO.ui.msg.messages,
    message = messages[ key ],
    params = Array.prototype.slice.call( arguments, 1 );
  if ( typeof message === 'string' ) {
    // Perform $1 substitution
    message = message.replace( /\$(\d+)/g, function ( unused, n ) {
      var i = parseInt( n, 10 );
      return params[ i - 1 ] !== undefined ? params[ i - 1 ] : '$' + n;
    } );
  } else {
    // Return placeholder if message not found
    message = '[' + key + ']';
  }
  return message;
};

/**
 * Package a message and arguments for deferred resolution.
 *
 * Use this when you are statically specifying a message and the message may not yet be present.
 *
 * @param {string} key Message key
 * @param {...Mixed} [params] Message parameters
 * @return {Function} Function that returns the resolved message when executed
 */
OO.ui.deferMsg = function () {
  var args = arguments;
  return function () {
    return OO.ui.msg.apply( OO.ui, args );
  };
};

/**
 * Resolve a message.
 *
 * If the message is a function it will be executed, otherwise it will pass through directly.
 *
 * @param {Function|string} msg Deferred message, or message text
 * @return {string} Resolved message
 */
OO.ui.resolveMsg = function ( msg ) {
  if ( typeof msg === 'function' ) {
    return msg();
  }
  return msg;
};

/**
 * @param {string} url
 * @return {boolean}
 */
OO.ui.isSafeUrl = function ( url ) {
  // Keep this function in sync with php/Tag.php
  var i, protocolWhitelist;

  function stringStartsWith( haystack, needle ) {
    return haystack.substr( 0, needle.length ) === needle;
  }

  protocolWhitelist = [
    'bitcoin', 'ftp', 'ftps', 'geo', 'git', 'gopher', 'http', 'https', 'irc', 'ircs',
    'magnet', 'mailto', 'mms', 'news', 'nntp', 'redis', 'sftp', 'sip', 'sips', 'sms', 'ssh',
    'svn', 'tel', 'telnet', 'urn', 'worldwind', 'xmpp'
  ];

  if ( url === '' ) {
    return true;
  }

  for ( i = 0; i < protocolWhitelist.length; i++ ) {
    if ( stringStartsWith( url, protocolWhitelist[ i ] + ':' ) ) {
      return true;
    }
  }

  // This matches '//' too
  if ( stringStartsWith( url, '/' ) || stringStartsWith( url, './' ) ) {
    return true;
  }
  if ( stringStartsWith( url, '?' ) || stringStartsWith( url, '#' ) ) {
    return true;
  }

  return false;
};

/**
 * Check if the user has a 'mobile' device.
 *
 * For our purposes this means the user is primarily using an
 * on-screen keyboard, touch input instead of a mouse and may
 * have a physically small display.
 *
 * It is left up to implementors to decide how to compute this
 * so the default implementation always returns false.
 *
 * @return {boolean} User is on a mobile device
 */
OO.ui.isMobile = function () {
  return false;
};

/**
 * Get the additional spacing that should be taken into account when displaying elements that are
 * clipped to the viewport, e.g. dropdown menus and popups. This is meant to be overridden to avoid
 * such menus overlapping any fixed headers/toolbars/navigation used by the site.
 *
 * @return {Object} Object with the properties 'top', 'right', 'bottom', 'left', each representing
 *  the extra spacing from that edge of viewport (in pixels)
 */
OO.ui.getViewportSpacing = function () {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
};

/**
 * Get the default overlay, which is used by various widgets when they are passed `$overlay: true`.
 * See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 *
 * @return {jQuery} Default overlay node
 */
OO.ui.getDefaultOverlay = function () {
  if ( !OO.ui.$defaultOverlay ) {
    OO.ui.$defaultOverlay = $( '<div>' ).addClass( 'oo-ui-defaultOverlay' );
    $( document.body ).append( OO.ui.$defaultOverlay );
  }
  return OO.ui.$defaultOverlay;
};

/**
 * Message store for the default implementation of OO.ui.msg.
 *
 * Environments that provide a localization system should not use this, but should override
 * OO.ui.msg altogether.
 *
 * @private
 */
OO.ui.msg.messages = {
  "ooui-outline-control-move-down": "Move item down",
  "ooui-outline-control-move-up": "Move item up",
  "ooui-outline-control-remove": "Remove item",
  "ooui-toolbar-more": "More",
  "ooui-toolgroup-expand": "More",
  "ooui-toolgroup-collapse": "Fewer",
  "ooui-item-remove": "Remove",
  "ooui-dialog-message-accept": "OK",
  "ooui-dialog-message-reject": "Cancel",
  "ooui-dialog-process-error": "Something went wrong",
  "ooui-dialog-process-dismiss": "Dismiss",
  "ooui-dialog-process-retry": "Try again",
  "ooui-dialog-process-continue": "Continue",
  "ooui-combobox-button-label": "Toggle options",
  "ooui-selectfile-button-select": "Select a file",
  "ooui-selectfile-not-supported": "File selection is not supported",
  "ooui-selectfile-placeholder": "No file is selected",
  "ooui-selectfile-dragdrop-placeholder": "Drop file here",
  "ooui-popup-widget-close-button-aria-label": "Close",
  "ooui-field-help": "Help"
};

/*!
 * Mixin namespace.
 */

/**
 * Namespace for OOUI mixins.
 *
 * Mixins are named according to the type of object they are intended to
 * be mixed in to.  For example, OO.ui.mixin.GroupElement is intended to be
 * mixed in to an instance of OO.ui.Element, and OO.ui.mixin.GroupWidget
 * is intended to be mixed in to an instance of OO.ui.Widget.
 *
 * @class
 * @singleton
 */
OO.ui.mixin = {};

// getDocument( element ) is preferrable to window.document
/* global document:off */

/**
 * Each Element represents a rendering in the DOM—a button or an icon, for example, or anything
 * that is visible to a user. Unlike {@link OO.ui.Widget widgets}, plain elements usually do not
 * have events connected to them and can't be interacted with.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string[]} [classes] The names of the CSS classes to apply to the element. CSS styles are
 *  added to the top level (e.g., the outermost div) of the element. See the
 *  [OOUI documentation on MediaWiki][2] for an example.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Buttons_and_Switches#cssExample
 * @cfg {string} [id] The HTML id attribute used in the rendered tag.
 * @cfg {string} [text] Text to insert
 * @cfg {Array} [content] An array of content elements to append (after #text).
 *  Strings will be html-escaped; use an OO.ui.HtmlSnippet to append raw HTML.
 *  Instances of OO.ui.Element will have their $element appended.
 * @cfg {jQuery} [$content] Content elements to append (after #text).
 * @cfg {jQuery} [$element] Wrapper element. Defaults to a new element with #getTagName.
 * @cfg {Mixed} [data] Custom data of any type or combination of types (e.g., string, number,
 *  array, object).
 *  Data can also be specified with the #setData method.
 */
OO.ui.Element = function OoUiElement( config ) {
  var doc;

  if ( OO.ui.isDemo ) {
    this.initialConfig = config;
  }
  // Configuration initialization
  config = config || {};

  // Properties
  this.elementId = null;
  this.visible = true;
  this.data = config.data;
  this.$element = config.$element ||
    $( window.document.createElement( this.getTagName() ) );
  this.elementGroup = null;

  // Initialization
  doc = OO.ui.Element.static.getDocument( this.$element );
  if ( Array.isArray( config.classes ) ) {
    this.$element.addClass( config.classes );
  }
  if ( config.id ) {
    this.setElementId( config.id );
  }
  if ( config.text ) {
    this.$element.text( config.text );
  }
  if ( config.content ) {
    // The `content` property treats plain strings as text; use an
    // HtmlSnippet to append HTML content.  `OO.ui.Element`s get their
    // appropriate $element appended.
    this.$element.append( config.content.map( function ( v ) {
      if ( typeof v === 'string' ) {
        // Escape string so it is properly represented in HTML.
        // Don't create empty text nodes for empty strings.
        return v ? doc.createTextNode( v ) : undefined;
      } else if ( v instanceof OO.ui.HtmlSnippet ) {
        // Bypass escaping.
        return v.toString();
      } else if ( v instanceof OO.ui.Element ) {
        return v.$element;
      }
      return v;
    } ) );
  }
  if ( config.$content ) {
    // The `$content` property treats plain strings as HTML.
    this.$element.append( config.$content );
  }
};

/* Setup */

OO.initClass( OO.ui.Element );

/* Static Properties */

/**
 * The name of the HTML tag used by the element.
 *
 * The static value may be ignored if the #getTagName method is overridden.
 *
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.Element.static.tagName = 'div';

/* Static Methods */

/**
 * Reconstitute a JavaScript object corresponding to a widget created
 * by the PHP implementation.
 *
 * @param {HTMLElement|jQuery} node
 *   A node for the widget to infuse.
 * @param {Object} [config] Configuration options
 * @return {OO.ui.Element}
 *   The `OO.ui.Element` corresponding to this (infusable) document node.
 *   For `Tag` objects emitted on the HTML side (used occasionally for content)
 *   the value returned is a newly-created Element wrapping around the existing
 *   DOM node.
 */
OO.ui.Element.static.infuse = function ( node, config ) {
  var obj = OO.ui.Element.static.unsafeInfuse( node, config, false );

  // Verify that the type matches up.
  // FIXME: uncomment after T89721 is fixed, see T90929.
  /*
  if ( !( obj instanceof this['class'] ) ) {
    throw new Error( 'Infusion type mismatch!' );
  }
  */
  return obj;
};

/**
 * Implementation helper for `infuse`; skips the type check and has an
 * extra property so that only the top-level invocation touches the DOM.
 *
 * @private
 * @param {HTMLElement|jQuery} elem
 * @param {Object} [config] Configuration options
 * @param {jQuery.Promise} [domPromise] A promise that will be resolved
 *     when the top-level widget of this infusion is inserted into DOM,
 *     replacing the original element; only used internally.
 * @return {OO.ui.Element}
 */
OO.ui.Element.static.unsafeInfuse = function ( elem, config, domPromise ) {
  // look for a cached result of a previous infusion.
  var error, data, cls, parts, obj, top, state, infusedChildren, doc,
    $elem = $( elem ),
    id = $elem.attr( 'id' );

  if ( !$elem.length ) {
    if ( elem && elem.selector ) {
      error = 'Widget not found: ' + elem.selector;
    } else {
      error = 'Widget not found';
    }
    throw new Error( error );
  }
  if ( $elem[ 0 ].$oouiInfused ) {
    $elem = $elem[ 0 ].$oouiInfused;
  }
  doc = this.getDocument( $elem );
  data = $elem.data( 'ooui-infused' );
  if ( data ) {
    // cached!
    if ( data === true ) {
      throw new Error( 'Circular dependency! ' + id );
    }
    if ( domPromise ) {
      // Pick up dynamic state, like focus, value of form inputs, scroll position, etc.
      state = data.constructor.static.gatherPreInfuseState( $elem, data );
      // Restore dynamic state after the new element is re-inserted into DOM under
      // infused parent.
      domPromise.done( data.restorePreInfuseState.bind( data, state ) );
      infusedChildren = $elem.data( 'ooui-infused-children' );
      if ( infusedChildren && infusedChildren.length ) {
        infusedChildren.forEach( function ( data ) {
          var state = data.constructor.static.gatherPreInfuseState( $elem, data );
          domPromise.done( data.restorePreInfuseState.bind( data, state ) );
        } );
      }
    }
    return data;
  }
  data = $elem.attr( 'data-ooui' );
  if ( !data ) {
    throw new Error( 'No infusion data found: ' + id );
  }
  try {
    data = JSON.parse( data );
  } catch ( _ ) {
    data = null;
  }
  if ( !( data && data._ ) ) {
    throw new Error( 'No valid infusion data found: ' + id );
  }
  if ( data._ === 'Tag' ) {
    // Special case: this is a raw Tag; wrap existing node, don't rebuild.
    return new OO.ui.Element( $.extend( {}, config, { $element: $elem } ) );
  }
  parts = data._.split( '.' );
  cls = OO.getProp.apply( OO, [ window ].concat( parts ) );

  if ( !( cls && ( cls === OO.ui.Element || cls.prototype instanceof OO.ui.Element ) ) ) {
    throw new Error( 'Unknown widget type: id: ' + id + ', class: ' + data._ );
  }

  if ( !domPromise ) {
    top = $.Deferred();
    domPromise = top.promise();
  }
  $elem.data( 'ooui-infused', true ); // prevent loops
  data.id = id; // implicit
  infusedChildren = [];
  data = OO.copy( data, null, function deserialize( value ) {
    var infused;
    if ( OO.isPlainObject( value ) ) {
      if ( value.tag && doc.getElementById( value.tag ) ) {
        infused = OO.ui.Element.static.unsafeInfuse(
          doc.getElementById( value.tag ), config, domPromise
        );
        infusedChildren.push( infused );
        // Flatten the structure
        infusedChildren.push.apply(
          infusedChildren,
          infused.$element.data( 'ooui-infused-children' ) || []
        );
        infused.$element.removeData( 'ooui-infused-children' );
        return infused;
      }
      if ( value.html !== undefined ) {
        return new OO.ui.HtmlSnippet( value.html );
      }
    }
  } );
  // allow widgets to reuse parts of the DOM
  data = cls.static.reusePreInfuseDOM( $elem[ 0 ], data );
  // pick up dynamic state, like focus, value of form inputs, scroll position, etc.
  state = cls.static.gatherPreInfuseState( $elem[ 0 ], data );
  // rebuild widget
  // eslint-disable-next-line new-cap
  obj = new cls( $.extend( {}, config, data ) );
  // If anyone is holding a reference to the old DOM element,
  // let's allow them to OO.ui.infuse() it and do what they expect, see T105828.
  // Do not use jQuery.data(), as using it on detached nodes leaks memory in 1.x line by design.
  $elem[ 0 ].$oouiInfused = obj.$element;
  // now replace old DOM with this new DOM.
  if ( top ) {
    // An efficient constructor might be able to reuse the entire DOM tree of the original
    // element, so only mutate the DOM if we need to.
    if ( $elem[ 0 ] !== obj.$element[ 0 ] ) {
      $elem.replaceWith( obj.$element );
    }
    top.resolve();
  }
  obj.$element.data( 'ooui-infused', obj );
  obj.$element.data( 'ooui-infused-children', infusedChildren );
  // set the 'data-ooui' attribute so we can identify infused widgets
  obj.$element.attr( 'data-ooui', '' );
  // restore dynamic state after the new element is inserted into DOM
  domPromise.done( obj.restorePreInfuseState.bind( obj, state ) );
  return obj;
};

/**
 * Pick out parts of `node`'s DOM to be reused when infusing a widget.
 *
 * This method **must not** make any changes to the DOM, only find interesting pieces and add them
 * to `config` (which should then be returned). Actual DOM juggling should then be done by the
 * constructor, which will be given the enhanced config.
 *
 * @protected
 * @param {HTMLElement} node
 * @param {Object} config
 * @return {Object}
 */
OO.ui.Element.static.reusePreInfuseDOM = function ( node, config ) {
  return config;
};

/**
 * Gather the dynamic state (focus, value of form inputs, scroll position, etc.) of an HTML DOM
 * node (and its children) that represent an Element of the same class and the given configuration,
 * generated by the PHP implementation.
 *
 * This method is called just before `node` is detached from the DOM. The return value of this
 * function will be passed to #restorePreInfuseState after the newly created widget's #$element
 * is inserted into DOM to replace `node`.
 *
 * @protected
 * @param {HTMLElement} node
 * @param {Object} config
 * @return {Object}
 */
OO.ui.Element.static.gatherPreInfuseState = function () {
  return {};
};

/**
 * Get the document of an element.
 *
 * @static
 * @param {jQuery|HTMLElement|HTMLDocument|Window} obj Object to get the document for
 * @return {HTMLDocument|null} Document object
 */
OO.ui.Element.static.getDocument = function ( obj ) {
  // HTMLElement
  return obj.ownerDocument ||
    // Window
    obj.document ||
    // HTMLDocument
    ( obj.nodeType === Node.DOCUMENT_NODE && obj ) ||
    // jQuery - selections created "offscreen" won't have a context, so .context isn't reliable
    ( obj[ 0 ] && obj[ 0 ].ownerDocument ) ||
    // Empty jQuery selections might have a context
    obj.context ||
    null;
};

/**
 * Get the window of an element or document.
 *
 * @static
 * @param {jQuery|HTMLElement|HTMLDocument|Window} obj Context to get the window for
 * @return {Window} Window object
 */
OO.ui.Element.static.getWindow = function ( obj ) {
  var doc = this.getDocument( obj );
  return doc.defaultView;
};

/**
 * Get the direction of an element or document.
 *
 * @static
 * @param {jQuery|HTMLElement|HTMLDocument|Window} obj Context to get the direction for
 * @return {string} Text direction, either 'ltr' or 'rtl'
 */
OO.ui.Element.static.getDir = function ( obj ) {
  var isDoc, isWin;

  if ( obj instanceof $ ) {
    obj = obj[ 0 ];
  }
  isDoc = obj.nodeType === Node.DOCUMENT_NODE;
  isWin = obj.document !== undefined;
  if ( isDoc || isWin ) {
    if ( isWin ) {
      obj = obj.document;
    }
    obj = obj.body;
  }
  return $( obj ).css( 'direction' );
};

/**
 * Get the offset between two frames.
 *
 * TODO: Make this function not use recursion.
 *
 * @static
 * @param {Window} from Window of the child frame
 * @param {Window} [to=window] Window of the parent frame
 * @param {Object} [offset] Offset to start with, used internally
 * @return {Object} Offset object, containing left and top properties
 */
OO.ui.Element.static.getFrameOffset = function ( from, to, offset ) {
  var i, len, frames, frame, rect;

  if ( !to ) {
    to = window;
  }
  if ( !offset ) {
    offset = { top: 0, left: 0 };
  }
  if ( from.parent === from ) {
    return offset;
  }

  // Get iframe element
  frames = from.parent.document.getElementsByTagName( 'iframe' );
  for ( i = 0, len = frames.length; i < len; i++ ) {
    if ( frames[ i ].contentWindow === from ) {
      frame = frames[ i ];
      break;
    }
  }

  // Recursively accumulate offset values
  if ( frame ) {
    rect = frame.getBoundingClientRect();
    offset.left += rect.left;
    offset.top += rect.top;
    if ( from !== to ) {
      this.getFrameOffset( from.parent, offset );
    }
  }
  return offset;
};

/**
 * Get the offset between two elements.
 *
 * The two elements may be in a different frame, but in that case the frame $element is in must
 * be contained in the frame $anchor is in.
 *
 * @static
 * @param {jQuery} $element Element whose position to get
 * @param {jQuery} $anchor Element to get $element's position relative to
 * @return {Object} Translated position coordinates, containing top and left properties
 */
OO.ui.Element.static.getRelativePosition = function ( $element, $anchor ) {
  var iframe, iframePos,
    pos = $element.offset(),
    anchorPos = $anchor.offset(),
    elementDocument = this.getDocument( $element ),
    anchorDocument = this.getDocument( $anchor );

  // If $element isn't in the same document as $anchor, traverse up
  while ( elementDocument !== anchorDocument ) {
    iframe = elementDocument.defaultView.frameElement;
    if ( !iframe ) {
      throw new Error( '$element frame is not contained in $anchor frame' );
    }
    iframePos = $( iframe ).offset();
    pos.left += iframePos.left;
    pos.top += iframePos.top;
    elementDocument = this.getDocument( iframe );
  }
  pos.left -= anchorPos.left;
  pos.top -= anchorPos.top;
  return pos;
};

/**
 * Get element border sizes.
 *
 * @static
 * @param {HTMLElement} el Element to measure
 * @return {Object} Dimensions object with `top`, `left`, `bottom` and `right` properties
 */
OO.ui.Element.static.getBorders = function ( el ) {
  var doc = this.getDocument( el ),
    win = doc.defaultView,
    style = win.getComputedStyle( el, null ),
    $el = $( el ),
    top = parseFloat( style ? style.borderTopWidth : $el.css( 'borderTopWidth' ) ) || 0,
    left = parseFloat( style ? style.borderLeftWidth : $el.css( 'borderLeftWidth' ) ) || 0,
    bottom = parseFloat( style ? style.borderBottomWidth : $el.css( 'borderBottomWidth' ) ) || 0,
    right = parseFloat( style ? style.borderRightWidth : $el.css( 'borderRightWidth' ) ) || 0;

  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right
  };
};

/**
 * Get dimensions of an element or window.
 *
 * @static
 * @param {HTMLElement|Window} el Element to measure
 * @return {Object} Dimensions object with `borders`, `scroll`, `scrollbar` and `rect` properties
 */
OO.ui.Element.static.getDimensions = function ( el ) {
  var $el, $win,
    doc = this.getDocument( el ),
    win = doc.defaultView;

  if ( win === el || el === doc.documentElement ) {
    $win = $( win );
    return {
      borders: { top: 0, left: 0, bottom: 0, right: 0 },
      scroll: {
        top: $win.scrollTop(),
        left: OO.ui.Element.static.getScrollLeft( win )
      },
      scrollbar: { right: 0, bottom: 0 },
      rect: {
        top: 0,
        left: 0,
        bottom: $win.innerHeight(),
        right: $win.innerWidth()
      }
    };
  } else {
    $el = $( el );
    return {
      borders: this.getBorders( el ),
      scroll: {
        top: $el.scrollTop(),
        left: OO.ui.Element.static.getScrollLeft( el )
      },
      scrollbar: {
        right: $el.innerWidth() - el.clientWidth,
        bottom: $el.innerHeight() - el.clientHeight
      },
      rect: el.getBoundingClientRect()
    };
  }
};

( function () {
  var rtlScrollType = null;

  // Adapted from <https://github.com/othree/jquery.rtl-scroll-type>.
  // Original code copyright 2012 Wei-Ko Kao, licensed under the MIT License.
  function rtlScrollTypeTest() {
    var $definer = $( '<div>' ).attr( {
        dir: 'rtl',
        style: 'font-size: 14px; width: 4px; height: 1px; position: absolute; top: -1000px; overflow: scroll;'
      } ).text( 'ABCD' ),
      definer = $definer[ 0 ];

    $definer.appendTo( 'body' );
    if ( definer.scrollLeft > 0 ) {
      // Safari, Chrome
      rtlScrollType = 'default';
    } else {
      definer.scrollLeft = 1;
      if ( definer.scrollLeft === 0 ) {
        // Firefox, old Opera
        rtlScrollType = 'negative';
      } else {
        // Internet Explorer, Edge
        rtlScrollType = 'reverse';
      }
    }
    $definer.remove();
  }

  function isRoot( el ) {
    return el === el.window ||
      el === el.ownerDocument.body ||
      el === el.ownerDocument.documentElement;
  }

  /**
   * Convert native `scrollLeft` value to a value consistent between browsers. See #getScrollLeft.
   *
   * @param {number} nativeOffset Native `scrollLeft` value
   * @param {HTMLElement|Window} el Element from which the value was obtained
   * @return {number}
   */
  OO.ui.Element.static.computeNormalizedScrollLeft = function ( nativeOffset, el ) {
    // All browsers use the correct scroll type ('negative') on the root, so don't
    // do any fixups when looking at the root element
    var direction = isRoot( el ) ? 'ltr' : $( el ).css( 'direction' );

    if ( direction === 'rtl' ) {
      if ( rtlScrollType === null ) {
        rtlScrollTypeTest();
      }
      if ( rtlScrollType === 'reverse' ) {
        return -nativeOffset;
      } else if ( rtlScrollType === 'default' ) {
        return nativeOffset - el.scrollWidth + el.clientWidth;
      }
    }

    return nativeOffset;
  };

  /**
   * Convert our normalized `scrollLeft` value to a value for current browser. See #getScrollLeft.
   *
   * @param {number} normalizedOffset Normalized `scrollLeft` value
   * @param {HTMLElement|Window} el Element on which the value will be set
   * @return {number}
   */
  OO.ui.Element.static.computeNativeScrollLeft = function ( normalizedOffset, el ) {
    // All browsers use the correct scroll type ('negative') on the root, so don't
    // do any fixups when looking at the root element
    var direction = isRoot( el ) ? 'ltr' : $( el ).css( 'direction' );

    if ( direction === 'rtl' ) {
      if ( rtlScrollType === null ) {
        rtlScrollTypeTest();
      }
      if ( rtlScrollType === 'reverse' ) {
        return -normalizedOffset;
      } else if ( rtlScrollType === 'default' ) {
        return normalizedOffset + el.scrollWidth - el.clientWidth;
      }
    }

    return normalizedOffset;
  };

  /**
   * Get the number of pixels that an element's content is scrolled to the left.
   *
   * This function smooths out browser inconsistencies (nicely described in the README at
   * <https://github.com/othree/jquery.rtl-scroll-type>) and produces a result consistent
   * with Firefox's 'scrollLeft', which seems the sanest.
   *
   * (Firefox's scrollLeft handling is nice because it increases from left to right, consistently
   * with `getBoundingClientRect().left` and related APIs; because initial value is zero, so
   * resetting it is easy; because adapting a hardcoded scroll position to a symmetrical RTL
   * interface requires just negating it, rather than involving `clientWidth` and `scrollWidth`;
   * and because if you mess up and don't adapt your code to RTL, it will scroll to the beginning
   * rather than somewhere randomly in the middle but not where you wanted.)
   *
   * @static
   * @method
   * @param {HTMLElement|Window} el Element to measure
   * @return {number} Scroll position from the left.
   *  If the element's direction is LTR, this is a positive number between `0` (initial scroll
   *  position) and `el.scrollWidth - el.clientWidth` (furthest possible scroll position).
   *  If the element's direction is RTL, this is a negative number between `0` (initial scroll
   *  position) and `-el.scrollWidth + el.clientWidth` (furthest possible scroll position).
   */
  OO.ui.Element.static.getScrollLeft = function ( el ) {
    var scrollLeft = isRoot( el ) ? $( window ).scrollLeft() : el.scrollLeft;
    scrollLeft = OO.ui.Element.static.computeNormalizedScrollLeft( scrollLeft, el );
    return scrollLeft;
  };

  /**
   * Set the number of pixels that an element's content is scrolled to the left.
   *
   * See #getScrollLeft.
   *
   * @static
   * @method
   * @param {HTMLElement|Window} el Element to scroll (and to use in calculations)
   * @param {number} scrollLeft Scroll position from the left.
   *  If the element's direction is LTR, this must be a positive number between
   *  `0` (initial scroll position) and `el.scrollWidth - el.clientWidth`
   *  (furthest possible scroll position).
   *  If the element's direction is RTL, this must be a negative number between
   *  `0` (initial scroll position) and `-el.scrollWidth + el.clientWidth`
   *  (furthest possible scroll position).
   */
  OO.ui.Element.static.setScrollLeft = function ( el, scrollLeft ) {
    scrollLeft = OO.ui.Element.static.computeNativeScrollLeft( scrollLeft, el );
    if ( isRoot( el ) ) {
      $( window ).scrollLeft( scrollLeft );
    } else {
      el.scrollLeft = scrollLeft;
    }
  };
}() );

/**
 * Get the root scrollable element of given element's document.
 *
 * Support: Chrome <= 60
 * On older versions of Blink, `document.documentElement` can't be used to get or set
 * the scrollTop property; instead we have to use `document.body`. Changing and testing the value
 * lets us use 'body' or 'documentElement' based on what is working.
 *
 * https://code.google.com/p/chromium/issues/detail?id=303131
 *
 * @static
 * @param {HTMLElement} el Element to find root scrollable parent for
 * @return {HTMLBodyElement|HTMLHtmlElement} Scrollable parent, `<body>` or `<html>`
 */
OO.ui.Element.static.getRootScrollableElement = function ( el ) {
  var scrollTop, body,
    doc = this.getDocument( el );

  if ( OO.ui.scrollableElement === undefined ) {
    body = doc.body;
    scrollTop = body.scrollTop;
    body.scrollTop = 1;

    // In some browsers (observed in Chrome 56 on Linux Mint 18.1),
    // body.scrollTop doesn't become exactly 1, but a fractional value like 0.76
    if ( Math.round( body.scrollTop ) === 1 ) {
      body.scrollTop = scrollTop;
      OO.ui.scrollableElement = 'body';
    } else {
      OO.ui.scrollableElement = 'documentElement';
    }
  }

  return doc[ OO.ui.scrollableElement ];
};

/**
 * Get closest scrollable container.
 *
 * Traverses up until either a scrollable element or the root is reached, in which case the root
 * scrollable element will be returned (see #getRootScrollableElement).
 *
 * @static
 * @param {HTMLElement} el Element to find scrollable container for
 * @param {string} [dimension] Dimension of scrolling to look for; `x`, `y` or omit for either
 * @return {HTMLElement} Closest scrollable container
 */
OO.ui.Element.static.getClosestScrollableContainer = function ( el, dimension ) {
  var i, val,
    doc = this.getDocument( el ),
    rootScrollableElement = this.getRootScrollableElement( el ),
    // Browsers do not correctly return the computed value of 'overflow' when 'overflow-x' and
    // 'overflow-y' have different values, so we need to check the separate properties.
    props = [ 'overflow-x', 'overflow-y' ],
    $parent = $( el ).parent();

  if ( el === doc.documentElement ) {
    return rootScrollableElement;
  }

  if ( dimension === 'x' || dimension === 'y' ) {
    props = [ 'overflow-' + dimension ];
  }

  // The parent of <html> is the document, so check we haven't traversed that far
  while ( $parent.length && $parent[ 0 ] !== doc ) {
    if ( $parent[ 0 ] === rootScrollableElement ) {
      return $parent[ 0 ];
    }
    i = props.length;
    while ( i-- ) {
      val = $parent.css( props[ i ] );
      // We assume that elements with 'overflow' (in any direction) set to 'hidden' will
      // never be scrolled in that direction, but they can actually be scrolled
      // programatically. The user can unintentionally perform a scroll in such case even if
      // the application doesn't scroll programatically, e.g. when jumping to an anchor, or
      // when using built-in find functionality.
      // This could cause funny issues...
      if ( val === 'auto' || val === 'scroll' ) {
        if ( $parent[ 0 ] === doc.body ) {
          // If overflow is set on <body>, return the rootScrollableElement
          // (<body> or <html>) as <body> may not be scrollable.
          return rootScrollableElement;
        } else {
          return $parent[ 0 ];
        }
      }
    }
    $parent = $parent.parent();
  }
  // The element is unattached... return something mostly sane
  return rootScrollableElement;
};

/**
 * Scroll element into view.
 *
 * @static
 * @param {HTMLElement|Object} elOrPosition Element to scroll into view
 * @param {Object} [config] Configuration options
 * @param {string} [config.animate=true] Animate to the new scroll offset.
 * @param {string} [config.duration='fast'] jQuery animation duration value
 * @param {string} [config.direction] Scroll in only one direction, e.g. 'x' or 'y', omit
 *  to scroll in both directions
 * @param {Object} [config.padding] Additional padding on the container to scroll past.
 *  Object containing any of 'top', 'bottom', 'left', or 'right' as numbers.
 * @param {Object} [config.scrollContainer] Scroll container. Defaults to
 *  getClosestScrollableContainer of the element.
 * @return {jQuery.Promise} Promise which resolves when the scroll is complete
 */
OO.ui.Element.static.scrollIntoView = function ( elOrPosition, config ) {
  var position, animations, container, $container, elementPosition, containerDimensions,
    $window, padding, animate, method,
    deferred = $.Deferred();

  // Configuration initialization
  config = config || {};

  padding = $.extend( {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }, config.padding );

  animate = config.animate !== false;

  animations = {};
  elementPosition = elOrPosition instanceof HTMLElement ?
    this.getDimensions( elOrPosition ).rect :
    elOrPosition;
  container = config.scrollContainer || (
    elOrPosition instanceof HTMLElement ?
      this.getClosestScrollableContainer( elOrPosition, config.direction ) :
      // No scrollContainer or element, use global document
      this.getClosestScrollableContainer( window.document.body )
  );
  $container = $( container );
  containerDimensions = this.getDimensions( container );
  $window = $( this.getWindow( container ) );

  // Compute the element's position relative to the container
  if ( $container.is( 'html, body' ) ) {
    // If the scrollable container is the root, this is easy
    position = {
      top: elementPosition.top,
      bottom: $window.innerHeight() - elementPosition.bottom,
      left: elementPosition.left,
      right: $window.innerWidth() - elementPosition.right
    };
  } else {
    // Otherwise, we have to subtract el's coordinates from container's coordinates
    position = {
      top: elementPosition.top -
        ( containerDimensions.rect.top + containerDimensions.borders.top ),
      bottom: containerDimensions.rect.bottom - containerDimensions.borders.bottom -
        containerDimensions.scrollbar.bottom - elementPosition.bottom,
      left: elementPosition.left -
        ( containerDimensions.rect.left + containerDimensions.borders.left ),
      right: containerDimensions.rect.right - containerDimensions.borders.right -
        containerDimensions.scrollbar.right - elementPosition.right
    };
  }

  if ( !config.direction || config.direction === 'y' ) {
    if ( position.top < padding.top ) {
      animations.scrollTop = containerDimensions.scroll.top + position.top - padding.top;
    } else if ( position.bottom < padding.bottom ) {
      animations.scrollTop = containerDimensions.scroll.top +
        // Scroll the bottom into view, but not at the expense
        // of scrolling the top out of view
        Math.min( position.top - padding.top, -position.bottom + padding.bottom );
    }
  }
  if ( !config.direction || config.direction === 'x' ) {
    if ( position.left < padding.left ) {
      animations.scrollLeft = containerDimensions.scroll.left + position.left - padding.left;
    } else if ( position.right < padding.right ) {
      animations.scrollLeft = containerDimensions.scroll.left +
        // Scroll the right into view, but not at the expense
        // of scrolling the left out of view
        Math.min( position.left - padding.left, -position.right + padding.right );
    }
    if ( animations.scrollLeft !== undefined ) {
      animations.scrollLeft =
        OO.ui.Element.static.computeNativeScrollLeft( animations.scrollLeft, container );
    }
  }
  if ( !$.isEmptyObject( animations ) ) {
    if ( animate ) {
      // eslint-disable-next-line no-jquery/no-animate
      $container.stop( true ).animate( animations, config.duration === undefined ? 'fast' : config.duration );
      $container.queue( function ( next ) {
        deferred.resolve();
        next();
      } );
    } else {
      $container.stop( true );
      for ( method in animations ) {
        $container[ method ]( animations[ method ] );
      }
      deferred.resolve();
    }
  } else {
    deferred.resolve();
  }
  return deferred.promise();
};

/**
 * Force the browser to reconsider whether it really needs to render scrollbars inside the element
 * and reserve space for them, because it probably doesn't.
 *
 * Workaround primarily for <https://code.google.com/p/chromium/issues/detail?id=387290>, but also
 * similar bugs in other browsers. "Just" forcing a reflow is not sufficient in all cases, we need
 * to first actually detach (or hide, but detaching is simpler) all children, *then* force a
 * reflow, and then reattach (or show) them back.
 *
 * @static
 * @param {HTMLElement} el Element to reconsider the scrollbars on
 */
OO.ui.Element.static.reconsiderScrollbars = function ( el ) {
  var i, len, scrollLeft, scrollTop, nodes = [];
  // Save scroll position
  scrollLeft = el.scrollLeft;
  scrollTop = el.scrollTop;
  // Detach all children
  while ( el.firstChild ) {
    nodes.push( el.firstChild );
    el.removeChild( el.firstChild );
  }
  // Force reflow
  // eslint-disable-next-line no-void
  void el.offsetHeight;
  // Reattach all children
  for ( i = 0, len = nodes.length; i < len; i++ ) {
    el.appendChild( nodes[ i ] );
  }
  // Restore scroll position (no-op if scrollbars disappeared)
  el.scrollLeft = scrollLeft;
  el.scrollTop = scrollTop;
};

/* Methods */

/**
 * Toggle visibility of an element.
 *
 * @param {boolean} [show] Make element visible, omit to toggle visibility
 * @fires visible
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.Element.prototype.toggle = function ( show ) {
  show = show === undefined ? !this.visible : !!show;

  if ( show !== this.isVisible() ) {
    this.visible = show;
    this.$element.toggleClass( 'oo-ui-element-hidden', !this.visible );
    this.emit( 'toggle', show );
  }

  return this;
};

/**
 * Check if element is visible.
 *
 * @return {boolean} element is visible
 */
OO.ui.Element.prototype.isVisible = function () {
  return this.visible;
};

/**
 * Get element data.
 *
 * @return {Mixed} Element data
 */
OO.ui.Element.prototype.getData = function () {
  return this.data;
};

/**
 * Set element data.
 *
 * @param {Mixed} data Element data
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.Element.prototype.setData = function ( data ) {
  this.data = data;
  return this;
};

/**
 * Set the element has an 'id' attribute.
 *
 * @param {string} id
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.Element.prototype.setElementId = function ( id ) {
  this.elementId = id;
  this.$element.attr( 'id', id );
  return this;
};

/**
 * Ensure that the element has an 'id' attribute, setting it to an unique value if it's missing,
 * and return its value.
 *
 * @return {string}
 */
OO.ui.Element.prototype.getElementId = function () {
  if ( this.elementId === null ) {
    this.setElementId( OO.ui.generateElementId() );
  }
  return this.elementId;
};

/**
 * Check if element supports one or more methods.
 *
 * @param {string|string[]} methods Method or list of methods to check
 * @return {boolean} All methods are supported
 */
OO.ui.Element.prototype.supports = function ( methods ) {
  var i, len,
    support = 0;

  methods = Array.isArray( methods ) ? methods : [ methods ];
  for ( i = 0, len = methods.length; i < len; i++ ) {
    if ( typeof this[ methods[ i ] ] === 'function' ) {
      support++;
    }
  }

  return methods.length === support;
};

/**
 * Update the theme-provided classes.
 *
 * @localdoc This is called in element mixins and widget classes any time state changes.
 *   Updating is debounced, minimizing overhead of changing multiple attributes and
 *   guaranteeing that theme updates do not occur within an element's constructor
 */
OO.ui.Element.prototype.updateThemeClasses = function () {
  OO.ui.theme.queueUpdateElementClasses( this );
};

/**
 * Get the HTML tag name.
 *
 * Override this method to base the result on instance information.
 *
 * @return {string} HTML tag name
 */
OO.ui.Element.prototype.getTagName = function () {
  return this.constructor.static.tagName;
};

/**
 * Check if the element is attached to the DOM
 *
 * @return {boolean} The element is attached to the DOM
 */
OO.ui.Element.prototype.isElementAttached = function () {
  return $.contains( this.getElementDocument(), this.$element[ 0 ] );
};

/**
 * Get the DOM document.
 *
 * @return {HTMLDocument} Document object
 */
OO.ui.Element.prototype.getElementDocument = function () {
  // Don't cache this in other ways either because subclasses could can change this.$element
  return OO.ui.Element.static.getDocument( this.$element );
};

/**
 * Get the DOM window.
 *
 * @return {Window} Window object
 */
OO.ui.Element.prototype.getElementWindow = function () {
  return OO.ui.Element.static.getWindow( this.$element );
};

/**
 * Get closest scrollable container.
 *
 * @return {HTMLElement} Closest scrollable container
 */
OO.ui.Element.prototype.getClosestScrollableElementContainer = function () {
  return OO.ui.Element.static.getClosestScrollableContainer( this.$element[ 0 ] );
};

/**
 * Get group element is in.
 *
 * @return {OO.ui.mixin.GroupElement|null} Group element, null if none
 */
OO.ui.Element.prototype.getElementGroup = function () {
  return this.elementGroup;
};

/**
 * Set group element is in.
 *
 * @param {OO.ui.mixin.GroupElement|null} group Group element, null if none
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.Element.prototype.setElementGroup = function ( group ) {
  this.elementGroup = group;
  return this;
};

/**
 * Scroll element into view.
 *
 * @param {Object} [config] Configuration options
 * @return {jQuery.Promise} Promise which resolves when the scroll is complete
 */
OO.ui.Element.prototype.scrollElementIntoView = function ( config ) {
  if (
    !this.isElementAttached() ||
    !this.isVisible() ||
    ( this.getElementGroup() && !this.getElementGroup().isVisible() )
  ) {
    return $.Deferred().resolve();
  }
  return OO.ui.Element.static.scrollIntoView( this.$element[ 0 ], config );
};

/**
 * Restore the pre-infusion dynamic state for this widget.
 *
 * This method is called after #$element has been inserted into DOM. The parameter is the return
 * value of #gatherPreInfuseState.
 *
 * @protected
 * @param {Object} state
 */
OO.ui.Element.prototype.restorePreInfuseState = function () {
};

/**
 * Wraps an HTML snippet for use with configuration values which default
 * to strings.  This bypasses the default html-escaping done to string
 * values.
 *
 * @class
 *
 * @constructor
 * @param {string} [content] HTML content
 */
OO.ui.HtmlSnippet = function OoUiHtmlSnippet( content ) {
  // Properties
  this.content = content;
};

/* Setup */

OO.initClass( OO.ui.HtmlSnippet );

/* Methods */

/**
 * Render into HTML.
 *
 * @return {string} Unchanged HTML snippet.
 */
OO.ui.HtmlSnippet.prototype.toString = function () {
  return this.content;
};

/**
 * Layouts are containers for elements and are used to arrange other widgets of arbitrary type in
 * a way that is centrally controlled and can be updated dynamically. Layouts can be, and usually
 * are, combined.
 * See {@link OO.ui.FieldsetLayout FieldsetLayout}, {@link OO.ui.FieldLayout FieldLayout},
 * {@link OO.ui.FormLayout FormLayout}, {@link OO.ui.PanelLayout PanelLayout},
 * {@link OO.ui.StackLayout StackLayout}, {@link OO.ui.PageLayout PageLayout},
 * {@link OO.ui.HorizontalLayout HorizontalLayout}, and {@link OO.ui.BookletLayout BookletLayout}
 * for more information and examples.
 *
 * @abstract
 * @class
 * @extends OO.ui.Element
 * @mixins OO.EventEmitter
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.Layout = function OoUiLayout( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.Layout.super.call( this, config );

  // Mixin constructors
  OO.EventEmitter.call( this );

  // Initialization
  this.$element.addClass( 'oo-ui-layout' );
};

/* Setup */

OO.inheritClass( OO.ui.Layout, OO.ui.Element );
OO.mixinClass( OO.ui.Layout, OO.EventEmitter );

/* Methods */

/**
 * Reset scroll offsets
 *
 * @chainable
 * @return {OO.ui.Layout} The layout, for chaining
 */
OO.ui.Layout.prototype.resetScroll = function () {
  this.$element[ 0 ].scrollTop = 0;
  OO.ui.Element.static.setScrollLeft( this.$element[ 0 ], 0 );

  return this;
};

/**
 * Widgets are compositions of one or more OOUI elements that users can both view
 * and interact with. All widgets can be configured and modified via a standard API,
 * and their state can change dynamically according to a model.
 *
 * @abstract
 * @class
 * @extends OO.ui.Element
 * @mixins OO.EventEmitter
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [disabled=false] Disable the widget. Disabled widgets cannot be used and their
 *  appearance reflects this state.
 */
OO.ui.Widget = function OoUiWidget( config ) {
  // Initialize config
  config = $.extend( { disabled: false }, config );

  // Parent constructor
  OO.ui.Widget.super.call( this, config );

  // Mixin constructors
  OO.EventEmitter.call( this );

  // Properties
  this.disabled = null;
  this.wasDisabled = null;

  // Initialization
  this.$element.addClass( 'oo-ui-widget' );
  this.setDisabled( !!config.disabled );
};

/* Setup */

OO.inheritClass( OO.ui.Widget, OO.ui.Element );
OO.mixinClass( OO.ui.Widget, OO.EventEmitter );

/* Events */

/**
 * @event disable
 *
 * A 'disable' event is emitted when the disabled state of the widget changes
 * (i.e. on disable **and** enable).
 *
 * @param {boolean} disabled Widget is disabled
 */

/**
 * @event toggle
 *
 * A 'toggle' event is emitted when the visibility of the widget changes.
 *
 * @param {boolean} visible Widget is visible
 */

/* Methods */

/**
 * Check if the widget is disabled.
 *
 * @return {boolean} Widget is disabled
 */
OO.ui.Widget.prototype.isDisabled = function () {
  return this.disabled;
};

/**
 * Set the 'disabled' state of the widget.
 *
 * When a widget is disabled, it cannot be used and its appearance is updated to reflect this state.
 *
 * @param {boolean} disabled Disable widget
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.Widget.prototype.setDisabled = function ( disabled ) {
  var isDisabled;

  this.disabled = !!disabled;
  isDisabled = this.isDisabled();
  if ( isDisabled !== this.wasDisabled ) {
    this.$element.toggleClass( 'oo-ui-widget-disabled', isDisabled );
    this.$element.toggleClass( 'oo-ui-widget-enabled', !isDisabled );
    this.$element.attr( 'aria-disabled', isDisabled.toString() );
    this.emit( 'disable', isDisabled );
    this.updateThemeClasses();
  }
  this.wasDisabled = isDisabled;

  return this;
};

/**
 * Update the disabled state, in case of changes in parent widget.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.Widget.prototype.updateDisabled = function () {
  this.setDisabled( this.disabled );
  return this;
};

/**
 * Get an ID of a labelable node which is part of this widget, if any, to be used for `<label for>`
 * value.
 *
 * If this function returns null, the widget should have a meaningful #simulateLabelClick method
 * instead.
 *
 * @return {string|null} The ID of the labelable element
 */
OO.ui.Widget.prototype.getInputId = function () {
  return null;
};

/**
 * Simulate the behavior of clicking on a label (a HTML `<label>` element) bound to this input.
 * HTML only allows `<label>` to act on specific "labelable" elements; complex widgets might need to
 * override this method to provide intuitive, accessible behavior.
 *
 * By default, this does nothing. OO.ui.mixin.TabIndexedElement overrides it for focusable widgets.
 * Individual widgets may override it too.
 *
 * This method is called by OO.ui.LabelWidget and OO.ui.FieldLayout. It should not be called
 * directly.
 */
OO.ui.Widget.prototype.simulateLabelClick = function () {
};

/**
 * Set the element with the given ID as a label for this widget.
 *
 * @param {string|null} id
 */
OO.ui.Widget.prototype.setLabelledBy = function ( id ) {
  if ( id ) {
    this.$element.attr( 'aria-labelledby', id );
  } else {
    this.$element.removeAttr( 'aria-labelledby' );
  }
};

/**
 * Theme logic.
 *
 * @abstract
 * @class
 *
 * @constructor
 */
OO.ui.Theme = function OoUiTheme() {
  this.elementClassesQueue = [];
  this.debouncedUpdateQueuedElementClasses = OO.ui.debounce( this.updateQueuedElementClasses );
};

/* Setup */

OO.initClass( OO.ui.Theme );

/* Methods */

/**
 * Get a list of classes to be applied to a widget.
 *
 * The 'on' and 'off' lists combined MUST contain keys for all classes the theme adds or removes,
 * otherwise state transitions will not work properly.
 *
 * @param {OO.ui.Element} element Element for which to get classes
 * @return {Object.<string,string[]>} Categorized class names with `on` and `off` lists
 */
OO.ui.Theme.prototype.getElementClasses = function () {
  return { on: [], off: [] };
};

/**
 * Update CSS classes provided by the theme.
 *
 * For elements with theme logic hooks, this should be called any time there's a state change.
 *
 * @param {OO.ui.Element} element Element for which to update classes
 */
OO.ui.Theme.prototype.updateElementClasses = function ( element ) {
  var $elements = $( [] ),
    classes = this.getElementClasses( element );

  if ( element.$icon ) {
    $elements = $elements.add( element.$icon );
  }
  if ( element.$indicator ) {
    $elements = $elements.add( element.$indicator );
  }

  $elements
    .removeClass( classes.off )
    .addClass( classes.on );
};

/**
 * @private
 */
OO.ui.Theme.prototype.updateQueuedElementClasses = function () {
  var i;
  for ( i = 0; i < this.elementClassesQueue.length; i++ ) {
    this.updateElementClasses( this.elementClassesQueue[ i ] );
  }
  // Clear the queue
  this.elementClassesQueue = [];
};

/**
 * Queue #updateElementClasses to be called for this element.
 *
 * @localdoc QUnit tests override this method to directly call #queueUpdateElementClasses,
 *   to make them synchronous.
 *
 * @param {OO.ui.Element} element Element for which to update classes
 */
OO.ui.Theme.prototype.queueUpdateElementClasses = function ( element ) {
  // Keep items in the queue unique. Use lastIndexOf to start checking from the end because that's
  // the most common case (this method is often called repeatedly for the same element).
  if ( this.elementClassesQueue.lastIndexOf( element ) !== -1 ) {
    return;
  }
  this.elementClassesQueue.push( element );
  this.debouncedUpdateQueuedElementClasses();
};

/**
 * Get the transition duration in milliseconds for dialogs opening/closing
 *
 * The dialog should be fully rendered this many milliseconds after the
 * ready process has executed.
 *
 * @return {number} Transition duration in milliseconds
 */
OO.ui.Theme.prototype.getDialogTransitionDuration = function () {
  return 0;
};

/**
 * The TabIndexedElement class is an attribute mixin used to add additional functionality to an
 * element created by another class. The mixin provides a ‘tabIndex’ property, which specifies the
 * order in which users will navigate through the focusable elements via the Tab key.
 *
 *     @example
 *     // TabIndexedElement is mixed into the ButtonWidget class
 *     // to provide a tabIndex property.
 *     var button1 = new OO.ui.ButtonWidget( {
 *             label: 'fourth',
 *             tabIndex: 4
 *         } ),
 *         button2 = new OO.ui.ButtonWidget( {
 *             label: 'second',
 *             tabIndex: 2
 *         } ),
 *         button3 = new OO.ui.ButtonWidget( {
 *             label: 'third',
 *             tabIndex: 3
 *         } ),
 *         button4 = new OO.ui.ButtonWidget( {
 *             label: 'first',
 *             tabIndex: 1
 *         } );
 *     $( document.body ).append(
 *         button1.$element,
 *         button2.$element,
 *         button3.$element,
 *         button4.$element
 *      );
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$tabIndexed] The element that should use the tabindex functionality. By default,
 *  the functionality is applied to the element created by the class ($element). If a different
 *  element is specified, the tabindex functionality will be applied to it instead.
 * @cfg {string|number|null} [tabIndex=0] Number that specifies the element’s position in the
 *  tab-navigation order (e.g., 1 for the first focusable element). Use 0 to use the default
 *  navigation order; use -1 to remove the element from the tab-navigation flow.
 */
OO.ui.mixin.TabIndexedElement = function OoUiMixinTabIndexedElement( config ) {
  // Configuration initialization
  config = $.extend( { tabIndex: 0 }, config );

  // Properties
  this.$tabIndexed = null;
  this.tabIndex = null;

  // Events
  this.connect( this, {
    disable: 'onTabIndexedElementDisable'
  } );

  // Initialization
  this.setTabIndex( config.tabIndex );
  this.setTabIndexedElement( config.$tabIndexed || this.$element );
};

/* Setup */

OO.initClass( OO.ui.mixin.TabIndexedElement );

/* Methods */

/**
 * Set the element that should use the tabindex functionality.
 *
 * This method is used to retarget a tabindex mixin so that its functionality applies
 * to the specified element. If an element is currently using the functionality, the mixin’s
 * effect on that element is removed before the new element is set up.
 *
 * @param {jQuery} $tabIndexed Element that should use the tabindex functionality
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.setTabIndexedElement = function ( $tabIndexed ) {
  var tabIndex = this.tabIndex;
  // Remove attributes from old $tabIndexed
  this.setTabIndex( null );
  // Force update of new $tabIndexed
  this.$tabIndexed = $tabIndexed;
  this.tabIndex = tabIndex;
  return this.updateTabIndex();
};

/**
 * Set the value of the tabindex.
 *
 * @param {string|number|null} tabIndex Tabindex value, or `null` for no tabindex
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.setTabIndex = function ( tabIndex ) {
  tabIndex = /^-?\d+$/.test( tabIndex ) ? Number( tabIndex ) : null;

  if ( this.tabIndex !== tabIndex ) {
    this.tabIndex = tabIndex;
    this.updateTabIndex();
  }

  return this;
};

/**
 * Update the `tabindex` attribute, in case of changes to tab index or
 * disabled state.
 *
 * @private
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.updateTabIndex = function () {
  if ( this.$tabIndexed ) {
    if ( this.tabIndex !== null ) {
      // Do not index over disabled elements
      this.$tabIndexed.attr( {
        tabindex: this.isDisabled() ? -1 : this.tabIndex,
        // Support: ChromeVox and NVDA
        // These do not seem to inherit aria-disabled from parent elements
        'aria-disabled': this.isDisabled().toString()
      } );
    } else {
      this.$tabIndexed.removeAttr( 'tabindex aria-disabled' );
    }
  }
  return this;
};

/**
 * Handle disable events.
 *
 * @private
 * @param {boolean} disabled Element is disabled
 */
OO.ui.mixin.TabIndexedElement.prototype.onTabIndexedElementDisable = function () {
  this.updateTabIndex();
};

/**
 * Get the value of the tabindex.
 *
 * @return {number|null} Tabindex value
 */
OO.ui.mixin.TabIndexedElement.prototype.getTabIndex = function () {
  return this.tabIndex;
};

/**
 * Get an ID of a focusable element of this widget, if any, to be used for `<label for>` value.
 *
 * If the element already has an ID then that is returned, otherwise unique ID is
 * generated, set on the element, and returned.
 *
 * @return {string|null} The ID of the focusable element
 */
OO.ui.mixin.TabIndexedElement.prototype.getInputId = function () {
  var id;

  if ( !this.$tabIndexed ) {
    return null;
  }
  if ( !this.isLabelableNode( this.$tabIndexed ) ) {
    return null;
  }

  id = this.$tabIndexed.attr( 'id' );
  if ( id === undefined ) {
    id = OO.ui.generateElementId();
    this.$tabIndexed.attr( 'id', id );
  }

  return id;
};

/**
 * Whether the node is 'labelable' according to the HTML spec
 * (i.e., whether it can be interacted with through a `<label for="…">`).
 * See: <https://html.spec.whatwg.org/multipage/forms.html#category-label>.
 *
 * @private
 * @param {jQuery} $node
 * @return {boolean}
 */
OO.ui.mixin.TabIndexedElement.prototype.isLabelableNode = function ( $node ) {
  var
    labelableTags = [ 'button', 'meter', 'output', 'progress', 'select', 'textarea' ],
    tagName = ( $node.prop( 'tagName' ) || '' ).toLowerCase();

  if ( tagName === 'input' && $node.attr( 'type' ) !== 'hidden' ) {
    return true;
  }
  if ( labelableTags.indexOf( tagName ) !== -1 ) {
    return true;
  }
  return false;
};

/**
 * Focus this element.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.focus = function () {
  if ( !this.isDisabled() ) {
    this.$tabIndexed.trigger( 'focus' );
  }
  return this;
};

/**
 * Blur this element.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TabIndexedElement.prototype.blur = function () {
  this.$tabIndexed.trigger( 'blur' );
  return this;
};

/**
 * @inheritdoc OO.ui.Widget
 */
OO.ui.mixin.TabIndexedElement.prototype.simulateLabelClick = function () {
  this.focus();
};

/**
 * ButtonElement is often mixed into other classes to generate a button, which is a clickable
 * interface element that can be configured with access keys for keyboard interaction.
 * See the [OOUI documentation on MediaWiki] [1] for examples.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Buttons_and_Switches#Buttons
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$button] The button element created by the class.
 *  If this configuration is omitted, the button element will use a generated `<a>`.
 * @cfg {boolean} [framed=true] Render the button with a frame
 */
OO.ui.mixin.ButtonElement = function OoUiMixinButtonElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.$button = null;
  this.framed = null;
  this.active = config.active !== undefined && config.active;
  this.onDocumentMouseUpHandler = this.onDocumentMouseUp.bind( this );
  this.onMouseDownHandler = this.onMouseDown.bind( this );
  this.onDocumentKeyUpHandler = this.onDocumentKeyUp.bind( this );
  this.onKeyDownHandler = this.onKeyDown.bind( this );
  this.onClickHandler = this.onClick.bind( this );
  this.onKeyPressHandler = this.onKeyPress.bind( this );

  // Initialization
  this.$element.addClass( 'oo-ui-buttonElement' );
  this.toggleFramed( config.framed === undefined || config.framed );
  this.setButtonElement( config.$button || $( '<a>' ) );
};

/* Setup */

OO.initClass( OO.ui.mixin.ButtonElement );

/* Static Properties */

/**
 * Cancel mouse down events.
 *
 * This property is usually set to `true` to prevent the focus from changing when the button is
 * clicked.
 * Classes such as {@link OO.ui.mixin.DraggableElement DraggableElement} and
 * {@link OO.ui.ButtonOptionWidget ButtonOptionWidget} use a value of `false` so that dragging
 * behavior is possible and mousedown events can be handled by a parent widget.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.mixin.ButtonElement.static.cancelButtonMouseDownEvents = true;

/* Events */

/**
 * A 'click' event is emitted when the button element is clicked.
 *
 * @event click
 */

/* Methods */

/**
 * Set the button element.
 *
 * This method is used to retarget a button mixin so that its functionality applies to
 * the specified button element instead of the one created by the class. If a button element
 * is already set, the method will remove the mixin’s effect on that element.
 *
 * @param {jQuery} $button Element to use as button
 */
OO.ui.mixin.ButtonElement.prototype.setButtonElement = function ( $button ) {
  if ( this.$button ) {
    this.$button
      .removeClass( 'oo-ui-buttonElement-button' )
      .removeAttr( 'role accesskey' )
      .off( {
        mousedown: this.onMouseDownHandler,
        keydown: this.onKeyDownHandler,
        click: this.onClickHandler,
        keypress: this.onKeyPressHandler
      } );
  }

  this.$button = $button
    .addClass( 'oo-ui-buttonElement-button' )
    .on( {
      mousedown: this.onMouseDownHandler,
      keydown: this.onKeyDownHandler,
      click: this.onClickHandler,
      keypress: this.onKeyPressHandler
    } );

  // Add `role="button"` on `<a>` elements, where it's needed
  // `toUpperCase()` is added for XHTML documents
  if ( this.$button.prop( 'tagName' ).toUpperCase() === 'A' ) {
    this.$button.attr( 'role', 'button' );
  }
};

/**
 * Handles mouse down events.
 *
 * @protected
 * @param {jQuery.Event} e Mouse down event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.mixin.ButtonElement.prototype.onMouseDown = function ( e ) {
  if ( this.isDisabled() || e.which !== OO.ui.MouseButtons.LEFT ) {
    return;
  }
  this.$element.addClass( 'oo-ui-buttonElement-pressed' );
  // Run the mouseup handler no matter where the mouse is when the button is let go, so we can
  // reliably remove the pressed class
  this.getElementDocument().addEventListener( 'mouseup', this.onDocumentMouseUpHandler, true );
  // Prevent change of focus unless specifically configured otherwise
  if ( this.constructor.static.cancelButtonMouseDownEvents ) {
    return false;
  }
};

/**
 * Handles document mouse up events.
 *
 * @protected
 * @param {MouseEvent} e Mouse up event
 */
OO.ui.mixin.ButtonElement.prototype.onDocumentMouseUp = function ( e ) {
  if ( this.isDisabled() || e.which !== OO.ui.MouseButtons.LEFT ) {
    return;
  }
  this.$element.removeClass( 'oo-ui-buttonElement-pressed' );
  // Stop listening for mouseup, since we only needed this once
  this.getElementDocument().removeEventListener( 'mouseup', this.onDocumentMouseUpHandler, true );
};

/**
 * Handles mouse click events.
 *
 * @protected
 * @param {jQuery.Event} e Mouse click event
 * @fires click
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.mixin.ButtonElement.prototype.onClick = function ( e ) {
  if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT ) {
    if ( this.emit( 'click' ) ) {
      return false;
    }
  }
};

/**
 * Handles key down events.
 *
 * @protected
 * @param {jQuery.Event} e Key down event
 */
OO.ui.mixin.ButtonElement.prototype.onKeyDown = function ( e ) {
  if ( this.isDisabled() || ( e.which !== OO.ui.Keys.SPACE && e.which !== OO.ui.Keys.ENTER ) ) {
    return;
  }
  this.$element.addClass( 'oo-ui-buttonElement-pressed' );
  // Run the keyup handler no matter where the key is when the button is let go, so we can
  // reliably remove the pressed class
  this.getElementDocument().addEventListener( 'keyup', this.onDocumentKeyUpHandler, true );
};

/**
 * Handles document key up events.
 *
 * @protected
 * @param {KeyboardEvent} e Key up event
 */
OO.ui.mixin.ButtonElement.prototype.onDocumentKeyUp = function ( e ) {
  if ( this.isDisabled() || ( e.which !== OO.ui.Keys.SPACE && e.which !== OO.ui.Keys.ENTER ) ) {
    return;
  }
  this.$element.removeClass( 'oo-ui-buttonElement-pressed' );
  // Stop listening for keyup, since we only needed this once
  this.getElementDocument().removeEventListener( 'keyup', this.onDocumentKeyUpHandler, true );
};

/**
 * Handles key press events.
 *
 * @protected
 * @param {jQuery.Event} e Key press event
 * @fires click
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.mixin.ButtonElement.prototype.onKeyPress = function ( e ) {
  if ( !this.isDisabled() && ( e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER ) ) {
    if ( this.emit( 'click' ) ) {
      return false;
    }
  }
};

/**
 * Check if button has a frame.
 *
 * @return {boolean} Button is framed
 */
OO.ui.mixin.ButtonElement.prototype.isFramed = function () {
  return this.framed;
};

/**
 * Render the button with or without a frame. Omit the `framed` parameter to toggle the button frame
 * on and off.
 *
 * @param {boolean} [framed] Make button framed, omit to toggle
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.ButtonElement.prototype.toggleFramed = function ( framed ) {
  framed = framed === undefined ? !this.framed : !!framed;
  if ( framed !== this.framed ) {
    this.framed = framed;
    this.$element
      .toggleClass( 'oo-ui-buttonElement-frameless', !framed )
      .toggleClass( 'oo-ui-buttonElement-framed', framed );
    this.updateThemeClasses();
  }

  return this;
};

/**
 * Set the button's active state.
 *
 * The active state can be set on:
 *
 *  - {@link OO.ui.ButtonOptionWidget ButtonOptionWidget} when it is selected
 *  - {@link OO.ui.ToggleButtonWidget ToggleButtonWidget} when it is toggle on
 *  - {@link OO.ui.ButtonWidget ButtonWidget} when clicking the button would only refresh the page
 *
 * @protected
 * @param {boolean} value Make button active
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.ButtonElement.prototype.setActive = function ( value ) {
  this.active = !!value;
  this.$element.toggleClass( 'oo-ui-buttonElement-active', this.active );
  this.updateThemeClasses();
  return this;
};

/**
 * Check if the button is active
 *
 * @protected
 * @return {boolean} The button is active
 */
OO.ui.mixin.ButtonElement.prototype.isActive = function () {
  return this.active;
};

/**
 * Any OOUI widget that contains other widgets (such as {@link OO.ui.ButtonWidget buttons} or
 * {@link OO.ui.OptionWidget options}) mixes in GroupElement. Adding, removing, and clearing
 * items from the group is done through the interface the class provides.
 * For more information, please see the [OOUI documentation on MediaWiki] [1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Elements/Groups
 *
 * @abstract
 * @mixins OO.EmitterList
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$group] The container element created by the class. If this configuration
 *  is omitted, the group element will use a generated `<div>`.
 */
OO.ui.mixin.GroupElement = function OoUiMixinGroupElement( config ) {
  // Configuration initialization
  config = config || {};

  // Mixin constructors
  OO.EmitterList.call( this, config );

  // Properties
  this.$group = null;

  // Initialization
  this.setGroupElement( config.$group || $( '<div>' ) );
};

/* Setup */

OO.mixinClass( OO.ui.mixin.GroupElement, OO.EmitterList );

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the set of selected items changes.
 *
 * @param {OO.ui.Element[]} items Items currently in the group
 */

/* Methods */

/**
 * Set the group element.
 *
 * If an element is already set, items will be moved to the new element.
 *
 * @param {jQuery} $group Element to use as group
 */
OO.ui.mixin.GroupElement.prototype.setGroupElement = function ( $group ) {
  var i, len;

  this.$group = $group;
  for ( i = 0, len = this.items.length; i < len; i++ ) {
    this.$group.append( this.items[ i ].$element );
  }
};

/**
 * Find an item by its data.
 *
 * Only the first item with matching data will be returned. To return all matching items,
 * use the #findItemsFromData method.
 *
 * @param {Object} data Item data to search for
 * @return {OO.ui.Element|null} Item with equivalent data, `null` if none exists
 */
OO.ui.mixin.GroupElement.prototype.findItemFromData = function ( data ) {
  var i, len, item,
    hash = OO.getHash( data );

  for ( i = 0, len = this.items.length; i < len; i++ ) {
    item = this.items[ i ];
    if ( hash === OO.getHash( item.getData() ) ) {
      return item;
    }
  }

  return null;
};

/**
 * Find items by their data.
 *
 * All items with matching data will be returned. To return only the first match, use the
 * #findItemFromData method instead.
 *
 * @param {Object} data Item data to search for
 * @return {OO.ui.Element[]} Items with equivalent data
 */
OO.ui.mixin.GroupElement.prototype.findItemsFromData = function ( data ) {
  var i, len, item,
    hash = OO.getHash( data ),
    items = [];

  for ( i = 0, len = this.items.length; i < len; i++ ) {
    item = this.items[ i ];
    if ( hash === OO.getHash( item.getData() ) ) {
      items.push( item );
    }
  }

  return items;
};

/**
 * Add items to the group.
 *
 * Items will be added to the end of the group array unless the optional `index` parameter
 * specifies a different insertion point. Adding an existing item will move it to the end of the
 * array or the point specified by the `index`.
 *
 * @param {OO.ui.Element[]} items An array of items to add to the group
 * @param {number} [index] Index of the insertion point
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.GroupElement.prototype.addItems = function ( items, index ) {

  if ( items.length === 0 ) {
    return this;
  }

  // Mixin method
  OO.EmitterList.prototype.addItems.call( this, items, index );

  this.emit( 'change', this.getItems() );
  return this;
};

/**
 * Move an item from its current position to a new index.
 *
 * The item is expected to exist in the list. If it doesn't,
 * the method will throw an exception.
 *
 * See https://doc.wikimedia.org/oojs/master/OO.EmitterList.html
 *
 * @private
 * @param {OO.EventEmitter} items Item to add
 * @param {number} newIndex Index to move the item to
 * @return {number} The index the item was moved to
 * @throws {Error} If item is not in the list
 */
OO.ui.mixin.GroupElement.prototype.moveItem = function ( items, newIndex ) {
  // insertItemElements expects this.items to not have been modified yet, so call before the mixin
  this.insertItemElements( items, newIndex );

  // Mixin method
  newIndex = OO.EmitterList.prototype.moveItem.call( this, items, newIndex );

  return newIndex;
};

/**
 * Utility method to insert an item into the list, and
 * connect it to aggregate events.
 *
 * Don't call this directly unless you know what you're doing.
 * Use #addItems instead.
 *
 * This method can be extended in child classes to produce
 * different behavior when an item is inserted. For example,
 * inserted items may also be attached to the DOM or may
 * interact with some other nodes in certain ways. Extending
 * this method is allowed, but if overridden, the aggregation
 * of events must be preserved, or behavior of emitted events
 * will be broken.
 *
 * If you are extending this method, please make sure the
 * parent method is called.
 *
 * See https://doc.wikimedia.org/oojs/master/OO.EmitterList.html
 *
 * @protected
 * @param {OO.EventEmitter|Object} item Item to add
 * @param {number} index Index to add items at
 * @return {number} The index the item was added at
 */
OO.ui.mixin.GroupElement.prototype.insertItem = function ( item, index ) {
  item.setElementGroup( this );
  this.insertItemElements( item, index );

  // Mixin method
  index = OO.EmitterList.prototype.insertItem.call( this, item, index );

  return index;
};

/**
 * Insert elements into the group
 *
 * @private
 * @param {OO.ui.Element} itemWidget Item to insert
 * @param {number} index Insertion index
 */
OO.ui.mixin.GroupElement.prototype.insertItemElements = function ( itemWidget, index ) {
  if ( index === undefined || index < 0 || index >= this.items.length ) {
    this.$group.append( itemWidget.$element );
  } else if ( index === 0 ) {
    this.$group.prepend( itemWidget.$element );
  } else {
    this.items[ index ].$element.before( itemWidget.$element );
  }
};

/**
 * Remove the specified items from a group.
 *
 * Removed items are detached (not removed) from the DOM so that they may be reused.
 * To remove all items from a group, you may wish to use the #clearItems method instead.
 *
 * @param {OO.ui.Element[]} items An array of items to remove
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.GroupElement.prototype.removeItems = function ( items ) {
  var i, len, item, index;

  if ( items.length === 0 ) {
    return this;
  }

  // Remove specific items elements
  for ( i = 0, len = items.length; i < len; i++ ) {
    item = items[ i ];
    index = this.items.indexOf( item );
    if ( index !== -1 ) {
      item.setElementGroup( null );
      item.$element.detach();
    }
  }

  // Mixin method
  OO.EmitterList.prototype.removeItems.call( this, items );

  this.emit( 'change', this.getItems() );
  return this;
};

/**
 * Clear all items from the group.
 *
 * Cleared items are detached from the DOM, not removed, so that they may be reused.
 * To remove only a subset of items from a group, use the #removeItems method.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.GroupElement.prototype.clearItems = function () {
  var i, len;

  // Remove all item elements
  for ( i = 0, len = this.items.length; i < len; i++ ) {
    this.items[ i ].setElementGroup( null );
    this.items[ i ].$element.detach();
  }

  // Mixin method
  OO.EmitterList.prototype.clearItems.call( this );

  this.emit( 'change', this.getItems() );
  return this;
};

/**
 * LabelElement is often mixed into other classes to generate a label, which
 * helps identify the function of an interface element.
 * See the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Labels
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$label] The label element created by the class. If this
 *  configuration is omitted, the label element will use a generated `<span>`.
 * @cfg {jQuery|string|Function|OO.ui.HtmlSnippet} [label] The label text. The label can be
 *  specified as a plaintext string, a jQuery selection of elements, or a function that will
 *  produce a string in the future. See the [OOUI documentation on MediaWiki] [2] for examples.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Labels
 * @cfg {boolean} [invisibleLabel] Whether the label should be visually hidden (but still
 *  accessible to screen-readers).
 */
OO.ui.mixin.LabelElement = function OoUiMixinLabelElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.$label = null;
  this.label = null;
  this.invisibleLabel = null;

  // Initialization
  this.setLabel( config.label || this.constructor.static.label );
  this.setLabelElement( config.$label || $( '<span>' ) );
  this.setInvisibleLabel( config.invisibleLabel );
};

/* Setup */

OO.initClass( OO.ui.mixin.LabelElement );

/* Events */

/**
 * @event labelChange
 * @param {string} value
 */

/* Static Properties */

/**
 * The label text. The label can be specified as a plaintext string, a function that will
 * produce a string in the future, or `null` for no label. The static value will
 * be overridden if a label is specified with the #label config option.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.LabelElement.static.label = null;

/* Static methods */

/**
 * Highlight the first occurrence of the query in the given text
 *
 * @param {string} text Text
 * @param {string} query Query to find
 * @param {Function} [compare] Optional string comparator, e.g. Intl.Collator().compare
 * @param {boolean} [combineMarks=false] Pull combining marks into highlighted text
 * @return {jQuery} Text with the first match of the query
 *  sub-string wrapped in highlighted span
 */
OO.ui.mixin.LabelElement.static.highlightQuery = function ( text, query, compare, combineMarks ) {
  var i, tLen, qLen,
    offset = -1,
    $result = $( '<span>' ),
    comboLength = 0,
    comboMarks = '',
    comboRegex,
    comboMatch;

  if ( compare ) {
    tLen = text.length;
    qLen = query.length;
    for ( i = 0; offset === -1 && i <= tLen - qLen; i++ ) {
      if ( compare( query, text.slice( i, i + qLen ) ) === 0 ) {
        offset = i;
      }
    }
  } else {
    offset = text.toLowerCase().indexOf( query.toLowerCase() );
  }

  if ( !query.length || offset === -1 ) {
    $result.text( text );
  } else {
    // Look for combining characters after the match
    if ( combineMarks ) {
      // Equivalent to \p{Mark} (which is not currently available in JavaScript)
      comboMarks = '[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]';

      comboRegex = new RegExp( '(^)' + comboMarks + '*' );
      comboMatch = text.slice( offset + query.length ).match( comboRegex );

      if ( comboMatch && comboMatch.length ) {
        comboLength = comboMatch[ 0 ].length;
      }
    }

    $result.append(
      document.createTextNode( text.slice( 0, offset ) ),
      $( '<span>' )
        .addClass( 'oo-ui-labelElement-label-highlight' )
        .text( text.slice( offset, offset + query.length + comboLength ) ),
      document.createTextNode( text.slice( offset + query.length + comboLength ) )
    );
  }
  return $result.contents();
};

/* Methods */

/**
 * Set the label element.
 *
 * If an element is already set, it will be cleaned up before setting up the new element.
 *
 * @param {jQuery} $label Element to use as label
 */
OO.ui.mixin.LabelElement.prototype.setLabelElement = function ( $label ) {
  if ( this.$label ) {
    this.$label.removeClass( 'oo-ui-labelElement-label' ).empty();
  }

  this.$label = $label.addClass( 'oo-ui-labelElement-label' );
  this.setLabelContent( this.label );
};

/**
 * Set the 'id' attribute of the label element.
 *
 * @param {string} id
 * @chainable
 * @return {OO.ui.mixin.LabelElement} The element, for chaining
 */
OO.ui.mixin.LabelElement.prototype.setLabelId = function ( id ) {
  this.$label.attr( 'id', id );
  return this;
};

/**
 * Set the label.
 *
 * An empty string will result in the label being hidden. A string containing only whitespace will
 * be converted to a single `&nbsp;`.
 *
 * @param {jQuery|string|OO.ui.HtmlSnippet|Function|null} label Label nodes; text; a function that
 *  returns nodes or text; or null for no label
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LabelElement.prototype.setLabel = function ( label ) {
  label = typeof label === 'function' ? OO.ui.resolveMsg( label ) : label;
  label = ( ( typeof label === 'string' || label instanceof $ ) && label.length ) || ( label instanceof OO.ui.HtmlSnippet && label.toString().length ) ? label : null;

  if ( this.label !== label ) {
    if ( this.$label ) {
      this.setLabelContent( label );
    }
    this.label = label;
    this.emit( 'labelChange' );
  }

  this.$element.toggleClass( 'oo-ui-labelElement', !!this.label && !this.invisibleLabel );

  return this;
};

/**
 * Set whether the label should be visually hidden (but still accessible to screen-readers).
 *
 * @param {boolean} invisibleLabel
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LabelElement.prototype.setInvisibleLabel = function ( invisibleLabel ) {
  invisibleLabel = !!invisibleLabel;

  if ( this.invisibleLabel !== invisibleLabel ) {
    this.invisibleLabel = invisibleLabel;
    this.emit( 'labelChange' );
  }

  this.$label.toggleClass( 'oo-ui-labelElement-invisible', this.invisibleLabel );
  // Pretend that there is no label, a lot of CSS has been written with this assumption
  this.$element.toggleClass( 'oo-ui-labelElement', !!this.label && !this.invisibleLabel );

  return this;
};

/**
 * Set the label as plain text with a highlighted query
 *
 * @param {string} text Text label to set
 * @param {string} query Substring of text to highlight
 * @param {Function} [compare] Optional string comparator, e.g. Intl.Collator().compare
 * @param {boolean} [combineMarks=false] Pull combining marks into highlighted text
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LabelElement.prototype.setHighlightedQuery = function (
  text, query, compare, combineMarks
) {
  return this.setLabel(
    this.constructor.static.highlightQuery( text, query, compare, combineMarks )
  );
};

/**
 * Get the label.
 *
 * @return {jQuery|string|Function|null} Label nodes; text; a function that returns nodes or
 *  text; or null for no label
 */
OO.ui.mixin.LabelElement.prototype.getLabel = function () {
  return this.label;
};

/**
 * Set the content of the label.
 *
 * Do not call this method until after the label element has been set by #setLabelElement.
 *
 * @private
 * @param {jQuery|string|Function|null} label Label nodes; text; a function that returns nodes or
 *  text; or null for no label
 */
OO.ui.mixin.LabelElement.prototype.setLabelContent = function ( label ) {
  if ( typeof label === 'string' ) {
    if ( label.match( /^\s*$/ ) ) {
      // Convert whitespace only string to a single non-breaking space
      this.$label.html( '&nbsp;' );
    } else {
      this.$label.text( label );
    }
  } else if ( label instanceof OO.ui.HtmlSnippet ) {
    this.$label.html( label.toString() );
  } else if ( label instanceof $ ) {
    this.$label.empty().append( label );
  } else {
    this.$label.empty();
  }
};

/**
 * IconElement is often mixed into other classes to generate an icon.
 * Icons are graphics, about the size of normal text. They are used to aid the user
 * in locating a control or to convey information in a space-efficient way. See the
 * [OOUI documentation on MediaWiki] [1] for a list of icons
 * included in the library.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Icons
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$icon] The icon element created by the class. If this configuration is omitted,
 *  the icon element will use a generated `<span>`. To use a different HTML tag, or to specify that
 *  the icon element be set to an existing icon instead of the one generated by this class, set a
 *  value using a jQuery selection. For example:
 *
 *      // Use a <div> tag instead of a <span>
 *     $icon: $( '<div>' )
 *     // Use an existing icon element instead of the one generated by the class
 *     $icon: this.$element
 *     // Use an icon element from a child widget
 *     $icon: this.childwidget.$element
 * @cfg {Object|string} [icon=''] The symbolic name of the icon (e.g., ‘remove’ or ‘menu’), or a
 *  map of symbolic names. A map is used for i18n purposes and contains a `default` icon
 *  name and additional names keyed by language code. The `default` name is used when no icon is
 *  keyed by the user's language.
 *
 *  Example of an i18n map:
 *
 *     { default: 'bold-a', en: 'bold-b', de: 'bold-f' }
 *  See the [OOUI documentation on MediaWiki] [2] for a list of icons included in the library.
 * [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Icons
 */
OO.ui.mixin.IconElement = function OoUiMixinIconElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.$icon = null;
  this.icon = null;

  // Initialization
  this.setIcon( config.icon || this.constructor.static.icon );
  this.setIconElement( config.$icon || $( '<span>' ) );
};

/* Setup */

OO.initClass( OO.ui.mixin.IconElement );

/* Static Properties */

/**
 * The symbolic name of the icon (e.g., ‘remove’ or ‘menu’), or a map of symbolic names. A map
 * is used for i18n purposes and contains a `default` icon name and additional names keyed by
 * language code. The `default` name is used when no icon is keyed by the user's language.
 *
 * Example of an i18n map:
 *
 *     { default: 'bold-a', en: 'bold-b', de: 'bold-f' }
 *
 * Note: the static property will be overridden if the #icon configuration is used.
 *
 * @static
 * @inheritable
 * @property {Object|string}
 */
OO.ui.mixin.IconElement.static.icon = null;

/**
 * The icon title, displayed when users move the mouse over the icon. The value can be text, a
 * function that returns title text, or `null` for no title.
 *
 * The static property will be overridden if the #iconTitle configuration is used.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.IconElement.static.iconTitle = null;

/* Methods */

/**
 * Set the icon element. This method is used to retarget an icon mixin so that its functionality
 * applies to the specified icon element instead of the one created by the class. If an icon
 * element is already set, the mixin’s effect on that element is removed. Generated CSS classes
 * and mixin methods will no longer affect the element.
 *
 * @param {jQuery} $icon Element to use as icon
 */
OO.ui.mixin.IconElement.prototype.setIconElement = function ( $icon ) {
  if ( this.$icon ) {
    this.$icon
      .removeClass( 'oo-ui-iconElement-icon oo-ui-icon-' + this.icon )
      .removeAttr( 'title' );
  }

  this.$icon = $icon
    .addClass( 'oo-ui-iconElement-icon' )
    .toggleClass( 'oo-ui-iconElement-noIcon', !this.icon )
    .toggleClass( 'oo-ui-icon-' + this.icon, !!this.icon );
  if ( this.iconTitle !== null ) {
    this.$icon.attr( 'title', this.iconTitle );
  }

  this.updateThemeClasses();
};

/**
 * Set icon by symbolic name (e.g., ‘remove’ or ‘menu’). Use `null` to remove an icon.
 * The icon parameter can also be set to a map of icon names. See the #icon config setting
 * for an example.
 *
 * @param {Object|string|null} icon A symbolic icon name, a {@link #icon map of icon names} keyed
 *  by language code, or `null` to remove the icon.
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.IconElement.prototype.setIcon = function ( icon ) {
  icon = OO.isPlainObject( icon ) ? OO.ui.getLocalValue( icon, null, 'default' ) : icon;
  icon = typeof icon === 'string' && icon.trim().length ? icon.trim() : null;

  if ( this.icon !== icon ) {
    if ( this.$icon ) {
      if ( this.icon !== null ) {
        this.$icon.removeClass( 'oo-ui-icon-' + this.icon );
      }
      if ( icon !== null ) {
        this.$icon.addClass( 'oo-ui-icon-' + icon );
      }
    }
    this.icon = icon;
  }

  this.$element.toggleClass( 'oo-ui-iconElement', !!this.icon );
  if ( this.$icon ) {
    this.$icon.toggleClass( 'oo-ui-iconElement-noIcon', !this.icon );
  }
  this.updateThemeClasses();

  return this;
};

/**
 * Get the symbolic name of the icon.
 *
 * @return {string} Icon name
 */
OO.ui.mixin.IconElement.prototype.getIcon = function () {
  return this.icon;
};

/**
 * IndicatorElement is often mixed into other classes to generate an indicator.
 * Indicators are small graphics that are generally used in two ways:
 *
 * - To draw attention to the status of an item. For example, an indicator might be
 *   used to show that an item in a list has errors that need to be resolved.
 * - To clarify the function of a control that acts in an exceptional way (a button
 *   that opens a menu instead of performing an action directly, for example).
 *
 * For a list of indicators included in the library, please see the
 * [OOUI documentation on MediaWiki] [1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Indicators
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$indicator] The indicator element created by the class. If this
 *  configuration is omitted, the indicator element will use a generated `<span>`.
 * @cfg {string} [indicator] Symbolic name of the indicator (e.g., ‘clear’ or ‘down’).
 *  See the [OOUI documentation on MediaWiki][2] for a list of indicators included
 *  in the library.
 * [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Indicators
 */
OO.ui.mixin.IndicatorElement = function OoUiMixinIndicatorElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.$indicator = null;
  this.indicator = null;

  // Initialization
  this.setIndicator( config.indicator || this.constructor.static.indicator );
  this.setIndicatorElement( config.$indicator || $( '<span>' ) );
};

/* Setup */

OO.initClass( OO.ui.mixin.IndicatorElement );

/* Static Properties */

/**
 * Symbolic name of the indicator (e.g., ‘clear’ or  ‘down’).
 * The static property will be overridden if the #indicator configuration is used.
 *
 * @static
 * @inheritable
 * @property {string|null}
 */
OO.ui.mixin.IndicatorElement.static.indicator = null;

/**
 * A text string used as the indicator title, a function that returns title text, or `null`
 * for no title. The static property will be overridden if the #indicatorTitle configuration is
 * used.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.IndicatorElement.static.indicatorTitle = null;

/* Methods */

/**
 * Set the indicator element.
 *
 * If an element is already set, it will be cleaned up before setting up the new element.
 *
 * @param {jQuery} $indicator Element to use as indicator
 */
OO.ui.mixin.IndicatorElement.prototype.setIndicatorElement = function ( $indicator ) {
  if ( this.$indicator ) {
    this.$indicator
      .removeClass( 'oo-ui-indicatorElement-indicator oo-ui-indicator-' + this.indicator )
      .removeAttr( 'title' );
  }

  this.$indicator = $indicator
    .addClass( 'oo-ui-indicatorElement-indicator' )
    .toggleClass( 'oo-ui-indicatorElement-noIndicator', !this.indicator )
    .toggleClass( 'oo-ui-indicator-' + this.indicator, !!this.indicator );
  if ( this.indicatorTitle !== null ) {
    this.$indicator.attr( 'title', this.indicatorTitle );
  }

  this.updateThemeClasses();
};

/**
 * Set the indicator by its symbolic name: ‘clear’, ‘down’, ‘required’, ‘search’, ‘up’. Use `null`
 * to remove the indicator.
 *
 * @param {string|null} indicator Symbolic name of indicator, or `null` for no indicator
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.IndicatorElement.prototype.setIndicator = function ( indicator ) {
  indicator = typeof indicator === 'string' && indicator.length ? indicator.trim() : null;

  if ( this.indicator !== indicator ) {
    if ( this.$indicator ) {
      if ( this.indicator !== null ) {
        this.$indicator.removeClass( 'oo-ui-indicator-' + this.indicator );
      }
      if ( indicator !== null ) {
        this.$indicator.addClass( 'oo-ui-indicator-' + indicator );
      }
    }
    this.indicator = indicator;
  }

  this.$element.toggleClass( 'oo-ui-indicatorElement', !!this.indicator );
  if ( this.$indicator ) {
    this.$indicator.toggleClass( 'oo-ui-indicatorElement-noIndicator', !this.indicator );
  }
  this.updateThemeClasses();

  return this;
};

/**
 * Get the symbolic name of the indicator (e.g., ‘clear’ or  ‘down’).
 *
 * @return {string} Symbolic name of indicator
 */
OO.ui.mixin.IndicatorElement.prototype.getIndicator = function () {
  return this.indicator;
};

/**
 * The FlaggedElement class is an attribute mixin, meaning that it is used to add
 * additional functionality to an element created by another class. The class provides
 * a ‘flags’ property assigned the name (or an array of names) of styling flags,
 * which are used to customize the look and feel of a widget to better describe its
 * importance and functionality.
 *
 * The library currently contains the following styling flags for general use:
 *
 * - **progressive**: Progressive styling is applied to convey that the widget will move the user
 *   forward in a process.
 * - **destructive**: Destructive styling is applied to convey that the widget will remove
 *   something.
 *
 * The flags affect the appearance of the buttons:
 *
 *     @example
 *     // FlaggedElement is mixed into ButtonWidget to provide styling flags
 *     var button1 = new OO.ui.ButtonWidget( {
 *             label: 'Progressive',
 *             flags: 'progressive'
 *         } ),
 *         button2 = new OO.ui.ButtonWidget( {
 *             label: 'Destructive',
 *             flags: 'destructive'
 *         } );
 *     $( document.body ).append( button1.$element, button2.$element );
 *
 * {@link OO.ui.ActionWidget ActionWidgets}, which are a special kind of button that execute an
 * action, use these flags: **primary** and **safe**.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Elements/Flagged
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string|string[]} [flags] The name or names of the flags (e.g., 'progressive' or 'primary')
 *  to apply.
 *  Please see the [OOUI documentation on MediaWiki] [2] for more information about available flags.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Elements/Flagged
 * @cfg {jQuery} [$flagged] The flagged element. By default,
 *  the flagged functionality is applied to the element created by the class ($element).
 *  If a different element is specified, the flagged functionality will be applied to it instead.
 */
OO.ui.mixin.FlaggedElement = function OoUiMixinFlaggedElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.flags = {};
  this.$flagged = null;

  // Initialization
  this.setFlags( config.flags || this.constructor.static.flags );
  this.setFlaggedElement( config.$flagged || this.$element );
};

/* Setup */

OO.initClass( OO.ui.mixin.FlaggedElement );

/* Events */

/**
 * @event flag
 * A flag event is emitted when the #clearFlags or #setFlags methods are used. The `changes`
 * parameter contains the name of each modified flag and indicates whether it was
 * added or removed.
 *
 * @param {Object.<string,boolean>} changes Object keyed by flag name. A Boolean `true` indicates
 * that the flag was added, `false` that the flag was removed.
 */

/* Static Properties */

/**
 * Initial value to pass to setFlags if no value is provided in config.
 *
 * @static
 * @inheritable
 * @property {string|string[]|Object.<string, boolean>}
 */
OO.ui.mixin.FlaggedElement.static.flags = null;

/* Methods */

/**
 * Set the flagged element.
 *
 * This method is used to retarget a flagged mixin so that its functionality applies to the
 * specified element.
 * If an element is already set, the method will remove the mixin’s effect on that element.
 *
 * @param {jQuery} $flagged Element that should be flagged
 */
OO.ui.mixin.FlaggedElement.prototype.setFlaggedElement = function ( $flagged ) {
  var classNames = Object.keys( this.flags ).map( function ( flag ) {
    return 'oo-ui-flaggedElement-' + flag;
  } );

  if ( this.$flagged ) {
    this.$flagged.removeClass( classNames );
  }

  this.$flagged = $flagged.addClass( classNames );
};

/**
 * Check if the specified flag is set.
 *
 * @param {string} flag Name of flag
 * @return {boolean} The flag is set
 */
OO.ui.mixin.FlaggedElement.prototype.hasFlag = function ( flag ) {
  // This may be called before the constructor, thus before this.flags is set
  return this.flags && ( flag in this.flags );
};

/**
 * Get the names of all flags set.
 *
 * @return {string[]} Flag names
 */
OO.ui.mixin.FlaggedElement.prototype.getFlags = function () {
  // This may be called before the constructor, thus before this.flags is set
  return Object.keys( this.flags || {} );
};

/**
 * Clear all flags.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 * @fires flag
 */
OO.ui.mixin.FlaggedElement.prototype.clearFlags = function () {
  var flag, className,
    changes = {},
    remove = [],
    classPrefix = 'oo-ui-flaggedElement-';

  for ( flag in this.flags ) {
    className = classPrefix + flag;
    changes[ flag ] = false;
    delete this.flags[ flag ];
    remove.push( className );
  }

  if ( this.$flagged ) {
    this.$flagged.removeClass( remove );
  }

  this.updateThemeClasses();
  this.emit( 'flag', changes );

  return this;
};

/**
 * Add one or more flags.
 *
 * @param {string|string[]|Object.<string, boolean>} flags A flag name, an array of flag names,
 *  or an object keyed by flag name with a boolean value that indicates whether the flag should
 *  be added (`true`) or removed (`false`).
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 * @fires flag
 */
OO.ui.mixin.FlaggedElement.prototype.setFlags = function ( flags ) {
  var i, len, flag, className,
    changes = {},
    add = [],
    remove = [],
    classPrefix = 'oo-ui-flaggedElement-';

  if ( typeof flags === 'string' ) {
    className = classPrefix + flags;
    // Set
    if ( !this.flags[ flags ] ) {
      this.flags[ flags ] = true;
      add.push( className );
    }
  } else if ( Array.isArray( flags ) ) {
    for ( i = 0, len = flags.length; i < len; i++ ) {
      flag = flags[ i ];
      className = classPrefix + flag;
      // Set
      if ( !this.flags[ flag ] ) {
        changes[ flag ] = true;
        this.flags[ flag ] = true;
        add.push( className );
      }
    }
  } else if ( OO.isPlainObject( flags ) ) {
    for ( flag in flags ) {
      className = classPrefix + flag;
      if ( flags[ flag ] ) {
        // Set
        if ( !this.flags[ flag ] ) {
          changes[ flag ] = true;
          this.flags[ flag ] = true;
          add.push( className );
        }
      } else {
        // Remove
        if ( this.flags[ flag ] ) {
          changes[ flag ] = false;
          delete this.flags[ flag ];
          remove.push( className );
        }
      }
    }
  }

  if ( this.$flagged ) {
    this.$flagged
      .addClass( add )
      .removeClass( remove );
  }

  this.updateThemeClasses();
  this.emit( 'flag', changes );

  return this;
};

/**
 * TitledElement is mixed into other classes to provide a `title` attribute.
 * Titles are rendered by the browser and are made visible when the user moves
 * the mouse over the element. Titles are not visible on touch devices.
 *
 *     @example
 *     // TitledElement provides a `title` attribute to the
 *     // ButtonWidget class.
 *     var button = new OO.ui.ButtonWidget( {
 *         label: 'Button with Title',
 *         title: 'I am a button'
 *     } );
 *     $( document.body ).append( button.$element );
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$titled] The element to which the `title` attribute is applied.
 *  If this config is omitted, the title functionality is applied to $element, the
 *  element created by the class.
 * @cfg {string|Function} [title] The title text or a function that returns text. If
 *  this config is omitted, the value of the {@link #static-title static title} property is used.
 */
OO.ui.mixin.TitledElement = function OoUiMixinTitledElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.$titled = null;
  this.title = null;

  // Initialization
  this.setTitle( config.title !== undefined ? config.title : this.constructor.static.title );
  this.setTitledElement( config.$titled || this.$element );
};

/* Setup */

OO.initClass( OO.ui.mixin.TitledElement );

/* Static Properties */

/**
 * The title text, a function that returns text, or `null` for no title. The value of the static
 * property is overridden if the #title config option is used.
 *
 * If the element has a default title (e.g. `<input type=file>`), `null` will allow that title to be
 * shown. Use empty string to suppress it.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.TitledElement.static.title = null;

/* Methods */

/**
 * Set the titled element.
 *
 * This method is used to retarget a TitledElement mixin so that its functionality applies to the
 * specified element.
 * If an element is already set, the mixin’s effect on that element is removed before the new
 * element is set up.
 *
 * @param {jQuery} $titled Element that should use the 'titled' functionality
 */
OO.ui.mixin.TitledElement.prototype.setTitledElement = function ( $titled ) {
  if ( this.$titled ) {
    this.$titled.removeAttr( 'title' );
  }

  this.$titled = $titled;
  this.updateTitle();
};

/**
 * Set title.
 *
 * @param {string|Function|null} title Title text, a function that returns text, or `null`
 *  for no title
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TitledElement.prototype.setTitle = function ( title ) {
  title = typeof title === 'function' ? OO.ui.resolveMsg( title ) : title;
  title = typeof title === 'string' ? title : null;

  if ( this.title !== title ) {
    this.title = title;
    this.updateTitle();
  }

  return this;
};

/**
 * Update the title attribute, in case of changes to title or accessKey.
 *
 * @protected
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.TitledElement.prototype.updateTitle = function () {
  var title = this.getTitle();
  if ( this.$titled ) {
    if ( title !== null ) {
      // Only if this is an AccessKeyedElement
      if ( this.formatTitleWithAccessKey ) {
        title = this.formatTitleWithAccessKey( title );
      }
      this.$titled.attr( 'title', title );
    } else {
      this.$titled.removeAttr( 'title' );
    }
  }
  return this;
};

/**
 * Get title.
 *
 * @return {string} Title string
 */
OO.ui.mixin.TitledElement.prototype.getTitle = function () {
  return this.title;
};

/**
 * AccessKeyedElement is mixed into other classes to provide an `accesskey` HTML attribute.
 * Access keys allow an user to go to a specific element by using
 * a shortcut combination of a browser specific keys + the key
 * set to the field.
 *
 *     @example
 *     // AccessKeyedElement provides an `accesskey` attribute to the
 *     // ButtonWidget class.
 *     var button = new OO.ui.ButtonWidget( {
 *         label: 'Button with access key',
 *         accessKey: 'k'
 *     } );
 *     $( document.body ).append( button.$element );
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$accessKeyed] The element to which the `accesskey` attribute is applied.
 *  If this config is omitted, the access key functionality is applied to $element, the
 *  element created by the class.
 * @cfg {string|Function} [accessKey] The key or a function that returns the key. If
 *  this config is omitted, no access key will be added.
 */
OO.ui.mixin.AccessKeyedElement = function OoUiMixinAccessKeyedElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.$accessKeyed = null;
  this.accessKey = null;

  // Initialization
  this.setAccessKey( config.accessKey || null );
  this.setAccessKeyedElement( config.$accessKeyed || this.$element );

  // If this is also a TitledElement and it initialized before we did, we may have
  // to update the title with the access key
  if ( this.updateTitle ) {
    this.updateTitle();
  }
};

/* Setup */

OO.initClass( OO.ui.mixin.AccessKeyedElement );

/* Static Properties */

/**
 * The access key, a function that returns a key, or `null` for no access key.
 *
 * @static
 * @inheritable
 * @property {string|Function|null}
 */
OO.ui.mixin.AccessKeyedElement.static.accessKey = null;

/* Methods */

/**
 * Set the access keyed element.
 *
 * This method is used to retarget a AccessKeyedElement mixin so that its functionality applies to
 * the specified element.
 * If an element is already set, the mixin's effect on that element is removed before the new
 * element is set up.
 *
 * @param {jQuery} $accessKeyed Element that should use the 'access keyed' functionality
 */
OO.ui.mixin.AccessKeyedElement.prototype.setAccessKeyedElement = function ( $accessKeyed ) {
  if ( this.$accessKeyed ) {
    this.$accessKeyed.removeAttr( 'accesskey' );
  }

  this.$accessKeyed = $accessKeyed;
  if ( this.accessKey ) {
    this.$accessKeyed.attr( 'accesskey', this.accessKey );
  }
};

/**
 * Set access key.
 *
 * @param {string|Function|null} accessKey Key, a function that returns a key, or `null` for no
 *  access key
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.AccessKeyedElement.prototype.setAccessKey = function ( accessKey ) {
  accessKey = typeof accessKey === 'string' ? OO.ui.resolveMsg( accessKey ) : null;

  if ( this.accessKey !== accessKey ) {
    if ( this.$accessKeyed ) {
      if ( accessKey !== null ) {
        this.$accessKeyed.attr( 'accesskey', accessKey );
      } else {
        this.$accessKeyed.removeAttr( 'accesskey' );
      }
    }
    this.accessKey = accessKey;

    // Only if this is a TitledElement
    if ( this.updateTitle ) {
      this.updateTitle();
    }
  }

  return this;
};

/**
 * Get access key.
 *
 * @return {string} accessKey string
 */
OO.ui.mixin.AccessKeyedElement.prototype.getAccessKey = function () {
  return this.accessKey;
};

/**
 * Add information about the access key to the element's tooltip label.
 * (This is only public for hacky usage in FieldLayout.)
 *
 * @param {string} title Tooltip label for `title` attribute
 * @return {string}
 */
OO.ui.mixin.AccessKeyedElement.prototype.formatTitleWithAccessKey = function ( title ) {
  var accessKey;

  if ( !this.$accessKeyed ) {
    // Not initialized yet; the constructor will call updateTitle() which will rerun this
    // function.
    return title;
  }
  // Use jquery.accessKeyLabel if available to show modifiers, otherwise just display the
  // single key.
  if ( $.fn.updateTooltipAccessKeys && $.fn.updateTooltipAccessKeys.getAccessKeyLabel ) {
    accessKey = $.fn.updateTooltipAccessKeys.getAccessKeyLabel( this.$accessKeyed[ 0 ] );
  } else {
    accessKey = this.getAccessKey();
  }
  if ( accessKey ) {
    title += ' [' + accessKey + ']';
  }
  return title;
};

/**
 * ButtonWidget is a generic widget for buttons. A wide variety of looks,
 * feels, and functionality can be customized via the class’s configuration options
 * and methods. Please see the [OOUI documentation on MediaWiki] [1] for more information
 * and examples.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Buttons_and_Switches
 *
 *     @example
 *     // A button widget.
 *     var button = new OO.ui.ButtonWidget( {
 *         label: 'Button with Icon',
 *         icon: 'trash',
 *         title: 'Remove'
 *     } );
 *     $( document.body ).append( button.$element );
 *
 * NOTE: HTML form buttons should use the OO.ui.ButtonInputWidget class.
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.ButtonElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TabIndexedElement
 * @mixins OO.ui.mixin.AccessKeyedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [active=false] Whether button should be shown as active
 * @cfg {string} [href] Hyperlink to visit when the button is clicked.
 * @cfg {string} [target] The frame or window in which to open the hyperlink.
 * @cfg {boolean} [noFollow] Search engine traversal hint (default: true)
 * @cfg {string[]} [rel] Relationship attributes for the hyperlink
 */
OO.ui.ButtonWidget = function OoUiButtonWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.ButtonWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.ButtonElement.call( this, config );
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.IndicatorElement.call( this, config );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.TitledElement.call( this, $.extend( {
    $titled: this.$button
  }, config ) );
  OO.ui.mixin.FlaggedElement.call( this, config );
  OO.ui.mixin.TabIndexedElement.call( this, $.extend( {
    $tabIndexed: this.$button
  }, config ) );
  OO.ui.mixin.AccessKeyedElement.call( this, $.extend( {
    $accessKeyed: this.$button
  }, config ) );

  // Properties
  this.href = null;
  this.target = null;
  this.noFollow = false;
  this.rel = [];

  // Events
  this.connect( this, {
    disable: 'onDisable'
  } );

  // Initialization
  this.$button.append( this.$icon, this.$label, this.$indicator );
  this.$element
    .addClass( 'oo-ui-buttonWidget' )
    .append( this.$button );
  this.setActive( config.active );
  this.setHref( config.href );
  this.setTarget( config.target );
  if ( config.rel ) {
    this.setRel( config.rel );
  } else {
    this.setNoFollow( config.noFollow );
  }
};

/* Setup */

OO.inheritClass( OO.ui.ButtonWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.ButtonElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.TabIndexedElement );
OO.mixinClass( OO.ui.ButtonWidget, OO.ui.mixin.AccessKeyedElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonWidget.static.cancelButtonMouseDownEvents = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonWidget.static.tagName = 'span';

/* Methods */

/**
 * Get hyperlink location.
 *
 * @return {string} Hyperlink location
 */
OO.ui.ButtonWidget.prototype.getHref = function () {
  return this.href;
};

/**
 * Get hyperlink target.
 *
 * @return {string} Hyperlink target
 */
OO.ui.ButtonWidget.prototype.getTarget = function () {
  return this.target;
};

/**
 * Get search engine traversal hint.
 *
 * @return {boolean} Whether search engines should avoid traversing this hyperlink
 */
OO.ui.ButtonWidget.prototype.getNoFollow = function () {
  return this.noFollow;
};

/**
 * Get the relationship attribute of the hyperlink.
 *
 * @return {string[]} Relationship attributes that apply to the hyperlink
 */
OO.ui.ButtonWidget.prototype.getRel = function () {
  return this.rel;
};

/**
 * Set hyperlink location.
 *
 * @param {string|null} href Hyperlink location, null to remove
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonWidget.prototype.setHref = function ( href ) {
  href = typeof href === 'string' ? href : null;
  if ( href !== null && !OO.ui.isSafeUrl( href ) ) {
    href = './' + href;
  }

  if ( href !== this.href ) {
    this.href = href;
    this.updateHref();
  }

  return this;
};

/**
 * Update the `href` attribute, in case of changes to href or
 * disabled state.
 *
 * @private
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonWidget.prototype.updateHref = function () {
  if ( this.href !== null && !this.isDisabled() ) {
    this.$button.attr( 'href', this.href );
  } else {
    this.$button.removeAttr( 'href' );
  }

  return this;
};

/**
 * Handle disable events.
 *
 * @private
 * @param {boolean} disabled Element is disabled
 */
OO.ui.ButtonWidget.prototype.onDisable = function () {
  this.updateHref();
};

/**
 * Set hyperlink target.
 *
 * @param {string|null} target Hyperlink target, null to remove
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonWidget.prototype.setTarget = function ( target ) {
  target = typeof target === 'string' ? target : null;

  if ( target !== this.target ) {
    this.target = target;
    if ( target !== null ) {
      this.$button.attr( 'target', target );
    } else {
      this.$button.removeAttr( 'target' );
    }
  }

  return this;
};

/**
 * Set search engine traversal hint.
 *
 * @param {boolean} noFollow True if search engines should avoid traversing this hyperlink
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonWidget.prototype.setNoFollow = function ( noFollow ) {
  var rel;

  noFollow = typeof noFollow === 'boolean' ? noFollow : true;

  if ( noFollow !== this.noFollow ) {
    if ( !noFollow ) {
      rel = this.rel.concat();
      rel.splice(
        this.rel.indexOf( 'nofollow' ),
        1
      );
      this.setRel( rel );
    } else {
      this.setRel( this.rel.concat( [ 'nofollow' ] ) );
    }
  }

  return this;
};

/**
 * Set the `rel` attribute of the hyperlink.
 *
 * @param {string|string[]} rel Relationship attributes for the hyperlink
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonWidget.prototype.setRel = function ( rel ) {
  rel = Array.isArray( rel ) ? rel : typeof rel === 'string' ? [ rel ] : [];

  if ( rel !== this.rel ) {
    this.rel = rel;
    // For backwards compatibility.
    this.noFollow = rel.indexOf( 'nofollow' ) !== -1;

    if ( rel.length > 0 ) {
      this.$button.attr( 'rel', rel.join( ' ' ) );
    } else {
      this.$button.removeAttr( 'rel' );
    }
  }

  return this;
};

// Override method visibility hints from ButtonElement
/**
 * @method setActive
 * @inheritdoc
 */
/**
 * @method isActive
 * @inheritdoc
 */

/**
 * A ButtonGroupWidget groups related buttons and is used together with OO.ui.ButtonWidget and
 * its subclasses. Each button in a group is addressed by a unique reference. Buttons can be added,
 * removed, and cleared from the group.
 *
 *     @example
 *     // A ButtonGroupWidget with two buttons.
 *     var button1 = new OO.ui.PopupButtonWidget( {
 *             label: 'Select a category',
 *             icon: 'menu',
 *             popup: {
 *                 $content: $( '<p>List of categories…</p>' ),
 *                 padded: true,
 *                 align: 'left'
 *             }
 *         } ),
 *         button2 = new OO.ui.ButtonWidget( {
 *             label: 'Add item'
 *         } ),
 *         buttonGroup = new OO.ui.ButtonGroupWidget( {
 *             items: [ button1, button2 ]
 *         } );
 *     $( document.body ).append( buttonGroup.$element );
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.ButtonWidget[]} [items] Buttons to add
 */
OO.ui.ButtonGroupWidget = function OoUiButtonGroupWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.ButtonGroupWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.GroupElement.call( this, $.extend( {
    $group: this.$element
  }, config ) );
  OO.ui.mixin.TitledElement.call( this, config );

  // Initialization
  this.$element.addClass( 'oo-ui-buttonGroupWidget' );
  if ( Array.isArray( config.items ) ) {
    this.addItems( config.items );
  }
};

/* Setup */

OO.inheritClass( OO.ui.ButtonGroupWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.ButtonGroupWidget, OO.ui.mixin.GroupElement );
OO.mixinClass( OO.ui.ButtonGroupWidget, OO.ui.mixin.TitledElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonGroupWidget.static.tagName = 'span';

/* Methods */

/**
 * Focus the widget
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonGroupWidget.prototype.focus = function () {
  if ( !this.isDisabled() ) {
    if ( this.items[ 0 ] ) {
      this.items[ 0 ].focus();
    }
  }
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.ButtonGroupWidget.prototype.simulateLabelClick = function () {
  this.focus();
};

/**
 * IconWidget is a generic widget for {@link OO.ui.mixin.IconElement icons}.
 * In general, IconWidgets should be used with OO.ui.LabelWidget, which creates a label that
 * identifies the icon’s function. See the [OOUI documentation on MediaWiki] [1]
 * for a list of icons included in the library.
 *
 *     @example
 *     // An IconWidget with a label via LabelWidget.
 *     var myIcon = new OO.ui.IconWidget( {
 *             icon: 'help',
 *             title: 'Help'
 *          } ),
 *          // Create a label.
 *          iconLabel = new OO.ui.LabelWidget( {
 *              label: 'Help'
 *          } );
 *      $( document.body ).append( myIcon.$element, iconLabel.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Icons
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.IconWidget = function OoUiIconWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.IconWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.IconElement.call( this, $.extend( {
    $icon: this.$element
  }, config ) );
  OO.ui.mixin.TitledElement.call( this, $.extend( {
    $titled: this.$element
  }, config ) );
  OO.ui.mixin.LabelElement.call( this, $.extend( {
    $label: this.$element,
    invisibleLabel: true
  }, config ) );
  OO.ui.mixin.FlaggedElement.call( this, $.extend( {
    $flagged: this.$element
  }, config ) );

  // Initialization
  this.$element.addClass( 'oo-ui-iconWidget' );
  // Remove class added by LabelElement initialization. It causes unexpected CSS to apply when
  // nested in other widgets, because this widget used to not mix in LabelElement.
  this.$element.removeClass( 'oo-ui-labelElement-label' );
};

/* Setup */

OO.inheritClass( OO.ui.IconWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.IconWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.IconWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.IconWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.IconWidget, OO.ui.mixin.FlaggedElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.IconWidget.static.tagName = 'span';

/**
 * IndicatorWidgets create indicators, which are small graphics that are generally used to draw
 * attention to the status of an item or to clarify the function within a control. For a list of
 * indicators included in the library, please see the [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // An indicator widget.
 *     var indicator1 = new OO.ui.IndicatorWidget( {
 *             indicator: 'required'
 *         } ),
 *         // Create a fieldset layout to add a label.
 *         fieldset = new OO.ui.FieldsetLayout();
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( indicator1, {
 *             label: 'A required indicator:'
 *         } )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Icons,_Indicators,_and_Labels#Indicators
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.LabelElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.IndicatorWidget = function OoUiIndicatorWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.IndicatorWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.IndicatorElement.call( this, $.extend( {
    $indicator: this.$element
  }, config ) );
  OO.ui.mixin.TitledElement.call( this, $.extend( {
    $titled: this.$element
  }, config ) );
  OO.ui.mixin.LabelElement.call( this, $.extend( {
    $label: this.$element,
    invisibleLabel: true
  }, config ) );

  // Initialization
  this.$element.addClass( 'oo-ui-indicatorWidget' );
  // Remove class added by LabelElement initialization. It causes unexpected CSS to apply when
  // nested in other widgets, because this widget used to not mix in LabelElement.
  this.$element.removeClass( 'oo-ui-labelElement-label' );
};

/* Setup */

OO.inheritClass( OO.ui.IndicatorWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.IndicatorWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.IndicatorWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.IndicatorWidget, OO.ui.mixin.LabelElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.IndicatorWidget.static.tagName = 'span';

/**
 * LabelWidgets help identify the function of interface elements. Each LabelWidget can
 * be configured with a `label` option that is set to a string, a label node, or a function:
 *
 * - String: a plaintext string
 * - jQuery selection: a jQuery selection, used for anything other than a plaintext label, e.g., a
 *   label that includes a link or special styling, such as a gray color or additional
 *   graphical elements.
 * - Function: a function that will produce a string in the future. Functions are used
 *   in cases where the value of the label is not currently defined.
 *
 * In addition, the LabelWidget can be associated with an {@link OO.ui.InputWidget input widget},
 * which will come into focus when the label is clicked.
 *
 *     @example
 *     // Two LabelWidgets.
 *     var label1 = new OO.ui.LabelWidget( {
 *             label: 'plaintext label'
 *         } ),
 *         label2 = new OO.ui.LabelWidget( {
 *             label: $( '<a>' ).attr( 'href', 'default.html' ).text( 'jQuery label' )
 *         } ),
 *         // Create a fieldset layout with fields for each example.
 *         fieldset = new OO.ui.FieldsetLayout();
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( label1 ),
 *         new OO.ui.FieldLayout( label2 )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.InputWidget} [input] {@link OO.ui.InputWidget Input widget} that uses the label.
 *  Clicking the label will focus the specified input field.
 */
OO.ui.LabelWidget = function OoUiLabelWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.LabelWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.LabelElement.call( this, $.extend( {
    $label: this.$element
  }, config ) );
  OO.ui.mixin.TitledElement.call( this, config );

  // Properties
  this.input = config.input;

  // Initialization
  if ( this.input ) {
    if ( this.input.getInputId() ) {
      this.$element.attr( 'for', this.input.getInputId() );
    } else {
      this.$label.on( 'click', function () {
        this.input.simulateLabelClick();
      }.bind( this ) );
    }
  }
  this.$element.addClass( 'oo-ui-labelWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.LabelWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.LabelWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.LabelWidget, OO.ui.mixin.TitledElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.LabelWidget.static.tagName = 'label';

/**
 * MessageWidget produces a visual component for sending a notice to the user
 * with an icon and distinct design noting its purpose. The MessageWidget changes
 * its visual presentation based on the type chosen, which also denotes its UX
 * purpose.
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.FlaggedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [type='notice'] The type of the notice widget. This will also
 *  impact the flags that the widget receives (and hence its CSS design) as well
 *  as the icon that appears. Available types:
 *  'notice', 'error', 'warning', 'success'
 * @cfg {boolean} [inline] Set the notice as an inline notice. The default
 *  is not inline, or 'boxed' style.
 */
OO.ui.MessageWidget = function OoUiMessageWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.MessageWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.TitledElement.call( this, config );
  OO.ui.mixin.FlaggedElement.call( this, config );

  // Set type
  this.setType( config.type );
  this.setInline( config.inline );

  // Build the widget
  this.$element
    .append( this.$icon, this.$label )
    .addClass( 'oo-ui-messageWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.MessageWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.MessageWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.MessageWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.MessageWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.MessageWidget, OO.ui.mixin.FlaggedElement );

/* Static Properties */

/**
 * An object defining the icon name per defined type.
 *
 * @static
 * @property {Object}
 */
OO.ui.MessageWidget.static.iconMap = {
  notice: 'infoFilled',
  error: 'error',
  warning: 'alert',
  success: 'check'
};

/* Methods */

/**
 * Set the inline state of the widget.
 *
 * @param {boolean} inline Widget is inline
 */
OO.ui.MessageWidget.prototype.setInline = function ( inline ) {
  inline = !!inline;

  if ( this.inline !== inline ) {
    this.inline = inline;
    this.$element
      .toggleClass( 'oo-ui-messageWidget-block', !this.inline );
  }
};
/**
 * Set the widget type. The given type must belong to the list of
 * legal types set by OO.ui.MessageWidget.static.iconMap
 *
 * @param  {string} [type] Given type. Defaults to 'notice'
 */
OO.ui.MessageWidget.prototype.setType = function ( type ) {
  // Validate type
  if ( Object.keys( this.constructor.static.iconMap ).indexOf( type ) === -1 ) {
    type = 'notice'; // Default
  }

  if ( this.type !== type ) {

    // Flags
    this.clearFlags();
    this.setFlags( type );

    // Set the icon and its variant
    this.setIcon( this.constructor.static.iconMap[ type ] );
    this.$icon.removeClass( 'oo-ui-image-' + this.type );
    this.$icon.addClass( 'oo-ui-image-' + type );

    if ( type === 'error' ) {
      this.$element.attr( 'role', 'alert' );
      this.$element.removeAttr( 'aria-live' );
    } else {
      this.$element.removeAttr( 'role' );
      this.$element.attr( 'aria-live', 'polite' );
    }

    this.type = type;
  }
};

/**
 * PendingElement is a mixin that is used to create elements that notify users that something is
 * happening and that they should wait before proceeding. The pending state is visually represented
 * with a pending texture that appears in the head of a pending
 * {@link OO.ui.ProcessDialog process dialog} or in the input field of a
 * {@link OO.ui.TextInputWidget text input widget}.
 *
 * Currently, {@link OO.ui.ActionWidget Action widgets}, which mix in this class, can also be marked
 * as pending, but only when used in {@link OO.ui.MessageDialog message dialogs}. The behavior is
 * not currently supported for action widgets used in process dialogs.
 *
 *     @example
 *     function MessageDialog( config ) {
 *         MessageDialog.super.call( this, config );
 *     }
 *     OO.inheritClass( MessageDialog, OO.ui.MessageDialog );
 *
 *     MessageDialog.static.name = 'myMessageDialog';
 *     MessageDialog.static.actions = [
 *         { action: 'save', label: 'Done', flags: 'primary' },
 *         { label: 'Cancel', flags: 'safe' }
 *     ];
 *
 *     MessageDialog.prototype.initialize = function () {
 *         MessageDialog.super.prototype.initialize.apply( this, arguments );
 *         this.content = new OO.ui.PanelLayout( { padded: true } );
 *         this.content.$element.append( '<p>Click the \'Done\' action widget to see its pending ' +
 *             'state. Note that action widgets can be marked pending in message dialogs but not ' +
 *             'process dialogs.</p>' );
 *         this.$body.append( this.content.$element );
 *     };
 *     MessageDialog.prototype.getBodyHeight = function () {
 *         return 100;
 *     }
 *     MessageDialog.prototype.getActionProcess = function ( action ) {
 *         var dialog = this;
 *         if ( action === 'save' ) {
 *             dialog.getActions().get({actions: 'save'})[0].pushPending();
 *             return new OO.ui.Process()
 *             .next( 1000 )
 *             .next( function () {
 *                 dialog.getActions().get({actions: 'save'})[0].popPending();
 *             } );
 *         }
 *         return MessageDialog.super.prototype.getActionProcess.call( this, action );
 *     };
 *
 *     var windowManager = new OO.ui.WindowManager();
 *     $( document.body ).append( windowManager.$element );
 *
 *     var dialog = new MessageDialog();
 *     windowManager.addWindows( [ dialog ] );
 *     windowManager.openWindow( dialog );
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$pending] Element to mark as pending, defaults to this.$element
 */
OO.ui.mixin.PendingElement = function OoUiMixinPendingElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.pending = 0;
  this.$pending = null;

  // Initialisation
  this.setPendingElement( config.$pending || this.$element );
};

/* Setup */

OO.initClass( OO.ui.mixin.PendingElement );

/* Methods */

/**
 * Set the pending element (and clean up any existing one).
 *
 * @param {jQuery} $pending The element to set to pending.
 */
OO.ui.mixin.PendingElement.prototype.setPendingElement = function ( $pending ) {
  if ( this.$pending ) {
    this.$pending.removeClass( 'oo-ui-pendingElement-pending' );
  }

  this.$pending = $pending;
  if ( this.pending > 0 ) {
    this.$pending.addClass( 'oo-ui-pendingElement-pending' );
  }
};

/**
 * Check if an element is pending.
 *
 * @return {boolean} Element is pending
 */
OO.ui.mixin.PendingElement.prototype.isPending = function () {
  return !!this.pending;
};

/**
 * Increase the pending counter. The pending state will remain active until the counter is zero
 * (i.e., the number of calls to #pushPending and #popPending is the same).
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.PendingElement.prototype.pushPending = function () {
  if ( this.pending === 0 ) {
    this.$pending.addClass( 'oo-ui-pendingElement-pending' );
    this.updateThemeClasses();
  }
  this.pending++;

  return this;
};

/**
 * Decrease the pending counter. The pending state will remain active until the counter is zero
 * (i.e., the number of calls to #pushPending and #popPending is the same).
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.PendingElement.prototype.popPending = function () {
  if ( this.pending === 1 ) {
    this.$pending.removeClass( 'oo-ui-pendingElement-pending' );
    this.updateThemeClasses();
  }
  this.pending = Math.max( 0, this.pending - 1 );

  return this;
};

/**
 * Element that will stick adjacent to a specified container, even when it is inserted elsewhere
 * in the document (for example, in an OO.ui.Window's $overlay).
 *
 * The elements's position is automatically calculated and maintained when window is resized or the
 * page is scrolled. If you reposition the container manually, you have to call #position to make
 * sure the element is still placed correctly.
 *
 * As positioning is only possible when both the element and the container are attached to the DOM
 * and visible, it's only done after you call #togglePositioning. You might want to do this inside
 * the #toggle method to display a floating popup, for example.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$floatable] Node to position, assigned to #$floatable, omit to use #$element
 * @cfg {jQuery} [$floatableContainer] Node to position adjacent to
 * @cfg {string} [verticalPosition='below'] Where to position $floatable vertically:
 *  'below': Directly below $floatableContainer, aligning f's top edge with fC's bottom edge
 *  'above': Directly above $floatableContainer, aligning f's bottom edge with fC's top edge
 *  'top': Align the top edge with $floatableContainer's top edge
 *  'bottom': Align the bottom edge with $floatableContainer's bottom edge
 *  'center': Vertically align the center with $floatableContainer's center
 * @cfg {string} [horizontalPosition='start'] Where to position $floatable horizontally:
 *  'before': Directly before $floatableContainer, aligning f's end edge with fC's start edge
 *  'after': Directly after $floatableContainer, aligning f's start edge with fC's end edge
 *  'start': Align the start (left in LTR, right in RTL) edge with $floatableContainer's start edge
 *  'end': Align the end (right in LTR, left in RTL) edge with $floatableContainer's end edge
 *  'center': Horizontally align the center with $floatableContainer's center
 * @cfg {boolean} [hideWhenOutOfView=true] Whether to hide the floatable element if the container
 *  is out of view
 */
OO.ui.mixin.FloatableElement = function OoUiMixinFloatableElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.$floatable = null;
  this.$floatableContainer = null;
  this.$floatableWindow = null;
  this.$floatableClosestScrollable = null;
  this.floatableOutOfView = false;
  this.onFloatableScrollHandler = this.position.bind( this );
  this.onFloatableWindowResizeHandler = this.position.bind( this );

  // Initialization
  this.setFloatableContainer( config.$floatableContainer );
  this.setFloatableElement( config.$floatable || this.$element );
  this.setVerticalPosition( config.verticalPosition || 'below' );
  this.setHorizontalPosition( config.horizontalPosition || 'start' );
  this.hideWhenOutOfView = config.hideWhenOutOfView === undefined ?
    true : !!config.hideWhenOutOfView;
};

/* Methods */

/**
 * Set floatable element.
 *
 * If an element is already set, it will be cleaned up before setting up the new element.
 *
 * @param {jQuery} $floatable Element to make floatable
 */
OO.ui.mixin.FloatableElement.prototype.setFloatableElement = function ( $floatable ) {
  if ( this.$floatable ) {
    this.$floatable.removeClass( 'oo-ui-floatableElement-floatable' );
    this.$floatable.css( { left: '', top: '' } );
  }

  this.$floatable = $floatable.addClass( 'oo-ui-floatableElement-floatable' );
  this.position();
};

/**
 * Set floatable container.
 *
 * The element will be positioned relative to the specified container.
 *
 * @param {jQuery|null} $floatableContainer Container to keep visible, or null to unset
 */
OO.ui.mixin.FloatableElement.prototype.setFloatableContainer = function ( $floatableContainer ) {
  this.$floatableContainer = $floatableContainer;
  if ( this.$floatable ) {
    this.position();
  }
};

/**
 * Change how the element is positioned vertically.
 *
 * @param {string} position 'below', 'above', 'top', 'bottom' or 'center'
 */
OO.ui.mixin.FloatableElement.prototype.setVerticalPosition = function ( position ) {
  if ( [ 'below', 'above', 'top', 'bottom', 'center' ].indexOf( position ) === -1 ) {
    throw new Error( 'Invalid value for vertical position: ' + position );
  }
  if ( this.verticalPosition !== position ) {
    this.verticalPosition = position;
    if ( this.$floatable ) {
      this.position();
    }
  }
};

/**
 * Change how the element is positioned horizontally.
 *
 * @param {string} position 'before', 'after', 'start', 'end' or 'center'
 */
OO.ui.mixin.FloatableElement.prototype.setHorizontalPosition = function ( position ) {
  if ( [ 'before', 'after', 'start', 'end', 'center' ].indexOf( position ) === -1 ) {
    throw new Error( 'Invalid value for horizontal position: ' + position );
  }
  if ( this.horizontalPosition !== position ) {
    this.horizontalPosition = position;
    if ( this.$floatable ) {
      this.position();
    }
  }
};

/**
 * Toggle positioning.
 *
 * Do not turn positioning on until after the element is attached to the DOM and visible.
 *
 * @param {boolean} [positioning] Enable positioning, omit to toggle
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.FloatableElement.prototype.togglePositioning = function ( positioning ) {
  var closestScrollableOfContainer;

  if ( !this.$floatable || !this.$floatableContainer ) {
    return this;
  }

  positioning = positioning === undefined ? !this.positioning : !!positioning;

  if ( positioning && !this.warnedUnattached && !this.isElementAttached() ) {
    OO.ui.warnDeprecation( 'FloatableElement#togglePositioning: Before calling this method, the element must be attached to the DOM.' );
    this.warnedUnattached = true;
  }

  if ( this.positioning !== positioning ) {
    this.positioning = positioning;

    closestScrollableOfContainer = OO.ui.Element.static.getClosestScrollableContainer(
      this.$floatableContainer[ 0 ]
    );
    // If the scrollable is the root, we have to listen to scroll events
    // on the window because of browser inconsistencies.
    if ( $( closestScrollableOfContainer ).is( 'html, body' ) ) {
      closestScrollableOfContainer = OO.ui.Element.static.getWindow(
        closestScrollableOfContainer
      );
    }

    if ( positioning ) {
      this.$floatableWindow = $( this.getElementWindow() );
      this.$floatableWindow.on( 'resize', this.onFloatableWindowResizeHandler );

      this.$floatableClosestScrollable = $( closestScrollableOfContainer );
      this.$floatableClosestScrollable.on( 'scroll', this.onFloatableScrollHandler );

      // Initial position after visible
      this.position();
    } else {
      if ( this.$floatableWindow ) {
        this.$floatableWindow.off( 'resize', this.onFloatableWindowResizeHandler );
        this.$floatableWindow = null;
      }

      if ( this.$floatableClosestScrollable ) {
        this.$floatableClosestScrollable.off( 'scroll', this.onFloatableScrollHandler );
        this.$floatableClosestScrollable = null;
      }

      this.$floatable.css( { left: '', right: '', top: '' } );
    }
  }

  return this;
};

/**
 * Check whether the bottom edge of the given element is within the viewport of the given
 * container.
 *
 * @private
 * @param {jQuery} $element
 * @param {jQuery} $container
 * @return {boolean}
 */
OO.ui.mixin.FloatableElement.prototype.isElementInViewport = function ( $element, $container ) {
  var elemRect, contRect, topEdgeInBounds, bottomEdgeInBounds, leftEdgeInBounds,
    rightEdgeInBounds, startEdgeInBounds, endEdgeInBounds, viewportSpacing,
    direction = $element.css( 'direction' );

  elemRect = $element[ 0 ].getBoundingClientRect();
  if ( $container[ 0 ] === window ) {
    viewportSpacing = OO.ui.getViewportSpacing();
    contRect = {
      top: 0,
      left: 0,
      right: document.documentElement.clientWidth,
      bottom: document.documentElement.clientHeight
    };
    contRect.top += viewportSpacing.top;
    contRect.left += viewportSpacing.left;
    contRect.right -= viewportSpacing.right;
    contRect.bottom -= viewportSpacing.bottom;
  } else {
    contRect = $container[ 0 ].getBoundingClientRect();
  }

  topEdgeInBounds = elemRect.top >= contRect.top && elemRect.top <= contRect.bottom;
  bottomEdgeInBounds = elemRect.bottom >= contRect.top && elemRect.bottom <= contRect.bottom;
  leftEdgeInBounds = elemRect.left >= contRect.left && elemRect.left <= contRect.right;
  rightEdgeInBounds = elemRect.right >= contRect.left && elemRect.right <= contRect.right;
  if ( direction === 'rtl' ) {
    startEdgeInBounds = rightEdgeInBounds;
    endEdgeInBounds = leftEdgeInBounds;
  } else {
    startEdgeInBounds = leftEdgeInBounds;
    endEdgeInBounds = rightEdgeInBounds;
  }

  if ( this.verticalPosition === 'below' && !bottomEdgeInBounds ) {
    return false;
  }
  if ( this.verticalPosition === 'above' && !topEdgeInBounds ) {
    return false;
  }
  if ( this.horizontalPosition === 'before' && !startEdgeInBounds ) {
    return false;
  }
  if ( this.horizontalPosition === 'after' && !endEdgeInBounds ) {
    return false;
  }

  // The other positioning values are all about being inside the container,
  // so in those cases all we care about is that any part of the container is visible.
  return elemRect.top <= contRect.bottom && elemRect.bottom >= contRect.top &&
    elemRect.left <= contRect.right && elemRect.right >= contRect.left;
};

/**
 * Check if the floatable is hidden to the user because it was offscreen.
 *
 * @return {boolean} Floatable is out of view
 */
OO.ui.mixin.FloatableElement.prototype.isFloatableOutOfView = function () {
  return this.floatableOutOfView;
};

/**
 * Position the floatable below its container.
 *
 * This should only be done when both of them are attached to the DOM and visible.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.FloatableElement.prototype.position = function () {
  if ( !this.positioning ) {
    return this;
  }

  if ( !(
    // To continue, some things need to be true:
    // The element must actually be in the DOM
    this.isElementAttached() && (
      // The closest scrollable is the current window
      this.$floatableClosestScrollable[ 0 ] === this.getElementWindow() ||
      // OR is an element in the element's DOM
      $.contains( this.getElementDocument(), this.$floatableClosestScrollable[ 0 ] )
    )
  ) ) {
    // Abort early if important parts of the widget are no longer attached to the DOM
    return this;
  }

  this.floatableOutOfView = this.hideWhenOutOfView &&
    !this.isElementInViewport( this.$floatableContainer, this.$floatableClosestScrollable );
  if ( this.floatableOutOfView ) {
    this.$floatable.addClass( 'oo-ui-element-hidden' );
    return this;
  } else {
    this.$floatable.removeClass( 'oo-ui-element-hidden' );
  }

  this.$floatable.css( this.computePosition() );

  // We updated the position, so re-evaluate the clipping state.
  // (ClippableElement does not listen to 'scroll' events on $floatableContainer's parent, and so
  // will not notice the need to update itself.)
  // TODO: This is terrible, we shouldn't need to know about ClippableElement at all here.
  // Why does it not listen to the right events in the right places?
  if ( this.clip ) {
    this.clip();
  }

  return this;
};

/**
 * Compute how #$floatable should be positioned based on the position of #$floatableContainer
 * and the positioning settings. This is a helper for #position that shouldn't be called directly,
 * but may be overridden by subclasses if they want to change or add to the positioning logic.
 *
 * @return {Object} New position to apply with .css(). Keys are 'top', 'left', 'bottom' and 'right'.
 */
OO.ui.mixin.FloatableElement.prototype.computePosition = function () {
  var isBody, scrollableX, scrollableY, containerPos,
    horizScrollbarHeight, vertScrollbarWidth, scrollTop, scrollLeft,
    newPos = { top: '', left: '', bottom: '', right: '' },
    direction = this.$floatableContainer.css( 'direction' ),
    $offsetParent = this.$floatable.offsetParent();

  if ( $offsetParent.is( 'html' ) ) {
    // The innerHeight/Width and clientHeight/Width calculations don't work well on the
    // <html> element, but they do work on the <body>
    $offsetParent = $( $offsetParent[ 0 ].ownerDocument.body );
  }
  isBody = $offsetParent.is( 'body' );
  scrollableX = $offsetParent.css( 'overflow-x' ) === 'scroll' ||
    $offsetParent.css( 'overflow-x' ) === 'auto';
  scrollableY = $offsetParent.css( 'overflow-y' ) === 'scroll' ||
    $offsetParent.css( 'overflow-y' ) === 'auto';

  vertScrollbarWidth = $offsetParent.innerWidth() - $offsetParent.prop( 'clientWidth' );
  horizScrollbarHeight = $offsetParent.innerHeight() - $offsetParent.prop( 'clientHeight' );
  // We don't need to compute and add scrollTop and scrollLeft if the scrollable container
  // is the body, or if it isn't scrollable
  scrollTop = scrollableY && !isBody ?
    $offsetParent.scrollTop() : 0;
  scrollLeft = scrollableX && !isBody ?
    OO.ui.Element.static.getScrollLeft( $offsetParent[ 0 ] ) : 0;

  // Avoid passing the <body> to getRelativePosition(), because it won't return what we expect
  // if the <body> has a margin
  containerPos = isBody ?
    this.$floatableContainer.offset() :
    OO.ui.Element.static.getRelativePosition( this.$floatableContainer, $offsetParent );
  containerPos.bottom = containerPos.top + this.$floatableContainer.outerHeight();
  containerPos.right = containerPos.left + this.$floatableContainer.outerWidth();
  containerPos.start = direction === 'rtl' ? containerPos.right : containerPos.left;
  containerPos.end = direction === 'rtl' ? containerPos.left : containerPos.right;

  if ( this.verticalPosition === 'below' ) {
    newPos.top = containerPos.bottom;
  } else if ( this.verticalPosition === 'above' ) {
    newPos.bottom = $offsetParent.outerHeight() - containerPos.top;
  } else if ( this.verticalPosition === 'top' ) {
    newPos.top = containerPos.top;
  } else if ( this.verticalPosition === 'bottom' ) {
    newPos.bottom = $offsetParent.outerHeight() - containerPos.bottom;
  } else if ( this.verticalPosition === 'center' ) {
    newPos.top = containerPos.top +
      ( this.$floatableContainer.height() - this.$floatable.height() ) / 2;
  }

  if ( this.horizontalPosition === 'before' ) {
    newPos.end = containerPos.start;
  } else if ( this.horizontalPosition === 'after' ) {
    newPos.start = containerPos.end;
  } else if ( this.horizontalPosition === 'start' ) {
    newPos.start = containerPos.start;
  } else if ( this.horizontalPosition === 'end' ) {
    newPos.end = containerPos.end;
  } else if ( this.horizontalPosition === 'center' ) {
    newPos.left = containerPos.left +
      ( this.$floatableContainer.width() - this.$floatable.width() ) / 2;
  }

  if ( newPos.start !== undefined ) {
    if ( direction === 'rtl' ) {
      newPos.right = ( isBody ? $( $offsetParent[ 0 ].ownerDocument.documentElement ) :
        $offsetParent ).outerWidth() - newPos.start;
    } else {
      newPos.left = newPos.start;
    }
    delete newPos.start;
  }
  if ( newPos.end !== undefined ) {
    if ( direction === 'rtl' ) {
      newPos.left = newPos.end;
    } else {
      newPos.right = ( isBody ? $( $offsetParent[ 0 ].ownerDocument.documentElement ) :
        $offsetParent ).outerWidth() - newPos.end;
    }
    delete newPos.end;
  }

  // Account for scroll position
  if ( newPos.top !== '' ) {
    newPos.top += scrollTop;
  }
  if ( newPos.bottom !== '' ) {
    newPos.bottom -= scrollTop;
  }
  if ( newPos.left !== '' ) {
    newPos.left += scrollLeft;
  }
  if ( newPos.right !== '' ) {
    newPos.right -= scrollLeft;
  }

  // Account for scrollbar gutter
  if ( newPos.bottom !== '' ) {
    newPos.bottom -= horizScrollbarHeight;
  }
  if ( direction === 'rtl' ) {
    if ( newPos.left !== '' ) {
      newPos.left -= vertScrollbarWidth;
    }
  } else {
    if ( newPos.right !== '' ) {
      newPos.right -= vertScrollbarWidth;
    }
  }

  return newPos;
};

/**
 * Element that can be automatically clipped to visible boundaries.
 *
 * Whenever the element's natural height changes, you have to call
 * {@link OO.ui.mixin.ClippableElement#clip} to make sure it's still
 * clipping correctly.
 *
 * The dimensions of #$clippableContainer will be compared to the boundaries of the
 * nearest scrollable container. If #$clippableContainer is too tall and/or too wide,
 * then #$clippable will be given a fixed reduced height and/or width and will be made
 * scrollable. By default, #$clippable and #$clippableContainer are the same element,
 * but you can build a static footer by setting #$clippableContainer to an element that contains
 * #$clippable and the footer.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$clippable] Node to clip, assigned to #$clippable, omit to use #$element
 * @cfg {jQuery} [$clippableContainer] Node to keep visible, assigned to #$clippableContainer,
 *   omit to use #$clippable
 */
OO.ui.mixin.ClippableElement = function OoUiMixinClippableElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.$clippable = null;
  this.$clippableContainer = null;
  this.clipping = false;
  this.clippedHorizontally = false;
  this.clippedVertically = false;
  this.$clippableScrollableContainer = null;
  this.$clippableScroller = null;
  this.$clippableWindow = null;
  this.idealWidth = null;
  this.idealHeight = null;
  this.onClippableScrollHandler = this.clip.bind( this );
  this.onClippableWindowResizeHandler = this.clip.bind( this );

  // Initialization
  if ( config.$clippableContainer ) {
    this.setClippableContainer( config.$clippableContainer );
  }
  this.setClippableElement( config.$clippable || this.$element );
};

/* Methods */

/**
 * Set clippable element.
 *
 * If an element is already set, it will be cleaned up before setting up the new element.
 *
 * @param {jQuery} $clippable Element to make clippable
 */
OO.ui.mixin.ClippableElement.prototype.setClippableElement = function ( $clippable ) {
  if ( this.$clippable ) {
    this.$clippable.removeClass( 'oo-ui-clippableElement-clippable' );
    this.$clippable.css( { width: '', height: '', overflowX: '', overflowY: '' } );
    OO.ui.Element.static.reconsiderScrollbars( this.$clippable[ 0 ] );
  }

  this.$clippable = $clippable.addClass( 'oo-ui-clippableElement-clippable' );
  this.clip();
};

/**
 * Set clippable container.
 *
 * This is the container that will be measured when deciding whether to clip. When clipping,
 * #$clippable will be resized in order to keep the clippable container fully visible.
 *
 * If the clippable container is unset, #$clippable will be used.
 *
 * @param {jQuery|null} $clippableContainer Container to keep visible, or null to unset
 */
OO.ui.mixin.ClippableElement.prototype.setClippableContainer = function ( $clippableContainer ) {
  this.$clippableContainer = $clippableContainer;
  if ( this.$clippable ) {
    this.clip();
  }
};

/**
 * Toggle clipping.
 *
 * Do not turn clipping on until after the element is attached to the DOM and visible.
 *
 * @param {boolean} [clipping] Enable clipping, omit to toggle
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.ClippableElement.prototype.toggleClipping = function ( clipping ) {
  clipping = clipping === undefined ? !this.clipping : !!clipping;

  if ( clipping && !this.warnedUnattached && !this.isElementAttached() ) {
    OO.ui.warnDeprecation( 'ClippableElement#toggleClipping: Before calling this method, the element must be attached to the DOM.' );
    this.warnedUnattached = true;
  }

  if ( this.clipping !== clipping ) {
    this.clipping = clipping;
    if ( clipping ) {
      this.$clippableScrollableContainer = $( this.getClosestScrollableElementContainer() );
      // If the clippable container is the root, we have to listen to scroll events and check
      // jQuery.scrollTop on the window because of browser inconsistencies
      this.$clippableScroller = this.$clippableScrollableContainer.is( 'html, body' ) ?
        $( OO.ui.Element.static.getWindow( this.$clippableScrollableContainer ) ) :
        this.$clippableScrollableContainer;
      this.$clippableScroller.on( 'scroll', this.onClippableScrollHandler );
      this.$clippableWindow = $( this.getElementWindow() )
        .on( 'resize', this.onClippableWindowResizeHandler );
      // Initial clip after visible
      this.clip();
    } else {
      this.$clippable.css( {
        width: '',
        height: '',
        maxWidth: '',
        maxHeight: '',
        overflowX: '',
        overflowY: ''
      } );
      OO.ui.Element.static.reconsiderScrollbars( this.$clippable[ 0 ] );

      this.$clippableScrollableContainer = null;
      this.$clippableScroller.off( 'scroll', this.onClippableScrollHandler );
      this.$clippableScroller = null;
      this.$clippableWindow.off( 'resize', this.onClippableWindowResizeHandler );
      this.$clippableWindow = null;
    }
  }

  return this;
};

/**
 * Check if the element will be clipped to fit the visible area of the nearest scrollable container.
 *
 * @return {boolean} Element will be clipped to the visible area
 */
OO.ui.mixin.ClippableElement.prototype.isClipping = function () {
  return this.clipping;
};

/**
 * Check if the bottom or right of the element is being clipped by the nearest scrollable container.
 *
 * @return {boolean} Part of the element is being clipped
 */
OO.ui.mixin.ClippableElement.prototype.isClipped = function () {
  return this.clippedHorizontally || this.clippedVertically;
};

/**
 * Check if the right of the element is being clipped by the nearest scrollable container.
 *
 * @return {boolean} Part of the element is being clipped
 */
OO.ui.mixin.ClippableElement.prototype.isClippedHorizontally = function () {
  return this.clippedHorizontally;
};

/**
 * Check if the bottom of the element is being clipped by the nearest scrollable container.
 *
 * @return {boolean} Part of the element is being clipped
 */
OO.ui.mixin.ClippableElement.prototype.isClippedVertically = function () {
  return this.clippedVertically;
};

/**
 * Set the ideal size. These are the dimensions #$clippable will have when it's not being clipped.
 *
 * @param {number|string} [width] Width as a number of pixels or CSS string with unit suffix
 * @param {number|string} [height] Height as a number of pixels or CSS string with unit suffix
 */
OO.ui.mixin.ClippableElement.prototype.setIdealSize = function ( width, height ) {
  this.idealWidth = width;
  this.idealHeight = height;

  if ( !this.clipping ) {
    // Update dimensions
    this.$clippable.css( { width: width, height: height } );
  }
  // While clipping, idealWidth and idealHeight are not considered
};

/**
 * Return the side of the clippable on which it is "anchored" (aligned to something else).
 * ClippableElement will clip the opposite side when reducing element's width.
 *
 * Classes that mix in ClippableElement should override this to return 'right' if their
 * clippable is absolutely positioned and using 'right: Npx' (and not using 'left').
 * If your class also mixes in FloatableElement, this is handled automatically.
 *
 * (This can't be guessed from the actual CSS because the computed values for 'left'/'right' are
 * always in pixels, even if they were unset or set to 'auto'.)
 *
 * When in doubt, 'left' (or 'right' in RTL) is a sane fallback.
 *
 * @return {string} 'left' or 'right'
 */
OO.ui.mixin.ClippableElement.prototype.getHorizontalAnchorEdge = function () {
  if ( this.computePosition && this.positioning && this.computePosition().right !== '' ) {
    return 'right';
  }
  return 'left';
};

/**
 * Return the side of the clippable on which it is "anchored" (aligned to something else).
 * ClippableElement will clip the opposite side when reducing element's width.
 *
 * Classes that mix in ClippableElement should override this to return 'bottom' if their
 * clippable is absolutely positioned and using 'bottom: Npx' (and not using 'top').
 * If your class also mixes in FloatableElement, this is handled automatically.
 *
 * (This can't be guessed from the actual CSS because the computed values for 'left'/'right' are
 * always in pixels, even if they were unset or set to 'auto'.)
 *
 * When in doubt, 'top' is a sane fallback.
 *
 * @return {string} 'top' or 'bottom'
 */
OO.ui.mixin.ClippableElement.prototype.getVerticalAnchorEdge = function () {
  if ( this.computePosition && this.positioning && this.computePosition().bottom !== '' ) {
    return 'bottom';
  }
  return 'top';
};

/**
 * Clip element to visible boundaries and allow scrolling when needed. You should call this method
 * when the element's natural height changes.
 *
 * Element will be clipped the bottom or right of the element is within 10px of the edge of, or
 * overlapped by, the visible area of the nearest scrollable container.
 *
 * Because calling clip() when the natural height changes isn't always possible, we also set
 * max-height when the element isn't being clipped. This means that if the element tries to grow
 * beyond the edge, something reasonable will happen before clip() is called.
 *
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.ClippableElement.prototype.clip = function () {
  var extraHeight, extraWidth, viewportSpacing,
    desiredWidth, desiredHeight, allotedWidth, allotedHeight,
    naturalWidth, naturalHeight, clipWidth, clipHeight,
    $item, itemRect, $viewport, viewportRect, availableRect,
    direction, vertScrollbarWidth, horizScrollbarHeight,
    // Extra tolerance so that the sloppy code below doesn't result in results that are off
    // by one or two pixels. (And also so that we have space to display drop shadows.)
    // Chosen by fair dice roll.
    buffer = 7;

  if ( !this.clipping ) {
    // this.$clippableScrollableContainer and this.$clippableWindow are null, so the below
    // will fail
    return this;
  }

  function rectIntersection( a, b ) {
    var out = {};
    out.top = Math.max( a.top, b.top );
    out.left = Math.max( a.left, b.left );
    out.bottom = Math.min( a.bottom, b.bottom );
    out.right = Math.min( a.right, b.right );
    return out;
  }

  viewportSpacing = OO.ui.getViewportSpacing();

  if ( this.$clippableScrollableContainer.is( 'html, body' ) ) {
    $viewport = $( this.$clippableScrollableContainer[ 0 ].ownerDocument.body );
    // Dimensions of the browser window, rather than the element!
    viewportRect = {
      top: 0,
      left: 0,
      right: document.documentElement.clientWidth,
      bottom: document.documentElement.clientHeight
    };
    viewportRect.top += viewportSpacing.top;
    viewportRect.left += viewportSpacing.left;
    viewportRect.right -= viewportSpacing.right;
    viewportRect.bottom -= viewportSpacing.bottom;
  } else {
    $viewport = this.$clippableScrollableContainer;
    viewportRect = $viewport[ 0 ].getBoundingClientRect();
    // Convert into a plain object
    viewportRect = $.extend( {}, viewportRect );
  }

  // Account for scrollbar gutter
  direction = $viewport.css( 'direction' );
  vertScrollbarWidth = $viewport.innerWidth() - $viewport.prop( 'clientWidth' );
  horizScrollbarHeight = $viewport.innerHeight() - $viewport.prop( 'clientHeight' );
  viewportRect.bottom -= horizScrollbarHeight;
  if ( direction === 'rtl' ) {
    viewportRect.left += vertScrollbarWidth;
  } else {
    viewportRect.right -= vertScrollbarWidth;
  }

  // Add arbitrary tolerance
  viewportRect.top += buffer;
  viewportRect.left += buffer;
  viewportRect.right -= buffer;
  viewportRect.bottom -= buffer;

  $item = this.$clippableContainer || this.$clippable;

  extraHeight = $item.outerHeight() - this.$clippable.outerHeight();
  extraWidth = $item.outerWidth() - this.$clippable.outerWidth();

  itemRect = $item[ 0 ].getBoundingClientRect();
  // Convert into a plain object
  itemRect = $.extend( {}, itemRect );

  // Item might already be clipped, so we can't just use its dimensions (in case we might need to
  // make it larger than before). Extend the rectangle to the maximum size we are allowed to take.
  if ( this.getHorizontalAnchorEdge() === 'right' ) {
    itemRect.left = viewportRect.left;
  } else {
    itemRect.right = viewportRect.right;
  }
  if ( this.getVerticalAnchorEdge() === 'bottom' ) {
    itemRect.top = viewportRect.top;
  } else {
    itemRect.bottom = viewportRect.bottom;
  }

  availableRect = rectIntersection( viewportRect, itemRect );

  desiredWidth = Math.max( 0, availableRect.right - availableRect.left );
  desiredHeight = Math.max( 0, availableRect.bottom - availableRect.top );
  // It should never be desirable to exceed the dimensions of the browser viewport... right?
  desiredWidth = Math.min( desiredWidth,
    document.documentElement.clientWidth - viewportSpacing.left - viewportSpacing.right );
  desiredHeight = Math.min( desiredHeight,
    document.documentElement.clientHeight - viewportSpacing.top - viewportSpacing.right );
  allotedWidth = Math.ceil( desiredWidth - extraWidth );
  allotedHeight = Math.ceil( desiredHeight - extraHeight );
  naturalWidth = this.$clippable.prop( 'scrollWidth' );
  naturalHeight = this.$clippable.prop( 'scrollHeight' );
  clipWidth = allotedWidth < naturalWidth;
  clipHeight = allotedHeight < naturalHeight;

  if ( clipWidth ) {
    // The order matters here. If overflow is not set first, Chrome displays bogus scrollbars.
    // See T157672.
    // Forcing a reflow is a smaller workaround than calling reconsiderScrollbars() for
    // this case.
    this.$clippable.css( 'overflowX', 'scroll' );
    // eslint-disable-next-line no-void
    void this.$clippable[ 0 ].offsetHeight; // Force reflow
    this.$clippable.css( {
      width: Math.max( 0, allotedWidth ),
      maxWidth: ''
    } );
  } else {
    this.$clippable.css( {
      overflowX: '',
      width: this.idealWidth || '',
      maxWidth: Math.max( 0, allotedWidth )
    } );
  }
  if ( clipHeight ) {
    // The order matters here. If overflow is not set first, Chrome displays bogus scrollbars.
    // See T157672.
    // Forcing a reflow is a smaller workaround than calling reconsiderScrollbars() for
    // this case.
    this.$clippable.css( 'overflowY', 'scroll' );
    // eslint-disable-next-line no-void
    void this.$clippable[ 0 ].offsetHeight; // Force reflow
    this.$clippable.css( {
      height: Math.max( 0, allotedHeight ),
      maxHeight: ''
    } );
  } else {
    this.$clippable.css( {
      overflowY: '',
      height: this.idealHeight || '',
      maxHeight: Math.max( 0, allotedHeight )
    } );
  }

  // If we stopped clipping in at least one of the dimensions
  if ( ( this.clippedHorizontally && !clipWidth ) || ( this.clippedVertically && !clipHeight ) ) {
    OO.ui.Element.static.reconsiderScrollbars( this.$clippable[ 0 ] );
  }

  this.clippedHorizontally = clipWidth;
  this.clippedVertically = clipHeight;

  return this;
};

/**
 * PopupWidget is a container for content. The popup is overlaid and positioned absolutely.
 * By default, each popup has an anchor that points toward its origin.
 * Please see the [OOUI documentation on MediaWiki.org] [1] for more information and examples.
 *
 * Unlike most widgets, PopupWidget is initially hidden and must be shown by calling #toggle.
 *
 *     @example
 *     // A PopupWidget.
 *     var popup = new OO.ui.PopupWidget( {
 *         $content: $( '<p>Hi there!</p>' ),
 *         padded: true,
 *         width: 300
 *     } );
 *
 *     $( document.body ).append( popup.$element );
 *     // To display the popup, toggle the visibility to 'true'.
 *     popup.toggle( true );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Popups
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.ClippableElement
 * @mixins OO.ui.mixin.FloatableElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {number|null} [width=320] Width of popup in pixels. Pass `null` to use automatic width.
 * @cfg {number|null} [height=null] Height of popup in pixels. Pass `null` to use automatic height.
 * @cfg {boolean} [anchor=true] Show anchor pointing to origin of popup
 * @cfg {string} [position='below'] Where to position the popup relative to $floatableContainer
 *  'above': Put popup above $floatableContainer; anchor points down to the horizontal center
 *    of $floatableContainer
 *  'below': Put popup below $floatableContainer; anchor points up to the horizontal center
 *    of $floatableContainer
 *  'before': Put popup to the left (LTR) / right (RTL) of $floatableContainer; anchor points
 *    endwards (right/left) to the vertical center of $floatableContainer
 *  'after': Put popup to the right (LTR) / left (RTL) of $floatableContainer; anchor points
 *    startwards (left/right) to the vertical center of $floatableContainer
 * @cfg {string} [align='center'] How to align the popup to $floatableContainer
 *  'forwards': If position is above/below, move the popup as far endwards (right in LTR, left in
 *    RTL) as possible while still keeping the anchor within the popup; if position is before/after,
 *    move the popup as far downwards as possible.
 *  'backwards': If position is above/below, move the popup as far startwards (left in LTR, right in
 *    RTL) as possible while still keeping the anchor within the popup; if position is before/after,
 *     move the popup as far upwards as possible.
 *  'center': Horizontally (if position is above/below) or vertically (before/after) align the
 *     center of the popup with the center of $floatableContainer.
 * 'force-left': Alias for 'forwards' in LTR and 'backwards' in RTL
 * 'force-right': Alias for 'backwards' in RTL and 'forwards' in LTR
 * @cfg {boolean} [autoFlip=true] Whether to automatically switch the popup's position between
 *  'above' and 'below', or between 'before' and 'after', if there is not enough space in the
 *  desired direction to display the popup without clipping
 * @cfg {jQuery} [$container] Constrain the popup to the boundaries of the specified container.
 *  See the [OOUI docs on MediaWiki][3] for an example.
 *  [3]: https://www.mediawiki.org/wiki/OOUI/Widgets/Popups#containerExample
 * @cfg {number} [containerPadding=10] Padding between the popup and its container, specified as a
 *  number of pixels.
 * @cfg {jQuery} [$content] Content to append to the popup's body
 * @cfg {jQuery} [$footer] Content to append to the popup's footer
 * @cfg {boolean} [autoClose=false] Automatically close the popup when it loses focus.
 * @cfg {jQuery} [$autoCloseIgnore] Elements that will not close the popup when clicked.
 *  This config option is only relevant if #autoClose is set to `true`. See the
 *  [OOUI documentation on MediaWiki][2] for an example.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Popups#autocloseExample
 * @cfg {boolean} [head=false] Show a popup header that contains a #label (if specified) and close
 *  button.
 * @cfg {boolean} [padded=false] Add padding to the popup's body
 */
OO.ui.PopupWidget = function OoUiPopupWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.PopupWidget.super.call( this, config );

  // Properties (must be set before ClippableElement constructor call)
  this.$body = $( '<div>' );
  this.$popup = $( '<div>' );

  // Mixin constructors
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.ClippableElement.call( this, $.extend( {
    $clippable: this.$body,
    $clippableContainer: this.$popup
  }, config ) );
  OO.ui.mixin.FloatableElement.call( this, config );

  // Properties
  this.$anchor = $( '<div>' );
  // If undefined, will be computed lazily in computePosition()
  this.$container = config.$container;
  this.containerPadding = config.containerPadding !== undefined ? config.containerPadding : 10;
  this.autoClose = !!config.autoClose;
  this.transitionTimeout = null;
  this.anchored = false;
  this.onDocumentMouseDownHandler = this.onDocumentMouseDown.bind( this );
  this.onDocumentKeyDownHandler = this.onDocumentKeyDown.bind( this );
  this.onTabKeyDownHandler = this.onTabKeyDown.bind( this );

  // Initialization
  this.setSize( config.width, config.height );
  this.toggleAnchor( config.anchor === undefined || config.anchor );
  this.setAlignment( config.align || 'center' );
  this.setPosition( config.position || 'below' );
  this.setAutoFlip( config.autoFlip === undefined || config.autoFlip );
  this.setAutoCloseIgnore( config.$autoCloseIgnore );
  this.$body.addClass( 'oo-ui-popupWidget-body' );
  this.$anchor.addClass( 'oo-ui-popupWidget-anchor' );
  this.$popup
    .addClass( 'oo-ui-popupWidget-popup' )
    .append( this.$body );
  this.$element
    .addClass( 'oo-ui-popupWidget' )
    .append( this.$popup, this.$anchor );
  // Move content, which was added to #$element by OO.ui.Widget, to the body
  // FIXME This is gross, we should use '$body' or something for the config
  if ( config.$content instanceof $ ) {
    this.$body.append( config.$content );
  }

  if ( config.padded ) {
    this.$body.addClass( 'oo-ui-popupWidget-body-padded' );
  }

  if ( config.head ) {
    if ( !config.hideCloseButton ) {
      this.closeButton = new OO.ui.ButtonWidget( {
        framed: false,
        icon: 'close',
        label: OO.ui.msg( 'ooui-popup-widget-close-button-aria-label' ),
        invisibleLabel: true
      } );
      this.closeButton.connect( this, {
        click: 'onCloseButtonClick'
      } );
    }
    this.$head = $( '<div>' )
      .addClass( 'oo-ui-popupWidget-head' )
      .append( this.$icon, this.$label, this.closeButton && this.closeButton.$element || '' );
    this.$popup.prepend( this.$head );
  }

  if ( config.$footer ) {
    this.$footer = $( '<div>' )
      .addClass( 'oo-ui-popupWidget-footer' )
      .append( config.$footer );
    this.$popup.append( this.$footer );
  }

  // Initially hidden - using #toggle may cause errors if subclasses override toggle with methods
  // that reference properties not initialized at that time of parent class construction
  // TODO: Find a better way to handle post-constructor setup
  this.visible = false;
  this.$element.addClass( 'oo-ui-element-hidden' );
};

/* Setup */

OO.inheritClass( OO.ui.PopupWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.PopupWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.PopupWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.PopupWidget, OO.ui.mixin.ClippableElement );
OO.mixinClass( OO.ui.PopupWidget, OO.ui.mixin.FloatableElement );

/* Events */

/**
 * @event ready
 *
 * The popup is ready: it is visible and has been positioned and clipped.
 */

/**
 * @event closing
 *
 * The popup is no longer visible.
 */

/* Methods */

/**
 * Handles document mouse down events.
 *
 * @private
 * @param {MouseEvent} e Mouse down event
 */
OO.ui.PopupWidget.prototype.onDocumentMouseDown = function ( e ) {
  if (
    this.isVisible() &&
    !OO.ui.contains( this.$element.add( this.$autoCloseIgnore ).get(), e.target, true )
  ) {
    this.toggle( false );
  }
};

/**
 * Bind document mouse down listener.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.bindDocumentMouseDownListener = function () {
  // Capture clicks outside popup
  this.getElementDocument().addEventListener( 'mousedown', this.onDocumentMouseDownHandler, true );
  // We add 'click' event because iOS safari needs to respond to this event.
  // We can't use 'touchstart' (as is usually the equivalent to 'mousedown') because
  // then it will trigger when scrolling. While iOS Safari has some reported behavior
  // of occasionally not emitting 'click' properly, that event seems to be the standard
  // that it should be emitting, so we add it to this and will operate the event handler
  // on whichever of these events was triggered first
  this.getElementDocument().addEventListener( 'click', this.onDocumentMouseDownHandler, true );
};

/**
 * Handles close button click events.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.onCloseButtonClick = function () {
  if ( this.isVisible() ) {
    this.toggle( false );
  }
};

/**
 * Unbind document mouse down listener.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.unbindDocumentMouseDownListener = function () {
  this.getElementDocument().removeEventListener( 'mousedown', this.onDocumentMouseDownHandler, true );
  this.getElementDocument().removeEventListener( 'click', this.onDocumentMouseDownHandler, true );
};

/**
 * Handles document key down events.
 *
 * @private
 * @param {KeyboardEvent} e Key down event
 */
OO.ui.PopupWidget.prototype.onDocumentKeyDown = function ( e ) {
  if (
    e.which === OO.ui.Keys.ESCAPE &&
    this.isVisible()
  ) {
    this.toggle( false );
    e.preventDefault();
    e.stopPropagation();
  }
};

/**
 * Bind document key down listener.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.bindDocumentKeyDownListener = function () {
  this.getElementDocument().addEventListener( 'keydown', this.onDocumentKeyDownHandler, true );
};

/**
 * Unbind document key down listener.
 *
 * @private
 */
OO.ui.PopupWidget.prototype.unbindDocumentKeyDownListener = function () {
  this.getElementDocument().removeEventListener( 'keydown', this.onDocumentKeyDownHandler, true );
};

/**
 * Handles Tab key down events.
 *
 * @private
 * @param {KeyboardEvent} e Key down event
 */
OO.ui.PopupWidget.prototype.onTabKeyDown = function ( e ) {
  if ( !e.shiftKey && e.which === OO.ui.Keys.TAB ) {
    e.preventDefault();
    this.toggle( false );
  }
};

/**
 * Show, hide, or toggle the visibility of the anchor.
 *
 * @param {boolean} [show] Show anchor, omit to toggle
 */
OO.ui.PopupWidget.prototype.toggleAnchor = function ( show ) {
  show = show === undefined ? !this.anchored : !!show;

  if ( this.anchored !== show ) {
    if ( show ) {
      this.$element.addClass( 'oo-ui-popupWidget-anchored' );
      this.$element.addClass( 'oo-ui-popupWidget-anchored-' + this.anchorEdge );
    } else {
      this.$element.removeClass( 'oo-ui-popupWidget-anchored' );
      this.$element.removeClass( 'oo-ui-popupWidget-anchored-' + this.anchorEdge );
    }
    this.anchored = show;
  }
};

/**
 * Change which edge the anchor appears on.
 *
 * @param {string} edge 'top', 'bottom', 'start' or 'end'
 */
OO.ui.PopupWidget.prototype.setAnchorEdge = function ( edge ) {
  if ( [ 'top', 'bottom', 'start', 'end' ].indexOf( edge ) === -1 ) {
    throw new Error( 'Invalid value for edge: ' + edge );
  }
  if ( this.anchorEdge !== null ) {
    this.$element.removeClass( 'oo-ui-popupWidget-anchored-' + this.anchorEdge );
  }
  this.anchorEdge = edge;
  if ( this.anchored ) {
    this.$element.addClass( 'oo-ui-popupWidget-anchored-' + edge );
  }
};

/**
 * Check if the anchor is visible.
 *
 * @return {boolean} Anchor is visible
 */
OO.ui.PopupWidget.prototype.hasAnchor = function () {
  return this.anchored;
};

/**
 * Toggle visibility of the popup. The popup is initially hidden and must be shown by calling
 * `.toggle( true )` after its #$element is attached to the DOM.
 *
 * Do not show the popup while it is not attached to the DOM. The calculations required to display
 * it in the right place and with the right dimensions only work correctly while it is attached.
 * Side-effects may include broken interface and exceptions being thrown. This wasn't always
 * strictly enforced, so currently it only generates a warning in the browser console.
 *
 * @fires ready
 * @inheritdoc
 */
OO.ui.PopupWidget.prototype.toggle = function ( show ) {
  var change, normalHeight, oppositeHeight, normalWidth,
    oppositeWidth, $lastFocusableElement;
  show = show === undefined ? !this.isVisible() : !!show;

  change = show !== this.isVisible();

  if ( show && !this.warnedUnattached && !this.isElementAttached() ) {
    OO.ui.warnDeprecation( 'PopupWidget#toggle: Before calling this method, the popup must be attached to the DOM.' );
    this.warnedUnattached = true;
  }
  if ( show && !this.$floatableContainer && this.isElementAttached() ) {
    // Fall back to the parent node if the floatableContainer is not set
    this.setFloatableContainer( this.$element.parent() );
  }

  if ( change && show && this.autoFlip ) {
    // Reset auto-flipping before showing the popup again. It's possible we no longer need to
    // flip (e.g. if the user scrolled).
    this.isAutoFlipped = false;
  }

  // Parent method
  OO.ui.PopupWidget.super.prototype.toggle.call( this, show );

  if ( change ) {
    this.togglePositioning( show && !!this.$floatableContainer );

    // Find the last focusable element in the popup widget
    $lastFocusableElement = OO.ui.findFocusable( this.$element, true );

    if ( show ) {
      if ( this.autoClose ) {
        this.bindDocumentMouseDownListener();
        this.bindDocumentKeyDownListener();

        // Bind a keydown event to the last focusable element
        // If user presses the tab key on this item, dismiss the popup and
        // take focus back to the caller, ideally the caller implements this functionality
        // This is to prevent illogical focus order, a common accessibility pitfall.
        // Alternative Fix: Implement focus trap for popup widget.
        $lastFocusableElement.on( 'keydown', this.onTabKeyDownHandler );
      }
      this.updateDimensions();
      this.toggleClipping( true );

      if ( this.autoFlip ) {
        if ( this.popupPosition === 'above' || this.popupPosition === 'below' ) {
          if ( this.isClippedVertically() || this.isFloatableOutOfView() ) {
            // If opening the popup in the normal direction causes it to be clipped,
            // open in the opposite one instead
            normalHeight = this.$element.height();
            this.isAutoFlipped = !this.isAutoFlipped;
            this.position();
            if ( this.isClippedVertically() || this.isFloatableOutOfView() ) {
              // If that also causes it to be clipped, open in whichever direction
              // we have more space
              oppositeHeight = this.$element.height();
              if ( oppositeHeight < normalHeight ) {
                this.isAutoFlipped = !this.isAutoFlipped;
                this.position();
              }
            }
          }
        }
        if ( this.popupPosition === 'before' || this.popupPosition === 'after' ) {
          if ( this.isClippedHorizontally() || this.isFloatableOutOfView() ) {
            // If opening the popup in the normal direction causes it to be clipped,
            // open in the opposite one instead
            normalWidth = this.$element.width();
            this.isAutoFlipped = !this.isAutoFlipped;
            // Due to T180173 horizontally clipped PopupWidgets have messed up
            // dimensions, which causes positioning to be off. Toggle clipping back and
            // forth to work around.
            this.toggleClipping( false );
            this.position();
            this.toggleClipping( true );
            if ( this.isClippedHorizontally() || this.isFloatableOutOfView() ) {
              // If that also causes it to be clipped, open in whichever direction
              // we have more space
              oppositeWidth = this.$element.width();
              if ( oppositeWidth < normalWidth ) {
                this.isAutoFlipped = !this.isAutoFlipped;
                // Due to T180173, horizontally clipped PopupWidgets have messed up
                // dimensions, which causes positioning to be off. Toggle clipping
                // back and forth to work around.
                this.toggleClipping( false );
                this.position();
                this.toggleClipping( true );
              }
            }
          }
        }
      }

      this.emit( 'ready' );
    } else {
      this.toggleClipping( false );
      if ( this.autoClose ) {
        // Remove binded keydown event from the last focusable element when popup closes
        $lastFocusableElement.off( 'keydown', this.onTabKeyDownHandler );

        this.unbindDocumentMouseDownListener();
        this.unbindDocumentKeyDownListener();
      }

      // This is so we can restore focus to the parent when the pop widget dismisses
      // Also, we're emitting an event
      // so we don't have to tie this implementation to the caller.
      // Let the caller handle this details.
      this.emit( 'closing' );
    }
  }

  return this;
};

/**
 * Set the size of the popup.
 *
 * Changing the size may also change the popup's position depending on the alignment.
 *
 * @param {number|null} [width=320] Width in pixels. Pass `null` to use automatic width.
 * @param {number|null} [height=null] Height in pixels. Pass `null` to use automatic height.
 * @param {boolean} [transition=false] Use a smooth transition
 * @chainable
 */
OO.ui.PopupWidget.prototype.setSize = function ( width, height, transition ) {
  this.width = width !== undefined ? width : 320;
  this.height = height !== undefined ? height : null;
  if ( this.isVisible() ) {
    this.updateDimensions( transition );
  }
};

/**
 * Update the size and position.
 *
 * Only use this to keep the popup properly anchored. Use #setSize to change the size, and this will
 * be called automatically.
 *
 * @param {boolean} [transition=false] Use a smooth transition
 * @chainable
 */
OO.ui.PopupWidget.prototype.updateDimensions = function ( transition ) {
  var widget = this;

  // Prevent transition from being interrupted
  clearTimeout( this.transitionTimeout );
  if ( transition ) {
    // Enable transition
    this.$element.addClass( 'oo-ui-popupWidget-transitioning' );
  }

  this.position();

  if ( transition ) {
    // Prevent transitioning after transition is complete
    this.transitionTimeout = setTimeout( function () {
      widget.$element.removeClass( 'oo-ui-popupWidget-transitioning' );
    }, 200 );
  } else {
    // Prevent transitioning immediately
    this.$element.removeClass( 'oo-ui-popupWidget-transitioning' );
  }
};

/**
 * @inheritdoc
 */
OO.ui.PopupWidget.prototype.computePosition = function () {
  var direction, align, vertical, start, end, near, far, sizeProp, popupSize, anchorSize,
    anchorPos, anchorOffset, anchorMargin, parentPosition, positionProp, positionAdjustment,
    floatablePos, offsetParentPos, containerPos, popupPosition, viewportSpacing,
    popupPos = {},
    anchorCss = { left: '', right: '', top: '', bottom: '' },
    popupPositionOppositeMap = {
      above: 'below',
      below: 'above',
      before: 'after',
      after: 'before'
    },
    alignMap = {
      ltr: {
        'force-left': 'backwards',
        'force-right': 'forwards'
      },
      rtl: {
        'force-left': 'forwards',
        'force-right': 'backwards'
      }
    },
    anchorEdgeMap = {
      above: 'bottom',
      below: 'top',
      before: 'end',
      after: 'start'
    },
    hPosMap = {
      forwards: 'start',
      center: 'center',
      backwards: this.anchored ? 'before' : 'end'
    },
    vPosMap = {
      forwards: 'top',
      center: 'center',
      backwards: 'bottom'
    };

  if ( !this.$container ) {
    // Lazy-initialize $container if not specified in constructor
    this.$container = $( this.getClosestScrollableElementContainer() );
  }
  direction = this.$container.css( 'direction' );

  // Set height and width before we do anything else, since it might cause our measurements
  // to change (e.g. due to scrollbars appearing or disappearing), and it also affects centering
  this.$popup.css( {
    width: this.width !== null ? this.width : 'auto',
    height: this.height !== null ? this.height : 'auto'
  } );

  align = alignMap[ direction ][ this.align ] || this.align;
  popupPosition = this.popupPosition;
  if ( this.isAutoFlipped ) {
    popupPosition = popupPositionOppositeMap[ popupPosition ];
  }

  // If the popup is positioned before or after, then the anchor positioning is vertical,
  // otherwise horizontal
  vertical = popupPosition === 'before' || popupPosition === 'after';
  start = vertical ? 'top' : ( direction === 'rtl' ? 'right' : 'left' );
  end = vertical ? 'bottom' : ( direction === 'rtl' ? 'left' : 'right' );
  near = vertical ? 'top' : 'left';
  far = vertical ? 'bottom' : 'right';
  sizeProp = vertical ? 'Height' : 'Width';
  popupSize = vertical ?
    ( this.height || this.$popup.height() ) :
    ( this.width || this.$popup.width() );

  this.setAnchorEdge( anchorEdgeMap[ popupPosition ] );
  this.horizontalPosition = vertical ? popupPosition : hPosMap[ align ];
  this.verticalPosition = vertical ? vPosMap[ align ] : popupPosition;

  // Parent method
  parentPosition = OO.ui.mixin.FloatableElement.prototype.computePosition.call( this );
  // Find out which property FloatableElement used for positioning, and adjust that value
  positionProp = vertical ?
    ( parentPosition.top !== '' ? 'top' : 'bottom' ) :
    ( parentPosition.left !== '' ? 'left' : 'right' );

  // Figure out where the near and far edges of the popup and $floatableContainer are
  floatablePos = this.$floatableContainer.offset();
  floatablePos[ far ] = floatablePos[ near ] + this.$floatableContainer[ 'outer' + sizeProp ]();
  // Measure where the offsetParent is and compute our position based on that and parentPosition
  offsetParentPos = this.$element.offsetParent()[ 0 ] === document.documentElement ?
    { top: 0, left: 0 } :
    this.$element.offsetParent().offset();

  if ( positionProp === near ) {
    popupPos[ near ] = offsetParentPos[ near ] + parentPosition[ near ];
    popupPos[ far ] = popupPos[ near ] + popupSize;
  } else {
    popupPos[ far ] = offsetParentPos[ near ] +
      this.$element.offsetParent()[ 'inner' + sizeProp ]() - parentPosition[ far ];
    popupPos[ near ] = popupPos[ far ] - popupSize;
  }

  if ( this.anchored ) {
    // Position the anchor (which is positioned relative to the popup) to point to
    // $floatableContainer
    anchorPos = ( floatablePos[ start ] + floatablePos[ end ] ) / 2;
    anchorOffset = ( start === far ? -1 : 1 ) * ( anchorPos - popupPos[ start ] );

    // If the anchor is less than 2*anchorSize from either edge, move the popup to make more
    // space this.$anchor.width()/height() returns 0 because of the CSS trickery we use, so use
    // scrollWidth/Height
    anchorSize = this.$anchor[ 0 ][ 'scroll' + sizeProp ];
    anchorMargin = parseFloat( this.$anchor.css( 'margin-' + start ) );
    if ( anchorOffset + anchorMargin < 2 * anchorSize ) {
      // Not enough space for the anchor on the start side; pull the popup startwards
      positionAdjustment = ( positionProp === start ? -1 : 1 ) *
        ( 2 * anchorSize - ( anchorOffset + anchorMargin ) );
    } else if ( anchorOffset + anchorMargin > popupSize - 2 * anchorSize ) {
      // Not enough space for the anchor on the end side; pull the popup endwards
      positionAdjustment = ( positionProp === end ? -1 : 1 ) *
        ( anchorOffset + anchorMargin - ( popupSize - 2 * anchorSize ) );
    } else {
      positionAdjustment = 0;
    }
  } else {
    positionAdjustment = 0;
  }

  // Check if the popup will go beyond the edge of this.$container
  containerPos = this.$container[ 0 ] === document.documentElement ?
    { top: 0, left: 0 } :
    this.$container.offset();
  containerPos[ far ] = containerPos[ near ] + this.$container[ 'inner' + sizeProp ]();
  if ( this.$container[ 0 ] === document.documentElement ) {
    viewportSpacing = OO.ui.getViewportSpacing();
    containerPos[ near ] += viewportSpacing[ near ];
    containerPos[ far ] -= viewportSpacing[ far ];
  }
  // Take into account how much the popup will move because of the adjustments we're going to make
  popupPos[ near ] += ( positionProp === near ? 1 : -1 ) * positionAdjustment;
  popupPos[ far ] += ( positionProp === near ? 1 : -1 ) * positionAdjustment;
  if ( containerPos[ near ] + this.containerPadding > popupPos[ near ] ) {
    // Popup goes beyond the near (left/top) edge, move it to the right/bottom
    positionAdjustment += ( positionProp === near ? 1 : -1 ) *
      ( containerPos[ near ] + this.containerPadding - popupPos[ near ] );
  } else if ( containerPos[ far ] - this.containerPadding < popupPos[ far ] ) {
    // Popup goes beyond the far (right/bottom) edge, move it to the left/top
    positionAdjustment += ( positionProp === far ? 1 : -1 ) *
      ( popupPos[ far ] - ( containerPos[ far ] - this.containerPadding ) );
  }

  if ( this.anchored ) {
    // Adjust anchorOffset for positionAdjustment
    anchorOffset += ( positionProp === start ? -1 : 1 ) * positionAdjustment;

    // Position the anchor
    anchorCss[ start ] = anchorOffset;
    this.$anchor.css( anchorCss );
  }

  // Move the popup if needed
  parentPosition[ positionProp ] += positionAdjustment;

  return parentPosition;
};

/**
 * Set popup alignment
 *
 * @param {string} [align=center] Alignment of the popup, `center`, `force-left`, `force-right`,
 *  `backwards` or `forwards`.
 */
OO.ui.PopupWidget.prototype.setAlignment = function ( align ) {
  // Validate alignment
  if ( [ 'force-left', 'force-right', 'backwards', 'forwards', 'center' ].indexOf( align ) > -1 ) {
    this.align = align;
  } else {
    this.align = 'center';
  }
  this.position();
};

/**
 * Get popup alignment
 *
 * @return {string} Alignment of the popup, `center`, `force-left`, `force-right`,
 *  `backwards` or `forwards`.
 */
OO.ui.PopupWidget.prototype.getAlignment = function () {
  return this.align;
};

/**
 * Change the positioning of the popup.
 *
 * @param {string} position 'above', 'below', 'before' or 'after'
 */
OO.ui.PopupWidget.prototype.setPosition = function ( position ) {
  if ( [ 'above', 'below', 'before', 'after' ].indexOf( position ) === -1 ) {
    position = 'below';
  }
  this.popupPosition = position;
  this.position();
};

/**
 * Get popup positioning.
 *
 * @return {string} 'above', 'below', 'before' or 'after'
 */
OO.ui.PopupWidget.prototype.getPosition = function () {
  return this.popupPosition;
};

/**
 * Set popup auto-flipping.
 *
 * @param {boolean} autoFlip Whether to automatically switch the popup's position between
 *  'above' and 'below', or between 'before' and 'after', if there is not enough space in the
 *  desired direction to display the popup without clipping
 */
OO.ui.PopupWidget.prototype.setAutoFlip = function ( autoFlip ) {
  autoFlip = !!autoFlip;

  if ( this.autoFlip !== autoFlip ) {
    this.autoFlip = autoFlip;
  }
};

/**
 * Set which elements will not close the popup when clicked.
 *
 * For auto-closing popups, clicks on these elements will not cause the popup to auto-close.
 *
 * @param {jQuery} $autoCloseIgnore Elements to ignore for auto-closing
 */
OO.ui.PopupWidget.prototype.setAutoCloseIgnore = function ( $autoCloseIgnore ) {
  this.$autoCloseIgnore = $autoCloseIgnore;
};

/**
 * Get an ID of the body element, this can be used as the
 * `aria-describedby` attribute for an input field.
 *
 * @return {string} The ID of the body element
 */
OO.ui.PopupWidget.prototype.getBodyId = function () {
  var id = this.$body.attr( 'id' );
  if ( id === undefined ) {
    id = OO.ui.generateElementId();
    this.$body.attr( 'id', id );
  }
  return id;
};

/**
 * PopupElement is mixed into other classes to generate a {@link OO.ui.PopupWidget popup widget}.
 * A popup is a container for content. It is overlaid and positioned absolutely. By default, each
 * popup has an anchor, which is an arrow-like protrusion that points toward the popup’s origin.
 * See {@link OO.ui.PopupWidget PopupWidget} for an example.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object} [popup] Configuration to pass to popup
 * @cfg {boolean} [popup.autoClose=true] Popup auto-closes when it loses focus
 */
OO.ui.mixin.PopupElement = function OoUiMixinPopupElement( config ) {
  // Configuration initialization
  config = config || {};

  // Properties
  this.popup = new OO.ui.PopupWidget( $.extend(
    {
      autoClose: true,
      $floatableContainer: this.$element
    },
    config.popup,
    {
      $autoCloseIgnore: this.$element.add( config.popup && config.popup.$autoCloseIgnore )
    }
  ) );
};

/* Methods */

/**
 * Get popup.
 *
 * @return {OO.ui.PopupWidget} Popup widget
 */
OO.ui.mixin.PopupElement.prototype.getPopup = function () {
  return this.popup;
};

/**
 * PopupButtonWidgets toggle the visibility of a contained {@link OO.ui.PopupWidget PopupWidget},
 * which is used to display additional information or options.
 *
 *     @example
 *     // A PopupButtonWidget.
 *     var popupButton = new OO.ui.PopupButtonWidget( {
 *         label: 'Popup button with options',
 *         icon: 'menu',
 *         popup: {
 *             $content: $( '<p>Additional options here.</p>' ),
 *             padded: true,
 *             align: 'force-left'
 *         }
 *     } );
 *     // Append the button to the DOM.
 *     $( document.body ).append( popupButton.$element );
 *
 * @class
 * @extends OO.ui.ButtonWidget
 * @mixins OO.ui.mixin.PopupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$overlay] Render the popup into a separate layer. This configuration is useful
 *  in cases where the expanded popup is larger than its containing `<div>`. The specified overlay
 *  layer is usually on top of the containing `<div>` and has a larger area. By default, the popup
 *  uses relative positioning.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.PopupButtonWidget = function OoUiPopupButtonWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.PopupButtonWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.PopupElement.call( this, config );

  // Properties
  this.$overlay = ( config.$overlay === true ?
    OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;

  // Events
  this.connect( this, {
    click: 'onAction'
  } );

  // Initialization
  this.$element.addClass( 'oo-ui-popupButtonWidget' );
  this.popup.$element
    .addClass( 'oo-ui-popupButtonWidget-popup' )
    .toggleClass( 'oo-ui-popupButtonWidget-framed-popup', this.isFramed() )
    .toggleClass( 'oo-ui-popupButtonWidget-frameless-popup', !this.isFramed() );
  this.$overlay.append( this.popup.$element );
};

/* Setup */

OO.inheritClass( OO.ui.PopupButtonWidget, OO.ui.ButtonWidget );
OO.mixinClass( OO.ui.PopupButtonWidget, OO.ui.mixin.PopupElement );

/* Methods */

/**
 * Handle the button action being triggered.
 *
 * @private
 */
OO.ui.PopupButtonWidget.prototype.onAction = function () {
  this.popup.toggle();
};

/**
 * Mixin for OO.ui.Widget subclasses to provide OO.ui.mixin.GroupElement.
 *
 * Use together with OO.ui.mixin.ItemWidget to make disabled state inheritable.
 *
 * @private
 * @abstract
 * @class
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.mixin.GroupWidget = function OoUiMixinGroupWidget( config ) {
  // Mixin constructors
  OO.ui.mixin.GroupElement.call( this, config );
};

/* Setup */

OO.mixinClass( OO.ui.mixin.GroupWidget, OO.ui.mixin.GroupElement );

/* Methods */

/**
 * Set the disabled state of the widget.
 *
 * This will also update the disabled state of child widgets.
 *
 * @param {boolean} disabled Disable widget
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.mixin.GroupWidget.prototype.setDisabled = function ( disabled ) {
  var i, len;

  // Parent method
  // Note: Calling #setDisabled this way assumes this is mixed into an OO.ui.Widget
  OO.ui.Widget.prototype.setDisabled.call( this, disabled );

  // During construction, #setDisabled is called before the OO.ui.mixin.GroupElement constructor
  if ( this.items ) {
    for ( i = 0, len = this.items.length; i < len; i++ ) {
      this.items[ i ].updateDisabled();
    }
  }

  return this;
};

/**
 * Mixin for widgets used as items in widgets that mix in OO.ui.mixin.GroupWidget.
 *
 * Item widgets have a reference to a OO.ui.mixin.GroupWidget while they are attached to the group.
 * This allows bidirectional communication.
 *
 * Use together with OO.ui.mixin.GroupWidget to make disabled state inheritable.
 *
 * @private
 * @abstract
 * @class
 *
 * @constructor
 */
OO.ui.mixin.ItemWidget = function OoUiMixinItemWidget() {
  //
};

/* Methods */

/**
 * Check if widget is disabled.
 *
 * Checks parent if present, making disabled state inheritable.
 *
 * @return {boolean} Widget is disabled
 */
OO.ui.mixin.ItemWidget.prototype.isDisabled = function () {
  return this.disabled ||
    ( this.elementGroup instanceof OO.ui.Widget && this.elementGroup.isDisabled() );
};

/**
 * Set group element is in.
 *
 * @param {OO.ui.mixin.GroupElement|null} group Group element, null if none
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.mixin.ItemWidget.prototype.setElementGroup = function ( group ) {
  // Parent method
  // Note: Calling #setElementGroup this way assumes this is mixed into an OO.ui.Element
  OO.ui.Element.prototype.setElementGroup.call( this, group );

  // Initialize item disabled states
  this.updateDisabled();

  return this;
};

/**
 * OptionWidgets are special elements that can be selected and configured with data. The
 * data is often unique for each option, but it does not have to be. OptionWidgets are used
 * with OO.ui.SelectWidget to create a selection of mutually exclusive options. For more information
 * and examples, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.ItemWidget
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.AccessKeyedElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.OptionWidget = function OoUiOptionWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.OptionWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.ItemWidget.call( this );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.FlaggedElement.call( this, config );
  OO.ui.mixin.AccessKeyedElement.call( this, config );
  OO.ui.mixin.TitledElement.call( this, config );

  // Properties
  this.highlighted = false;
  this.pressed = false;
  this.setSelected( !!config.selected );

  // Initialization
  this.$element
    .data( 'oo-ui-optionWidget', this )
    // Allow programmatic focussing (and by access key), but not tabbing
    .attr( 'tabindex', '-1' )
    .attr( 'role', 'option' )
    .addClass( 'oo-ui-optionWidget' )
    .append( this.$label );
};

/* Setup */

OO.inheritClass( OO.ui.OptionWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.ItemWidget );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.AccessKeyedElement );
OO.mixinClass( OO.ui.OptionWidget, OO.ui.mixin.TitledElement );

/* Static Properties */

/**
 * Whether this option can be selected. See #setSelected.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.OptionWidget.static.selectable = true;

/**
 * Whether this option can be highlighted. See #setHighlighted.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.OptionWidget.static.highlightable = true;

/**
 * Whether this option can be pressed. See #setPressed.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.OptionWidget.static.pressable = true;

/**
 * Whether this option will be scrolled into view when it is selected.
 *
 * @static
 * @inheritable
 * @property {boolean}
 */
OO.ui.OptionWidget.static.scrollIntoViewOnSelect = false;

/* Methods */

/**
 * Check if the option can be selected.
 *
 * @return {boolean} Item is selectable
 */
OO.ui.OptionWidget.prototype.isSelectable = function () {
  return this.constructor.static.selectable && !this.disabled && this.isVisible();
};

/**
 * Check if the option can be highlighted. A highlight indicates that the option
 * may be selected when a user presses Enter key or clicks. Disabled items cannot
 * be highlighted.
 *
 * @return {boolean} Item is highlightable
 */
OO.ui.OptionWidget.prototype.isHighlightable = function () {
  return this.constructor.static.highlightable && !this.disabled && this.isVisible();
};

/**
 * Check if the option can be pressed. The pressed state occurs when a user mouses
 * down on an item, but has not yet let go of the mouse.
 *
 * @return {boolean} Item is pressable
 */
OO.ui.OptionWidget.prototype.isPressable = function () {
  return this.constructor.static.pressable && !this.disabled && this.isVisible();
};

/**
 * Check if the option is selected.
 *
 * @return {boolean} Item is selected
 */
OO.ui.OptionWidget.prototype.isSelected = function () {
  return this.selected;
};

/**
 * Check if the option is highlighted. A highlight indicates that the
 * item may be selected when a user presses Enter key or clicks.
 *
 * @return {boolean} Item is highlighted
 */
OO.ui.OptionWidget.prototype.isHighlighted = function () {
  return this.highlighted;
};

/**
 * Check if the option is pressed. The pressed state occurs when a user mouses
 * down on an item, but has not yet let go of the mouse. The item may appear
 * selected, but it will not be selected until the user releases the mouse.
 *
 * @return {boolean} Item is pressed
 */
OO.ui.OptionWidget.prototype.isPressed = function () {
  return this.pressed;
};

/**
 * Set the option’s selected state. In general, all modifications to the selection
 * should be handled by the SelectWidget’s
 * {@link OO.ui.SelectWidget#selectItem selectItem( [item] )} method instead of this method.
 *
 * @param {boolean} [state=false] Select option
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OptionWidget.prototype.setSelected = function ( state ) {
  if ( this.constructor.static.selectable ) {
    this.selected = !!state;
    this.$element
      .toggleClass( 'oo-ui-optionWidget-selected', state )
      .attr( 'aria-selected', state.toString() );
    if ( state && this.constructor.static.scrollIntoViewOnSelect ) {
      this.scrollElementIntoView();
    }
    this.updateThemeClasses();
  }
  return this;
};

/**
 * Set the option’s highlighted state. In general, all programmatic
 * modifications to the highlight should be handled by the
 * SelectWidget’s {@link OO.ui.SelectWidget#highlightItem highlightItem( [item] )}
 * method instead of this method.
 *
 * @param {boolean} [state=false] Highlight option
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OptionWidget.prototype.setHighlighted = function ( state ) {
  if ( this.constructor.static.highlightable ) {
    this.highlighted = !!state;
    this.$element.toggleClass( 'oo-ui-optionWidget-highlighted', state );
    this.updateThemeClasses();
  }
  return this;
};

/**
 * Set the option’s pressed state. In general, all
 * programmatic modifications to the pressed state should be handled by the
 * SelectWidget’s {@link OO.ui.SelectWidget#pressItem pressItem( [item] )}
 * method instead of this method.
 *
 * @param {boolean} [state=false] Press option
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OptionWidget.prototype.setPressed = function ( state ) {
  if ( this.constructor.static.pressable ) {
    this.pressed = !!state;
    this.$element.toggleClass( 'oo-ui-optionWidget-pressed', state );
    this.updateThemeClasses();
  }
  return this;
};

/**
 * Get text to match search strings against.
 *
 * The default implementation returns the label text, but subclasses
 * can override this to provide more complex behavior.
 *
 * @return {string|boolean} String to match search string against
 */
OO.ui.OptionWidget.prototype.getMatchText = function () {
  var label = this.getLabel();
  return typeof label === 'string' ? label : this.$label.text();
};

/**
 * A SelectWidget is of a generic selection of options. The OOUI library contains several types of
 * select widgets, including {@link OO.ui.ButtonSelectWidget button selects},
 * {@link OO.ui.RadioSelectWidget radio selects}, and {@link OO.ui.MenuSelectWidget
 * menu selects}.
 *
 * This class should be used together with OO.ui.OptionWidget or OO.ui.DecoratedOptionWidget. For
 * more information, please see the [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // A select widget with three options.
 *     var select = new OO.ui.SelectWidget( {
 *         items: [
 *             new OO.ui.OptionWidget( {
 *                 data: 'a',
 *                 label: 'Option One',
 *             } ),
 *             new OO.ui.OptionWidget( {
 *                 data: 'b',
 *                 label: 'Option Two',
 *             } ),
 *             new OO.ui.OptionWidget( {
 *                 data: 'c',
 *                 label: 'Option Three',
 *             } )
 *         ]
 *     } );
 *     $( document.body ).append( select.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @abstract
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.OptionWidget[]} [items] An array of options to add to the select.
 *  Options are created with {@link OO.ui.OptionWidget OptionWidget} classes. See
 *  the [OOUI documentation on MediaWiki] [2] for examples.
 *  [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 * @cfg {boolean} [multiselect] Allow for multiple selections
 */
OO.ui.SelectWidget = function OoUiSelectWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.SelectWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.GroupWidget.call( this, $.extend( {
    $group: this.$element
  }, config ) );

  // Properties
  this.pressed = false;
  this.selecting = null;
  this.multiselect = !!config.multiselect;
  this.onDocumentMouseUpHandler = this.onDocumentMouseUp.bind( this );
  this.onDocumentMouseMoveHandler = this.onDocumentMouseMove.bind( this );
  this.onDocumentKeyDownHandler = this.onDocumentKeyDown.bind( this );
  this.onDocumentKeyPressHandler = this.onDocumentKeyPress.bind( this );
  this.keyPressBuffer = '';
  this.keyPressBufferTimer = null;
  this.blockMouseOverEvents = 0;

  // Events
  this.connect( this, {
    toggle: 'onToggle'
  } );
  this.$element.on( {
    focusin: this.onFocus.bind( this ),
    mousedown: this.onMouseDown.bind( this ),
    mouseover: this.onMouseOver.bind( this ),
    mouseleave: this.onMouseLeave.bind( this )
  } );

  // Initialization
  this.$element
    .addClass( 'oo-ui-selectWidget oo-ui-selectWidget-unpressed' )
    .attr( 'role', 'listbox' );
  this.setFocusOwner( this.$element );
  if ( Array.isArray( config.items ) ) {
    this.addItems( config.items );
  }
};

/* Setup */

OO.inheritClass( OO.ui.SelectWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.SelectWidget, OO.ui.mixin.GroupWidget );

/* Events */

/**
 * @event highlight
 *
 * A `highlight` event is emitted when the highlight is changed with the #highlightItem method.
 *
 * @param {OO.ui.OptionWidget|null} item Highlighted item
 */

/**
 * @event press
 *
 * A `press` event is emitted when the #pressItem method is used to programmatically modify the
 * pressed state of an option.
 *
 * @param {OO.ui.OptionWidget|null} item Pressed item
 */

/**
 * @event select
 *
 * A `select` event is emitted when the selection is modified programmatically with the #selectItem
 * method.
 *
 * @param {OO.ui.OptionWidget[]|OO.ui.OptionWidget|null} items Currently selected items
 */

/**
 * @event choose
 *
 * A `choose` event is emitted when an item is chosen with the #chooseItem method.
 *
 * @param {OO.ui.OptionWidget} item Chosen item
 * @param {boolean} selected Item is selected
 */

/**
 * @event add
 *
 * An `add` event is emitted when options are added to the select with the #addItems method.
 *
 * @param {OO.ui.OptionWidget[]} items Added items
 * @param {number} index Index of insertion point
 */

/**
 * @event remove
 *
 * A `remove` event is emitted when options are removed from the select with the #clearItems
 * or #removeItems methods.
 *
 * @param {OO.ui.OptionWidget[]} items Removed items
 */

/* Static methods */

/**
 * Normalize text for filter matching
 *
 * @param {string} text Text
 * @return {string} Normalized text
 */
OO.ui.SelectWidget.static.normalizeForMatching = function ( text ) {
  // Replace trailing whitespace, normalize multiple spaces and make case insensitive
  var normalized = text.trim().replace( /\s+/, ' ' ).toLowerCase();

  // Normalize Unicode
  // eslint-disable-next-line no-restricted-properties
  if ( normalized.normalize ) {
    // eslint-disable-next-line no-restricted-properties
    normalized = normalized.normalize();
  }
  return normalized;
};

/* Methods */

/**
 * Handle focus events
 *
 * @private
 * @param {jQuery.Event} event
 */
OO.ui.SelectWidget.prototype.onFocus = function ( event ) {
  var item;
  if ( event.target === this.$element[ 0 ] ) {
    // This widget was focussed, e.g. by the user tabbing to it.
    // The styles for focus state depend on one of the items being selected.
    if ( !this.findSelectedItem() ) {
      item = this.findFirstSelectableItem();
    }
  } else {
    if ( event.target.tabIndex === -1 ) {
      // One of the options got focussed (and the event bubbled up here).
      // They can't be tabbed to, but they can be activated using access keys.
      // OptionWidgets and focusable UI elements inside them have tabindex="-1" set.
      item = this.findTargetItem( event );
      if ( !( item.isHighlightable() || item.isSelectable() ) ) {
        // The item is disabled (weirdly, disabled items can be focussed in Firefox and IE,
        // but not in Chrome). Do nothing (do not highlight or select anything).
        return;
      }
    } else {
      // There is something actually user-focusable in one of the labels of the options, and
      // the user focussed it (e.g. by tabbing to it). Do nothing (especially, don't change
      // the focus).
      return;
    }
  }

  if ( item ) {
    if ( item.constructor.static.highlightable ) {
      this.highlightItem( item );
    } else {
      this.selectItem( item );
    }
  }

  if ( event.target !== this.$element[ 0 ] ) {
    this.$focusOwner.trigger( 'focus' );
  }
};

/**
 * Handle mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onMouseDown = function ( e ) {
  var item;

  if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT ) {
    this.togglePressed( true );
    item = this.findTargetItem( e );
    if ( item && item.isSelectable() ) {
      this.pressItem( item );
      this.selecting = item;
      this.getElementDocument().addEventListener( 'mouseup', this.onDocumentMouseUpHandler, true );
      this.getElementDocument().addEventListener( 'mousemove', this.onDocumentMouseMoveHandler, true );
    }
  }
  return false;
};

/**
 * Handle document mouse up events.
 *
 * @private
 * @param {MouseEvent} e Mouse up event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onDocumentMouseUp = function ( e ) {
  var item;

  this.togglePressed( false );
  if ( !this.selecting ) {
    item = this.findTargetItem( e );
    if ( item && item.isSelectable() ) {
      this.selecting = item;
    }
  }
  if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT && this.selecting ) {
    this.pressItem( null );
    this.chooseItem( this.selecting );
    this.selecting = null;
  }

  this.getElementDocument().removeEventListener( 'mouseup', this.onDocumentMouseUpHandler, true );
  this.getElementDocument().removeEventListener( 'mousemove', this.onDocumentMouseMoveHandler, true );

  return false;
};

/**
 * Handle document mouse move events.
 *
 * @private
 * @param {MouseEvent} e Mouse move event
 */
OO.ui.SelectWidget.prototype.onDocumentMouseMove = function ( e ) {
  var item;

  if ( !this.isDisabled() && this.pressed ) {
    item = this.findTargetItem( e );
    if ( item && item !== this.selecting && item.isSelectable() ) {
      this.pressItem( item );
      this.selecting = item;
    }
  }
};

/**
 * Handle mouse over events.
 *
 * @private
 * @param {jQuery.Event} e Mouse over event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onMouseOver = function ( e ) {
  var item;
  if ( this.blockMouseOverEvents ) {
    return;
  }
  if ( !this.isDisabled() ) {
    item = this.findTargetItem( e );
    this.highlightItem( item && item.isHighlightable() ? item : null );
  }
  return false;
};

/**
 * Handle mouse leave events.
 *
 * @private
 * @param {jQuery.Event} e Mouse over event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onMouseLeave = function () {
  if ( !this.isDisabled() ) {
    this.highlightItem( null );
  }
  return false;
};

/**
 * Handle document key down events.
 *
 * @protected
 * @param {KeyboardEvent} e Key down event
 */
OO.ui.SelectWidget.prototype.onDocumentKeyDown = function ( e ) {
  var nextItem,
    handled = false,
    selected = this.findSelectedItems(),
    currentItem = this.findHighlightedItem() || (
      Array.isArray( selected ) ? selected[ 0 ] : selected
    ),
    firstItem = this.getItems()[ 0 ];

  if ( !this.isDisabled() && this.isVisible() ) {
    switch ( e.keyCode ) {
      case OO.ui.Keys.ENTER:
        if ( currentItem ) {
          // Was only highlighted, now let's select it. No-op if already selected.
          this.chooseItem( currentItem );
          handled = true;
        }
        break;
      case OO.ui.Keys.UP:
      case OO.ui.Keys.LEFT:
        this.clearKeyPressBuffer();
        nextItem = currentItem ?
          this.findRelativeSelectableItem( currentItem, -1 ) : firstItem;
        handled = true;
        break;
      case OO.ui.Keys.DOWN:
      case OO.ui.Keys.RIGHT:
        this.clearKeyPressBuffer();
        nextItem = currentItem ?
          this.findRelativeSelectableItem( currentItem, 1 ) : firstItem;
        handled = true;
        break;
      case OO.ui.Keys.ESCAPE:
      case OO.ui.Keys.TAB:
        if ( currentItem ) {
          currentItem.setHighlighted( false );
        }
        this.unbindDocumentKeyDownListener();
        this.unbindDocumentKeyPressListener();
        // Don't prevent tabbing away / defocusing
        handled = false;
        break;
    }

    if ( nextItem ) {
      if ( nextItem.constructor.static.highlightable ) {
        this.highlightItem( nextItem );
      } else {
        this.chooseItem( nextItem );
      }
      this.scrollItemIntoView( nextItem );
    }

    if ( handled ) {
      e.preventDefault();
      e.stopPropagation();
    }
  }
};

/**
 * Bind document key down listener.
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.bindDocumentKeyDownListener = function () {
  this.getElementDocument().addEventListener( 'keydown', this.onDocumentKeyDownHandler, true );
};

/**
 * Unbind document key down listener.
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.unbindDocumentKeyDownListener = function () {
  this.getElementDocument().removeEventListener( 'keydown', this.onDocumentKeyDownHandler, true );
};

/**
 * Scroll item into view, preventing spurious mouse highlight actions from happening.
 *
 * @param {OO.ui.OptionWidget} item Item to scroll into view
 */
OO.ui.SelectWidget.prototype.scrollItemIntoView = function ( item ) {
  var widget = this;
  // Chromium's Blink engine will generate spurious 'mouseover' events during programmatic
  // scrolling and around 100-150 ms after it is finished.
  this.blockMouseOverEvents++;
  item.scrollElementIntoView().done( function () {
    setTimeout( function () {
      widget.blockMouseOverEvents--;
    }, 200 );
  } );
};

/**
 * Clear the key-press buffer
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.clearKeyPressBuffer = function () {
  if ( this.keyPressBufferTimer ) {
    clearTimeout( this.keyPressBufferTimer );
    this.keyPressBufferTimer = null;
  }
  this.keyPressBuffer = '';
};

/**
 * Handle key press events.
 *
 * @protected
 * @param {KeyboardEvent} e Key press event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.SelectWidget.prototype.onDocumentKeyPress = function ( e ) {
  var c, filter, item, selected;

  if ( !e.charCode ) {
    if ( e.keyCode === OO.ui.Keys.BACKSPACE && this.keyPressBuffer !== '' ) {
      this.keyPressBuffer = this.keyPressBuffer.substr( 0, this.keyPressBuffer.length - 1 );
      return false;
    }
    return;
  }
  // eslint-disable-next-line es/no-string-fromcodepoint
  if ( String.fromCodePoint ) {
    // eslint-disable-next-line es/no-string-fromcodepoint
    c = String.fromCodePoint( e.charCode );
  } else {
    c = String.fromCharCode( e.charCode );
  }

  if ( this.keyPressBufferTimer ) {
    clearTimeout( this.keyPressBufferTimer );
  }
  this.keyPressBufferTimer = setTimeout( this.clearKeyPressBuffer.bind( this ), 1500 );

  selected = this.findSelectedItems();
  item = this.findHighlightedItem() || (
    Array.isArray( selected ) ? selected[ 0 ] : selected
  );

  if ( this.keyPressBuffer === c ) {
    // Common (if weird) special case: typing "xxxx" will cycle through all
    // the items beginning with "x".
    if ( item ) {
      item = this.findRelativeSelectableItem( item, 1 );
    }
  } else {
    this.keyPressBuffer += c;
  }

  filter = this.getItemMatcher( this.keyPressBuffer, false );
  if ( !item || !filter( item ) ) {
    item = this.findRelativeSelectableItem( item, 1, filter );
  }
  if ( item ) {
    if ( this.isVisible() && item.constructor.static.highlightable ) {
      this.highlightItem( item );
    } else {
      this.chooseItem( item );
    }
    this.scrollItemIntoView( item );
  }

  e.preventDefault();
  e.stopPropagation();
};

/**
 * Get a matcher for the specific string
 *
 * @protected
 * @param {string} query String to match against items
 * @param {string} [mode='prefix'] Matching mode: 'substring', 'prefix', or 'exact'
 * @return {Function} function ( OO.ui.OptionWidget ) => boolean
 */
OO.ui.SelectWidget.prototype.getItemMatcher = function ( query, mode ) {
  var normalizeForMatching = this.constructor.static.normalizeForMatching,
    normalizedQuery = normalizeForMatching( query );

  // Support deprecated exact=true argument
  if ( mode === true ) {
    mode = 'exact';
  }

  return function ( item ) {
    var matchText = normalizeForMatching( item.getMatchText() );

    if ( normalizedQuery === '' ) {
      // Empty string matches all, except if we are in 'exact'
      // mode, where it doesn't match at all
      return mode !== 'exact';
    }

    switch ( mode ) {
      case 'exact':
        return matchText === normalizedQuery;
      case 'substring':
        return matchText.indexOf( normalizedQuery ) !== -1;
      // 'prefix'
      default:
        return matchText.indexOf( normalizedQuery ) === 0;
    }
  };
};

/**
 * Bind document key press listener.
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.bindDocumentKeyPressListener = function () {
  this.getElementDocument().addEventListener( 'keypress', this.onDocumentKeyPressHandler, true );
};

/**
 * Unbind document key down listener.
 *
 * If you override this, be sure to call this.clearKeyPressBuffer() from your
 * implementation.
 *
 * @protected
 */
OO.ui.SelectWidget.prototype.unbindDocumentKeyPressListener = function () {
  this.getElementDocument().removeEventListener( 'keypress', this.onDocumentKeyPressHandler, true );
  this.clearKeyPressBuffer();
};

/**
 * Visibility change handler
 *
 * @protected
 * @param {boolean} visible
 */
OO.ui.SelectWidget.prototype.onToggle = function ( visible ) {
  if ( !visible ) {
    this.clearKeyPressBuffer();
  }
};

/**
 * Get the closest item to a jQuery.Event.
 *
 * @private
 * @param {jQuery.Event} e
 * @return {OO.ui.OptionWidget|null} Outline item widget, `null` if none was found
 */
OO.ui.SelectWidget.prototype.findTargetItem = function ( e ) {
  var $option = $( e.target ).closest( '.oo-ui-optionWidget' );
  if ( !$option.closest( '.oo-ui-selectWidget' ).is( this.$element ) ) {
    return null;
  }
  return $option.data( 'oo-ui-optionWidget' ) || null;
};

/**
 * Find all selected items, if there are any. If the widget allows for multiselect
 * it will return an array of selected options. If the widget doesn't allow for
 * multiselect, it will return the selected option or null if no item is selected.
 *
 * @return {OO.ui.OptionWidget[]|OO.ui.OptionWidget|null} If the widget is multiselect
 *  then return an array of selected items (or empty array),
 *  if the widget is not multiselect, return a single selected item, or `null`
 *  if no item is selected
 */
OO.ui.SelectWidget.prototype.findSelectedItems = function () {
  var selected = this.items.filter( function ( item ) {
    return item.isSelected();
  } );

  return this.multiselect ?
    selected :
    selected[ 0 ] || null;
};

/**
 * Find selected item.
 *
 * @return {OO.ui.OptionWidget[]|OO.ui.OptionWidget|null} If the widget is multiselect
 *  then return an array of selected items (or empty array),
 *  if the widget is not multiselect, return a single selected item, or `null`
 *  if no item is selected
 */
OO.ui.SelectWidget.prototype.findSelectedItem = function () {
  return this.findSelectedItems();
};

/**
 * Find highlighted item.
 *
 * @return {OO.ui.OptionWidget|null} Highlighted item, `null` if no item is highlighted
 */
OO.ui.SelectWidget.prototype.findHighlightedItem = function () {
  var i, len;

  for ( i = 0, len = this.items.length; i < len; i++ ) {
    if ( this.items[ i ].isHighlighted() ) {
      return this.items[ i ];
    }
  }
  return null;
};

/**
 * Toggle pressed state.
 *
 * Press is a state that occurs when a user mouses down on an item, but
 * has not yet let go of the mouse. The item may appear selected, but it will not be selected
 * until the user releases the mouse.
 *
 * @param {boolean} pressed An option is being pressed
 */
OO.ui.SelectWidget.prototype.togglePressed = function ( pressed ) {
  if ( pressed === undefined ) {
    pressed = !this.pressed;
  }
  if ( pressed !== this.pressed ) {
    this.$element
      .toggleClass( 'oo-ui-selectWidget-pressed', pressed )
      .toggleClass( 'oo-ui-selectWidget-unpressed', !pressed );
    this.pressed = pressed;
  }
};

/**
 * Highlight an option. If the `item` param is omitted, no options will be highlighted
 * and any existing highlight will be removed. The highlight is mutually exclusive.
 *
 * @param {OO.ui.OptionWidget} [item] Item to highlight, omit for no highlight
 * @fires highlight
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.highlightItem = function ( item ) {
  var i, len, highlighted,
    changed = false;

  for ( i = 0, len = this.items.length; i < len; i++ ) {
    highlighted = this.items[ i ] === item;
    if ( this.items[ i ].isHighlighted() !== highlighted ) {
      this.items[ i ].setHighlighted( highlighted );
      changed = true;
    }
  }
  if ( changed ) {
    if ( item ) {
      this.$focusOwner.attr( 'aria-activedescendant', item.getElementId() );
    } else {
      this.$focusOwner.removeAttr( 'aria-activedescendant' );
    }
    this.emit( 'highlight', item );
  }

  return this;
};

/**
 * Fetch an item by its label.
 *
 * @param {string} label Label of the item to select.
 * @param {boolean} [prefix=false] Allow a prefix match, if only a single item matches
 * @return {OO.ui.Element|null} Item with equivalent label, `null` if none exists
 */
OO.ui.SelectWidget.prototype.getItemFromLabel = function ( label, prefix ) {
  var i, item, found,
    len = this.items.length,
    filter = this.getItemMatcher( label, 'exact' );

  for ( i = 0; i < len; i++ ) {
    item = this.items[ i ];
    if ( item instanceof OO.ui.OptionWidget && item.isSelectable() && filter( item ) ) {
      return item;
    }
  }

  if ( prefix ) {
    found = null;
    filter = this.getItemMatcher( label, 'prefix' );
    for ( i = 0; i < len; i++ ) {
      item = this.items[ i ];
      if ( item instanceof OO.ui.OptionWidget && item.isSelectable() && filter( item ) ) {
        if ( found ) {
          return null;
        }
        found = item;
      }
    }
    if ( found ) {
      return found;
    }
  }

  return null;
};

/**
 * Programmatically select an option by its label. If the item does not exist,
 * all options will be deselected.
 *
 * @param {string} [label] Label of the item to select.
 * @param {boolean} [prefix=false] Allow a prefix match, if only a single item matches
 * @fires select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.selectItemByLabel = function ( label, prefix ) {
  var itemFromLabel = this.getItemFromLabel( label, !!prefix );
  if ( label === undefined || !itemFromLabel ) {
    return this.selectItem();
  }
  return this.selectItem( itemFromLabel );
};

/**
 * Programmatically select an option by its data. If the `data` parameter is omitted,
 * or if the item does not exist, all options will be deselected.
 *
 * @param {Object|string} [data] Value of the item to select, omit to deselect all
 * @fires select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.selectItemByData = function ( data ) {
  var itemFromData = this.findItemFromData( data );
  if ( data === undefined || !itemFromData ) {
    return this.selectItem();
  }
  return this.selectItem( itemFromData );
};

/**
 * Programmatically unselect an option by its reference. If the widget
 * allows for multiple selections, there may be other items still selected;
 * otherwise, no items will be selected.
 * If no item is given, all selected items will be unselected.
 *
 * @param {OO.ui.OptionWidget} [item] Item to unselect
 * @fires select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.unselectItem = function ( item ) {
  if ( item ) {
    item.setSelected( false );
  } else {
    this.items.forEach( function ( item ) {
      if ( item.isSelected() ) {
        item.setSelected( false );
      }
    } );
  }

  this.emit( 'select', this.findSelectedItems() );
  return this;
};

/**
 * Programmatically select an option by its reference. If the `item` parameter is omitted,
 * all options will be deselected.
 *
 * @param {OO.ui.OptionWidget} [item] Item to select, omit to deselect all
 * @fires select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.selectItem = function ( item ) {
  var i, len, selected,
    changed = false;

  if ( this.multiselect && item ) {
    // Select the item directly
    item.setSelected( true );
  } else {
    for ( i = 0, len = this.items.length; i < len; i++ ) {
      selected = this.items[ i ] === item;
      if ( this.items[ i ].isSelected() !== selected ) {
        this.items[ i ].setSelected( selected );
        changed = true;
      }
    }
  }
  if ( changed ) {
    // TODO: When should a non-highlightable element be selected?
    if ( item && !item.constructor.static.highlightable ) {
      if ( item ) {
        this.$focusOwner.attr( 'aria-activedescendant', item.getElementId() );
      } else {
        this.$focusOwner.removeAttr( 'aria-activedescendant' );
      }
    }
    this.emit( 'select', this.findSelectedItems() );
  }

  return this;
};

/**
 * Press an item.
 *
 * Press is a state that occurs when a user mouses down on an item, but has not
 * yet let go of the mouse. The item may appear selected, but it will not be selected until the user
 * releases the mouse.
 *
 * @param {OO.ui.OptionWidget} [item] Item to press, omit to depress all
 * @fires press
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.pressItem = function ( item ) {
  var i, len, pressed,
    changed = false;

  for ( i = 0, len = this.items.length; i < len; i++ ) {
    pressed = this.items[ i ] === item;
    if ( this.items[ i ].isPressed() !== pressed ) {
      this.items[ i ].setPressed( pressed );
      changed = true;
    }
  }
  if ( changed ) {
    this.emit( 'press', item );
  }

  return this;
};

/**
 * Choose an item.
 *
 * Note that ‘choose’ should never be modified programmatically. A user can choose
 * an option with the keyboard or mouse and it becomes selected. To select an item programmatically,
 * use the #selectItem method.
 *
 * This method is identical to #selectItem, but may vary in subclasses that take additional action
 * when users choose an item with the keyboard or mouse.
 *
 * @param {OO.ui.OptionWidget} item Item to choose
 * @fires choose
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.chooseItem = function ( item ) {
  if ( item ) {
    if ( this.multiselect && item.isSelected() ) {
      this.unselectItem( item );
    } else {
      this.selectItem( item );
    }

    this.emit( 'choose', item, item.isSelected() );
  }

  return this;
};

/**
 * Find an option by its position relative to the specified item (or to the start of the option
 * array, if item is `null`). The direction in which to search through the option array is specified
 * with a number: -1 for reverse (the default) or 1 for forward. The method will return an option,
 * or `null` if there are no options in the array.
 *
 * @param {OO.ui.OptionWidget|null} item Item to describe the start position, or `null` to start at
 *  the beginning of the array.
 * @param {number} direction Direction to move in: -1 to move backward, 1 to move forward
 * @param {Function} [filter] Only consider items for which this function returns
 *  true. Function takes an OO.ui.OptionWidget and returns a boolean.
 * @return {OO.ui.OptionWidget|null} Item at position, `null` if there are no items in the select
 */
OO.ui.SelectWidget.prototype.findRelativeSelectableItem = function ( item, direction, filter ) {
  var currentIndex, nextIndex, i,
    increase = direction > 0 ? 1 : -1,
    len = this.items.length;

  if ( item instanceof OO.ui.OptionWidget ) {
    currentIndex = this.items.indexOf( item );
    nextIndex = ( currentIndex + increase + len ) % len;
  } else {
    // If no item is selected and moving forward, start at the beginning.
    // If moving backward, start at the end.
    nextIndex = direction > 0 ? 0 : len - 1;
  }

  for ( i = 0; i < len; i++ ) {
    item = this.items[ nextIndex ];
    if (
      item instanceof OO.ui.OptionWidget && item.isSelectable() &&
      ( !filter || filter( item ) )
    ) {
      return item;
    }
    nextIndex = ( nextIndex + increase + len ) % len;
  }
  return null;
};

/**
 * Find the next selectable item or `null` if there are no selectable items.
 * Disabled options and menu-section markers and breaks are not selectable.
 *
 * @return {OO.ui.OptionWidget|null} Item, `null` if there aren't any selectable items
 */
OO.ui.SelectWidget.prototype.findFirstSelectableItem = function () {
  return this.findRelativeSelectableItem( null, 1 );
};

/**
 * Add an array of options to the select. Optionally, an index number can be used to
 * specify an insertion point.
 *
 * @param {OO.ui.OptionWidget[]} items Items to add
 * @param {number} [index] Index to insert items after
 * @fires add
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.addItems = function ( items, index ) {
  // Mixin method
  OO.ui.mixin.GroupWidget.prototype.addItems.call( this, items, index );

  // Always provide an index, even if it was omitted
  this.emit( 'add', items, index === undefined ? this.items.length - items.length - 1 : index );

  return this;
};

/**
 * Remove the specified array of options from the select. Options will be detached
 * from the DOM, not removed, so they can be reused later. To remove all options from
 * the select, you may wish to use the #clearItems method instead.
 *
 * @param {OO.ui.OptionWidget[]} items Items to remove
 * @fires remove
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.removeItems = function ( items ) {
  var i, len, item;

  // Deselect items being removed
  for ( i = 0, len = items.length; i < len; i++ ) {
    item = items[ i ];
    if ( item.isSelected() ) {
      this.selectItem( null );
    }
  }

  // Mixin method
  OO.ui.mixin.GroupWidget.prototype.removeItems.call( this, items );

  this.emit( 'remove', items );

  return this;
};

/**
 * Clear all options from the select. Options will be detached from the DOM, not removed,
 * so that they can be reused later. To remove a subset of options from the select, use
 * the #removeItems method.
 *
 * @fires remove
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.SelectWidget.prototype.clearItems = function () {
  var items = this.items.slice();

  // Mixin method
  OO.ui.mixin.GroupWidget.prototype.clearItems.call( this );

  // Clear selection
  this.selectItem( null );

  this.emit( 'remove', items );

  return this;
};

/**
 * Set the DOM element which has focus while the user is interacting with this SelectWidget.
 *
 * This is used to set `aria-activedescendant` and `aria-expanded` on it.
 *
 * @protected
 * @param {jQuery} $focusOwner
 */
OO.ui.SelectWidget.prototype.setFocusOwner = function ( $focusOwner ) {
  this.$focusOwner = $focusOwner;
};

/**
 * DecoratedOptionWidgets are {@link OO.ui.OptionWidget options} that can be configured
 * with an {@link OO.ui.mixin.IconElement icon} and/or
 * {@link OO.ui.mixin.IndicatorElement indicator}.
 * This class is used with OO.ui.SelectWidget to create a selection of mutually exclusive
 * options. For more information about options and selects, please see the
 * [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // Decorated options in a select widget.
 *     var select = new OO.ui.SelectWidget( {
 *         items: [
 *             new OO.ui.DecoratedOptionWidget( {
 *                 data: 'a',
 *                 label: 'Option with icon',
 *                 icon: 'help'
 *             } ),
 *             new OO.ui.DecoratedOptionWidget( {
 *                 data: 'b',
 *                 label: 'Option with indicator',
 *                 indicator: 'next'
 *             } )
 *         ]
 *     } );
 *     $( document.body ).append( select.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.OptionWidget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.DecoratedOptionWidget = function OoUiDecoratedOptionWidget( config ) {
  // Parent constructor
  OO.ui.DecoratedOptionWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.IndicatorElement.call( this, config );

  // Initialization
  this.$element
    .addClass( 'oo-ui-decoratedOptionWidget' )
    .prepend( this.$icon )
    .append( this.$indicator );
};

/* Setup */

OO.inheritClass( OO.ui.DecoratedOptionWidget, OO.ui.OptionWidget );
OO.mixinClass( OO.ui.DecoratedOptionWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.DecoratedOptionWidget, OO.ui.mixin.IndicatorElement );

/**
 * MenuOptionWidget is an option widget that looks like a menu item. The class is used with
 * OO.ui.MenuSelectWidget to create a menu of mutually exclusive options. Please see
 * the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Menu_selects_and_options
 *
 * @class
 * @extends OO.ui.DecoratedOptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.MenuOptionWidget = function OoUiMenuOptionWidget( config ) {
  // Parent constructor
  OO.ui.MenuOptionWidget.super.call( this, config );

  // Properties
  this.checkIcon = new OO.ui.IconWidget( {
    icon: 'check',
    classes: [ 'oo-ui-menuOptionWidget-checkIcon' ]
  } );

  // Initialization
  this.$element
    .prepend( this.checkIcon.$element )
    .addClass( 'oo-ui-menuOptionWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.MenuOptionWidget, OO.ui.DecoratedOptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.MenuOptionWidget.static.scrollIntoViewOnSelect = true;

/**
 * MenuSectionOptionWidgets are used inside {@link OO.ui.MenuSelectWidget menu select widgets} to
 * group one or more related {@link OO.ui.MenuOptionWidget menu options}. MenuSectionOptionWidgets
 * cannot be highlighted or selected.
 *
 *     @example
 *     var dropdown = new OO.ui.DropdownWidget( {
 *         menu: {
 *             items: [
 *                 new OO.ui.MenuSectionOptionWidget( {
 *                     label: 'Dogs'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'corgi',
 *                     label: 'Welsh Corgi'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'poodle',
 *                     label: 'Standard Poodle'
 *                 } ),
 *                 new OO.ui.MenuSectionOptionWidget( {
 *                     label: 'Cats'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'lion',
 *                     label: 'Lion'
 *                 } )
 *             ]
 *         }
 *     } );
 *     $( document.body ).append( dropdown.$element );
 *
 * @class
 * @extends OO.ui.DecoratedOptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.MenuSectionOptionWidget = function OoUiMenuSectionOptionWidget( config ) {
  // Parent constructor
  OO.ui.MenuSectionOptionWidget.super.call( this, config );

  // Initialization
  this.$element
    .addClass( 'oo-ui-menuSectionOptionWidget' )
    .removeAttr( 'role aria-selected' );
  this.selected = false;
};

/* Setup */

OO.inheritClass( OO.ui.MenuSectionOptionWidget, OO.ui.DecoratedOptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.MenuSectionOptionWidget.static.selectable = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.MenuSectionOptionWidget.static.highlightable = false;

/**
 * MenuSelectWidget is a {@link OO.ui.SelectWidget select widget} that contains options and
 * is used together with OO.ui.MenuOptionWidget. It is designed be used as part of another widget.
 * See {@link OO.ui.DropdownWidget DropdownWidget},
 * {@link OO.ui.ComboBoxInputWidget ComboBoxInputWidget}, and
 * {@link OO.ui.mixin.LookupElement LookupElement} for examples of widgets that contain menus.
 * MenuSelectWidgets themselves are not instantiated directly, rather subclassed
 * and customized to be opened, closed, and displayed as needed.
 *
 * By default, menus are clipped to the visible viewport and are not visible when a user presses the
 * mouse outside the menu.
 *
 * Menus also have support for keyboard interaction:
 *
 * - Enter/Return key: choose and select a menu option
 * - Up-arrow key: highlight the previous menu option
 * - Down-arrow key: highlight the next menu option
 * - Escape key: hide the menu
 *
 * Unlike most widgets, MenuSelectWidget is initially hidden and must be shown by calling #toggle.
 *
 * Please see the [OOUI documentation on MediaWiki][1] for more information.
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.ClippableElement
 * @mixins OO.ui.mixin.FloatableElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.TextInputWidget} [input] Text input used to implement option highlighting for menu
 *  items that match the text the user types. This config is used by
 *  {@link OO.ui.ComboBoxInputWidget ComboBoxInputWidget} and
 *  {@link OO.ui.mixin.LookupElement LookupElement}
 * @cfg {jQuery} [$input] Text input used to implement option highlighting for menu items that match
 *  the text the user types. This config is used by
 *  {@link OO.ui.TagMultiselectWidget TagMultiselectWidget}
 * @cfg {OO.ui.Widget} [widget] Widget associated with the menu's active state. If the user clicks
 *  the mouse anywhere on the page outside of this widget, the menu is hidden. For example, if
 *  there is a button that toggles the menu's visibility on click, the menu will be hidden then
 *  re-shown when the user clicks that button, unless the button (or its parent widget) is passed
 *  in here.
 * @cfg {boolean} [autoHide=true] Hide the menu when the mouse is pressed outside the menu.
 * @cfg {jQuery} [$autoCloseIgnore] If these elements are clicked, don't auto-hide the menu.
 * @cfg {boolean} [hideOnChoose=true] Hide the menu when the user chooses an option.
 * @cfg {boolean} [filterFromInput=false] Filter the displayed options from the input
 * @cfg {boolean} [highlightOnFilter] Highlight the first result when filtering
 * @cfg {string} [filterMode='prefix'] The mode by which the menu filters the results.
 *  Options are 'exact', 'prefix' or 'substring'. See `OO.ui.SelectWidget#getItemMatcher`
 * @cfg {number|string} [width] Width of the menu as a number of pixels or CSS string with unit
 *  suffix, used by {@link OO.ui.mixin.ClippableElement ClippableElement}
 */
OO.ui.MenuSelectWidget = function OoUiMenuSelectWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.MenuSelectWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.ClippableElement.call( this, $.extend( { $clippable: this.$group }, config ) );
  OO.ui.mixin.FloatableElement.call( this, config );

  // Initial vertical positions other than 'center' will result in
  // the menu being flipped if there is not enough space in the container.
  // Store the original position so we know what to reset to.
  this.originalVerticalPosition = this.verticalPosition;

  // Properties
  this.autoHide = config.autoHide === undefined || !!config.autoHide;
  this.hideOnChoose = config.hideOnChoose === undefined || !!config.hideOnChoose;
  this.filterFromInput = !!config.filterFromInput;
  this.$input = config.$input ? config.$input : config.input ? config.input.$input : null;
  this.$widget = config.widget ? config.widget.$element : null;
  this.$autoCloseIgnore = config.$autoCloseIgnore || $( [] );
  this.onDocumentMouseDownHandler = this.onDocumentMouseDown.bind( this );
  this.onInputEditHandler = OO.ui.debounce( this.updateItemVisibility.bind( this ), 100 );
  this.highlightOnFilter = !!config.highlightOnFilter;
  this.lastHighlightedItem = null;
  this.width = config.width;
  this.filterMode = config.filterMode;

  // Initialization
  this.$element.addClass( 'oo-ui-menuSelectWidget' );
  if ( config.widget ) {
    this.setFocusOwner( config.widget.$tabIndexed );
  }

  // Initially hidden - using #toggle may cause errors if subclasses override toggle with methods
  // that reference properties not initialized at that time of parent class construction
  // TODO: Find a better way to handle post-constructor setup
  this.visible = false;
  this.$element.addClass( 'oo-ui-element-hidden' );
  this.$focusOwner.attr( 'aria-expanded', 'false' );
};

/* Setup */

OO.inheritClass( OO.ui.MenuSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.MenuSelectWidget, OO.ui.mixin.ClippableElement );
OO.mixinClass( OO.ui.MenuSelectWidget, OO.ui.mixin.FloatableElement );

/* Events */

/**
 * @event ready
 *
 * The menu is ready: it is visible and has been positioned and clipped.
 */

/* Static properties */

/**
 * Positions to flip to if there isn't room in the container for the
 * menu in a specific direction.
 *
 * @property {Object.<string,string>}
 */
OO.ui.MenuSelectWidget.static.flippedPositions = {
  below: 'above',
  above: 'below',
  top: 'bottom',
  bottom: 'top'
};

/* Methods */

/**
 * Handles document mouse down events.
 *
 * @protected
 * @param {MouseEvent} e Mouse down event
 */
OO.ui.MenuSelectWidget.prototype.onDocumentMouseDown = function ( e ) {
  if (
    this.isVisible() &&
    !OO.ui.contains(
      this.$element.add( this.$widget ).add( this.$autoCloseIgnore ).get(),
      e.target,
      true
    )
  ) {
    this.toggle( false );
  }
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.onDocumentKeyDown = function ( e ) {
  var handled = false,
    selected = this.findSelectedItems(),
    currentItem = this.findHighlightedItem() || (
      Array.isArray( selected ) ? selected[ 0 ] : selected
    );

  if ( !this.isDisabled() && this.isVisible() && this.getVisibleItems().length ) {
    switch ( e.keyCode ) {
      case OO.ui.Keys.TAB:
        if ( currentItem ) {
          // Was only highlighted, now let's select it. No-op if already selected.
          this.chooseItem( currentItem );
          handled = true;
        }
        this.toggle( false );
        break;
      case OO.ui.Keys.LEFT:
      case OO.ui.Keys.RIGHT:
        // Do nothing if a text field is associated, arrow keys will be handled natively
        if ( !this.$input ) {
          OO.ui.MenuSelectWidget.super.prototype.onDocumentKeyDown.call( this, e );
        }
        break;
      case OO.ui.Keys.ESCAPE:
        if ( currentItem && !this.multiselect ) {
          currentItem.setHighlighted( false );
        }
        this.toggle( false );
        handled = true;
        break;
      default:
        return OO.ui.MenuSelectWidget.super.prototype.onDocumentKeyDown.call( this, e );
    }
    if ( handled ) {
      e.preventDefault();
      e.stopPropagation();
    }
  }
};

/**
 * Return the visible items in the menu.
 *
 * @return {OO.ui.MenuOptionWidget[]} Visible items
 */
OO.ui.MenuSelectWidget.prototype.getVisibleItems = function () {
  return this.getItems().filter( function ( item ) {
    return item.isVisible();
  } );
};

/**
 * Update menu item visibility and clipping after input changes (if filterFromInput is enabled)
 * or after items were added/removed (always).
 *
 * @protected
 */
OO.ui.MenuSelectWidget.prototype.updateItemVisibility = function () {
  var i, item, items, visible, section, sectionEmpty, filter, exactFilter,
    anyVisible = false,
    len = this.items.length,
    showAll = !this.isVisible(),
    exactMatch = false;

  if ( this.$input && this.filterFromInput ) {
    filter = showAll ? null : this.getItemMatcher( this.$input.val(), this.filterMode );
    exactFilter = this.getItemMatcher( this.$input.val(), 'exact' );
    // Hide non-matching options, and also hide section headers if all options
    // in their section are hidden.
    for ( i = 0; i < len; i++ ) {
      item = this.items[ i ];
      if ( item instanceof OO.ui.MenuSectionOptionWidget ) {
        if ( section ) {
          // If the previous section was empty, hide its header
          section.toggle( showAll || !sectionEmpty );
        }
        section = item;
        sectionEmpty = true;
      } else if ( item instanceof OO.ui.OptionWidget ) {
        visible = showAll || filter( item );
        exactMatch = exactMatch || exactFilter( item );
        anyVisible = anyVisible || visible;
        sectionEmpty = sectionEmpty && !visible;
        item.toggle( visible );
      }
    }
    // Process the final section
    if ( section ) {
      section.toggle( showAll || !sectionEmpty );
    }

    if ( !anyVisible ) {
      this.highlightItem( null );
    }

    this.$element.toggleClass( 'oo-ui-menuSelectWidget-invisible', !anyVisible );

    if (
      this.highlightOnFilter &&
      !( this.lastHighlightedItem && this.lastHighlightedItem.isVisible() ) &&
      this.isVisible()
    ) {
      // Highlight the first item on the list
      item = null;
      items = this.getItems();
      for ( i = 0; i < items.length; i++ ) {
        if ( items[ i ].isVisible() ) {
          item = items[ i ];
          break;
        }
      }
      this.highlightItem( item );
      this.lastHighlightedItem = item;
    }
  }

  // Reevaluate clipping
  this.clip();
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.bindDocumentKeyDownListener = function () {
  if ( this.$input ) {
    this.$input.on( 'keydown', this.onDocumentKeyDownHandler );
  } else {
    OO.ui.MenuSelectWidget.super.prototype.bindDocumentKeyDownListener.call( this );
  }
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.unbindDocumentKeyDownListener = function () {
  if ( this.$input ) {
    this.$input.off( 'keydown', this.onDocumentKeyDownHandler );
  } else {
    OO.ui.MenuSelectWidget.super.prototype.unbindDocumentKeyDownListener.call( this );
  }
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.bindDocumentKeyPressListener = function () {
  if ( this.$input ) {
    if ( this.filterFromInput ) {
      this.$input.on(
        'keydown mouseup cut paste change input select',
        this.onInputEditHandler
      );
      this.updateItemVisibility();
    }
  } else {
    OO.ui.MenuSelectWidget.super.prototype.bindDocumentKeyPressListener.call( this );
  }
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.unbindDocumentKeyPressListener = function () {
  if ( this.$input ) {
    if ( this.filterFromInput ) {
      this.$input.off(
        'keydown mouseup cut paste change input select',
        this.onInputEditHandler
      );
      this.updateItemVisibility();
    }
  } else {
    OO.ui.MenuSelectWidget.super.prototype.unbindDocumentKeyPressListener.call( this );
  }
};

/**
 * Choose an item.
 *
 * When a user chooses an item, the menu is closed, unless the hideOnChoose config option is
 * set to false.
 *
 * Note that ‘choose’ should never be modified programmatically. A user can choose an option with
 * the keyboard or mouse and it becomes selected. To select an item programmatically,
 * use the #selectItem method.
 *
 * @param {OO.ui.OptionWidget} item Item to choose
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.MenuSelectWidget.prototype.chooseItem = function ( item ) {
  OO.ui.MenuSelectWidget.super.prototype.chooseItem.call( this, item );
  if ( this.hideOnChoose ) {
    this.toggle( false );
  }
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.addItems = function ( items, index ) {
  // Parent method
  OO.ui.MenuSelectWidget.super.prototype.addItems.call( this, items, index );

  this.updateItemVisibility();

  return this;
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.removeItems = function ( items ) {
  // Parent method
  OO.ui.MenuSelectWidget.super.prototype.removeItems.call( this, items );

  this.updateItemVisibility();

  return this;
};

/**
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.clearItems = function () {
  // Parent method
  OO.ui.MenuSelectWidget.super.prototype.clearItems.call( this );

  this.updateItemVisibility();

  return this;
};

/**
 * Toggle visibility of the menu. The menu is initially hidden and must be shown by calling
 * `.toggle( true )` after its #$element is attached to the DOM.
 *
 * Do not show the menu while it is not attached to the DOM. The calculations required to display
 * it in the right place and with the right dimensions only work correctly while it is attached.
 * Side-effects may include broken interface and exceptions being thrown. This wasn't always
 * strictly enforced, so currently it only generates a warning in the browser console.
 *
 * @fires ready
 * @inheritdoc
 */
OO.ui.MenuSelectWidget.prototype.toggle = function ( visible ) {
  var change, originalHeight, flippedHeight, selectedItem;

  visible = ( visible === undefined ? !this.visible : !!visible ) && !!this.items.length;
  change = visible !== this.isVisible();

  if ( visible && !this.warnedUnattached && !this.isElementAttached() ) {
    OO.ui.warnDeprecation( 'MenuSelectWidget#toggle: Before calling this method, the menu must be attached to the DOM.' );
    this.warnedUnattached = true;
  }

  if ( change && visible ) {
    // Reset position before showing the popup again. It's possible we no longer need to flip
    // (e.g. if the user scrolled).
    this.setVerticalPosition( this.originalVerticalPosition );
  }

  // Parent method
  OO.ui.MenuSelectWidget.super.prototype.toggle.call( this, visible );

  if ( change ) {
    if ( visible ) {

      if ( this.width ) {
        this.setIdealSize( this.width );
      } else if ( this.$floatableContainer ) {
        this.$clippable.css( 'width', 'auto' );
        this.setIdealSize(
          this.$floatableContainer[ 0 ].offsetWidth > this.$clippable[ 0 ].offsetWidth ?
            // Dropdown is smaller than handle so expand to width
            this.$floatableContainer[ 0 ].offsetWidth :
            // Dropdown is larger than handle so auto size
            'auto'
        );
        this.$clippable.css( 'width', '' );
      }

      this.togglePositioning( !!this.$floatableContainer );
      this.toggleClipping( true );

      this.bindDocumentKeyDownListener();
      this.bindDocumentKeyPressListener();

      if (
        ( this.isClippedVertically() || this.isFloatableOutOfView() ) &&
        this.originalVerticalPosition !== 'center'
      ) {
        // If opening the menu in one direction causes it to be clipped, flip it
        originalHeight = this.$element.height();
        this.setVerticalPosition(
          this.constructor.static.flippedPositions[ this.originalVerticalPosition ]
        );
        if ( this.isClippedVertically() || this.isFloatableOutOfView() ) {
          // If flipping also causes it to be clipped, open in whichever direction
          // we have more space
          flippedHeight = this.$element.height();
          if ( originalHeight > flippedHeight ) {
            this.setVerticalPosition( this.originalVerticalPosition );
          }
        }
      }
      // Note that we do not flip the menu's opening direction if the clipping changes
      // later (e.g. after the user scrolls), that seems like it would be annoying

      this.$focusOwner.attr( 'aria-expanded', 'true' );

      selectedItem = this.findSelectedItem();
      if ( !this.multiselect && selectedItem ) {
        // TODO: Verify if this is even needed; This is already done on highlight changes
        // in SelectWidget#highlightItem, so we should just need to highlight the item
        // we need to highlight here and not bother with attr or checking selections.
        this.$focusOwner.attr( 'aria-activedescendant', selectedItem.getElementId() );
        selectedItem.scrollElementIntoView( { duration: 0 } );
      }

      // Auto-hide
      if ( this.autoHide ) {
        this.getElementDocument().addEventListener( 'mousedown', this.onDocumentMouseDownHandler, true );
      }

      this.emit( 'ready' );
    } else {
      this.$focusOwner.removeAttr( 'aria-activedescendant' );
      this.unbindDocumentKeyDownListener();
      this.unbindDocumentKeyPressListener();
      this.$focusOwner.attr( 'aria-expanded', 'false' );
      this.getElementDocument().removeEventListener( 'mousedown', this.onDocumentMouseDownHandler, true );
      this.togglePositioning( false );
      this.toggleClipping( false );
      this.lastHighlightedItem = null;
    }
  }

  return this;
};

/**
 * Scroll to the top of the menu
 */
OO.ui.MenuSelectWidget.prototype.scrollToTop = function () {
  this.$element.scrollTop( 0 );
};

/**
 * DropdownWidgets are not menus themselves, rather they contain a menu of options created with
 * OO.ui.MenuOptionWidget. The DropdownWidget takes care of opening and displaying the menu so that
 * users can interact with it.
 *
 * If you want to use this within an HTML form, such as a OO.ui.FormLayout, use
 * OO.ui.DropdownInputWidget instead.
 *
 *     @example
 *     // A DropdownWidget with a menu that contains three options.
 *     var dropDown = new OO.ui.DropdownWidget( {
 *         label: 'Dropdown menu: Select a menu option',
 *         menu: {
 *             items: [
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'a',
 *                     label: 'First'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'b',
 *                     label: 'Second'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'c',
 *                     label: 'Third'
 *                 } )
 *             ]
 *         }
 *     } );
 *
 *     $( document.body ).append( dropDown.$element );
 *
 *     dropDown.getMenu().selectItemByData( 'b' );
 *
 *     dropDown.getMenu().findSelectedItem().getData(); // Returns 'b'.
 *
 * For more information, please see the [OOUI documentation on MediaWiki] [1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Menu_selects_and_options
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object} [menu] Configuration options to pass to
 *  {@link OO.ui.MenuSelectWidget menu select widget}.
 * @cfg {jQuery|boolean} [$overlay] Render the menu into a separate layer. This configuration is
 *  useful in cases where the expanded menu is larger than its containing `<div>`. The specified
 *  overlay layer is usually on top of the containing `<div>` and has a larger area. By default,
 *  the menu uses relative positioning. Pass 'true' to use the default overlay.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.DropdownWidget = function OoUiDropdownWidget( config ) {
  var labelId;

  // Configuration initialization
  config = $.extend( { indicator: 'down' }, config );

  // Parent constructor
  OO.ui.DropdownWidget.super.call( this, config );

  // Properties (must be set before TabIndexedElement constructor call)
  this.$handle = $( '<span>' );
  this.$overlay = ( config.$overlay === true ?
    OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;

  // Mixin constructors
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.IndicatorElement.call( this, config );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.TitledElement.call( this, $.extend( {
    $titled: this.$label
  }, config ) );
  OO.ui.mixin.TabIndexedElement.call( this, $.extend( {
    $tabIndexed: this.$handle
  }, config ) );

  // Properties
  this.menu = new OO.ui.MenuSelectWidget( $.extend( {
    widget: this,
    $floatableContainer: this.$element
  }, config.menu ) );

  // Events
  this.$handle.on( {
    click: this.onClick.bind( this ),
    keydown: this.onKeyDown.bind( this ),
    // Hack? Handle type-to-search when menu is not expanded and not handling its own events.
    keypress: this.menu.onDocumentKeyPressHandler,
    blur: this.menu.clearKeyPressBuffer.bind( this.menu )
  } );
  this.menu.connect( this, {
    select: 'onMenuSelect',
    toggle: 'onMenuToggle'
  } );

  // Initialization
  labelId = OO.ui.generateElementId();
  this.setLabelId( labelId );
  this.$label
    .attr( {
      role: 'textbox',
      'aria-readonly': 'true'
    } );
  this.$handle
    .addClass( 'oo-ui-dropdownWidget-handle' )
    .append( this.$icon, this.$label, this.$indicator )
    .attr( {
      role: 'combobox',
      'aria-autocomplete': 'list',
      'aria-expanded': 'false',
      'aria-haspopup': 'true',
      'aria-owns': this.menu.getElementId(),
      'aria-labelledby': labelId
    } );
  this.$element
    .addClass( 'oo-ui-dropdownWidget' )
    .append( this.$handle );
  this.$overlay.append( this.menu.$element );
};

/* Setup */

OO.inheritClass( OO.ui.DropdownWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.DropdownWidget, OO.ui.mixin.TabIndexedElement );

/* Methods */

/**
 * Get the menu.
 *
 * @return {OO.ui.MenuSelectWidget} Menu of widget
 */
OO.ui.DropdownWidget.prototype.getMenu = function () {
  return this.menu;
};

/**
 * Handles menu select events.
 *
 * @private
 * @param {OO.ui.MenuOptionWidget} item Selected menu item
 */
OO.ui.DropdownWidget.prototype.onMenuSelect = function ( item ) {
  var selectedLabel;

  if ( !item ) {
    this.setLabel( null );
    return;
  }

  selectedLabel = item.getLabel();

  // If the label is a DOM element, clone it, because setLabel will append() it
  if ( selectedLabel instanceof $ ) {
    selectedLabel = selectedLabel.clone();
  }

  this.setLabel( selectedLabel );
};

/**
 * Handle menu toggle events.
 *
 * @private
 * @param {boolean} isVisible Open state of the menu
 */
OO.ui.DropdownWidget.prototype.onMenuToggle = function ( isVisible ) {
  this.$element.toggleClass( 'oo-ui-dropdownWidget-open', isVisible );
};

/**
 * Handle mouse click events.
 *
 * @private
 * @param {jQuery.Event} e Mouse click event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.DropdownWidget.prototype.onClick = function ( e ) {
  if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT ) {
    this.menu.toggle();
  }
  return false;
};

/**
 * Handle key down events.
 *
 * @private
 * @param {jQuery.Event} e Key down event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.DropdownWidget.prototype.onKeyDown = function ( e ) {
  if (
    !this.isDisabled() &&
    (
      e.which === OO.ui.Keys.ENTER ||
      (
        e.which === OO.ui.Keys.SPACE &&
        // Avoid conflicts with type-to-search, see SelectWidget#onKeyPress.
        // Space only closes the menu is the user is not typing to search.
        this.menu.keyPressBuffer === ''
      ) ||
      (
        !this.menu.isVisible() &&
        (
          e.which === OO.ui.Keys.UP ||
          e.which === OO.ui.Keys.DOWN
        )
      )
    )
  ) {
    this.menu.toggle();
    return false;
  }
};

/**
 * @inheritdoc
 */
OO.ui.DropdownWidget.prototype.setLabelledBy = function ( id ) {
  var labelId = this.$label.attr( 'id' );

  if ( id ) {
    this.$handle.attr( 'aria-labelledby', id + ' ' + labelId );
  } else {
    this.$handle.attr( 'aria-labelledby', labelId );
  }
};

/**
 * RadioOptionWidget is an option widget that looks like a radio button.
 * The class is used with OO.ui.RadioSelectWidget to create a selection of radio options.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Button_selects_and_option
 *
 * @class
 * @extends OO.ui.OptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.RadioOptionWidget = function OoUiRadioOptionWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Properties (must be done before parent constructor which calls #setDisabled)
  this.radio = new OO.ui.RadioInputWidget( { value: config.data, tabIndex: -1 } );

  // Parent constructor
  OO.ui.RadioOptionWidget.super.call( this, config );

  // Initialization
  // Remove implicit role, we're handling it ourselves
  this.radio.$input.attr( 'role', 'presentation' );
  this.$element
    .addClass( 'oo-ui-radioOptionWidget' )
    .attr( 'role', 'radio' )
    .attr( 'aria-checked', 'false' )
    .removeAttr( 'aria-selected' )
    .prepend( this.radio.$element );
};

/* Setup */

OO.inheritClass( OO.ui.RadioOptionWidget, OO.ui.OptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.static.highlightable = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.static.scrollIntoViewOnSelect = true;

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.static.pressable = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.static.tagName = 'label';

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.prototype.setSelected = function ( state ) {
  OO.ui.RadioOptionWidget.super.prototype.setSelected.call( this, state );

  this.radio.setSelected( state );
  this.$element
    .attr( 'aria-checked', state.toString() )
    .removeAttr( 'aria-selected' );

  return this;
};

/**
 * @inheritdoc
 */
OO.ui.RadioOptionWidget.prototype.setDisabled = function ( disabled ) {
  OO.ui.RadioOptionWidget.super.prototype.setDisabled.call( this, disabled );

  this.radio.setDisabled( this.isDisabled() );

  return this;
};

/**
 * RadioSelectWidget is a {@link OO.ui.SelectWidget select widget} that contains radio
 * options and is used together with OO.ui.RadioOptionWidget. The RadioSelectWidget provides
 * an interface for adding, removing and selecting options.
 * Please see the [OOUI documentation on MediaWiki][1] for more information.
 *
 * If you want to use this within an HTML form, such as a OO.ui.FormLayout, use
 * OO.ui.RadioSelectInputWidget instead.
 *
 *     @example
 *     // A RadioSelectWidget with RadioOptions.
 *     var option1 = new OO.ui.RadioOptionWidget( {
 *             data: 'a',
 *             label: 'Selected radio option'
 *         } ),
 *         option2 = new OO.ui.RadioOptionWidget( {
 *             data: 'b',
 *             label: 'Unselected radio option'
 *         } );
 *         radioSelect = new OO.ui.RadioSelectWidget( {
 *             items: [ option1, option2 ]
 *         } );
 *
 *     // Select 'option 1' using the RadioSelectWidget's selectItem() method.
 *     radioSelect.selectItem( option1 );
 *
 *     $( document.body ).append( radioSelect.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.RadioSelectWidget = function OoUiRadioSelectWidget( config ) {
  // Parent constructor
  OO.ui.RadioSelectWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.TabIndexedElement.call( this, config );

  // Events
  this.$element.on( {
    focus: this.bindDocumentKeyDownListener.bind( this ),
    blur: this.unbindDocumentKeyDownListener.bind( this )
  } );

  // Initialization
  this.$element
    .addClass( 'oo-ui-radioSelectWidget' )
    .attr( 'role', 'radiogroup' );
};

/* Setup */

OO.inheritClass( OO.ui.RadioSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.RadioSelectWidget, OO.ui.mixin.TabIndexedElement );

/**
 * MultioptionWidgets are special elements that can be selected and configured with data. The
 * data is often unique for each option, but it does not have to be. MultioptionWidgets are used
 * with OO.ui.SelectWidget to create a selection of mutually exclusive options. For more information
 * and examples, please see the [OOUI documentation on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.ItemWidget
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [selected=false] Whether the option is initially selected
 */
OO.ui.MultioptionWidget = function OoUiMultioptionWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.MultioptionWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.ItemWidget.call( this );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.TitledElement.call( this, config );

  // Properties
  this.selected = null;

  // Initialization
  this.$element
    .addClass( 'oo-ui-multioptionWidget' )
    .append( this.$label );
  this.setSelected( config.selected );
};

/* Setup */

OO.inheritClass( OO.ui.MultioptionWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.MultioptionWidget, OO.ui.mixin.ItemWidget );
OO.mixinClass( OO.ui.MultioptionWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.MultioptionWidget, OO.ui.mixin.TitledElement );

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the selected state of the option changes.
 *
 * @param {boolean} selected Whether the option is now selected
 */

/* Methods */

/**
 * Check if the option is selected.
 *
 * @return {boolean} Item is selected
 */
OO.ui.MultioptionWidget.prototype.isSelected = function () {
  return this.selected;
};

/**
 * Set the option’s selected state. In general, all modifications to the selection
 * should be handled by the SelectWidget’s
 * {@link OO.ui.SelectWidget#selectItem selectItem( [item] )} method instead of this method.
 *
 * @param {boolean} [state=false] Select option
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.MultioptionWidget.prototype.setSelected = function ( state ) {
  state = !!state;
  if ( this.selected !== state ) {
    this.selected = state;
    this.emit( 'change', state );
    this.$element.toggleClass( 'oo-ui-multioptionWidget-selected', state );
  }
  return this;
};

/**
 * MultiselectWidget allows selecting multiple options from a list.
 *
 * For more information about menus and options, please see the [OOUI documentation
 * on MediaWiki][1].
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Menu_selects_and_options
 *
 * @class
 * @abstract
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupWidget
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.MultioptionWidget[]} [items] An array of options to add to the multiselect.
 */
OO.ui.MultiselectWidget = function OoUiMultiselectWidget( config ) {
  // Parent constructor
  OO.ui.MultiselectWidget.super.call( this, config );

  // Configuration initialization
  config = config || {};

  // Mixin constructors
  OO.ui.mixin.GroupWidget.call( this, config );
  OO.ui.mixin.TitledElement.call( this, config );

  // Events
  this.aggregate( {
    change: 'select'
  } );
  // This is mostly for compatibility with TagMultiselectWidget... normally, 'change' is emitted
  // by GroupElement only when items are added/removed
  this.connect( this, {
    select: [ 'emit', 'change' ]
  } );

  // Initialization
  if ( config.items ) {
    this.addItems( config.items );
  }
  this.$group.addClass( 'oo-ui-multiselectWidget-group' );
  this.$element.addClass( 'oo-ui-multiselectWidget' )
    .append( this.$group );
};

/* Setup */

OO.inheritClass( OO.ui.MultiselectWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.MultiselectWidget, OO.ui.mixin.GroupWidget );
OO.mixinClass( OO.ui.MultiselectWidget, OO.ui.mixin.TitledElement );

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the set of items changes, or an item is selected or deselected.
 */

/**
 * @event select
 *
 * A select event is emitted when an item is selected or deselected.
 */

/* Methods */

/**
 * Find options that are selected.
 *
 * @return {OO.ui.MultioptionWidget[]} Selected options
 */
OO.ui.MultiselectWidget.prototype.findSelectedItems = function () {
  return this.items.filter( function ( item ) {
    return item.isSelected();
  } );
};

/**
 * Find the data of options that are selected.
 *
 * @return {Object[]|string[]} Values of selected options
 */
OO.ui.MultiselectWidget.prototype.findSelectedItemsData = function () {
  return this.findSelectedItems().map( function ( item ) {
    return item.data;
  } );
};

/**
 * Select options by reference. Options not mentioned in the `items` array will be deselected.
 *
 * @param {OO.ui.MultioptionWidget[]} items Items to select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.MultiselectWidget.prototype.selectItems = function ( items ) {
  this.items.forEach( function ( item ) {
    var selected = items.indexOf( item ) !== -1;
    item.setSelected( selected );
  } );
  return this;
};

/**
 * Select items by their data. Options not mentioned in the `datas` array will be deselected.
 *
 * @param {Object[]|string[]} datas Values of items to select
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.MultiselectWidget.prototype.selectItemsByData = function ( datas ) {
  var items,
    widget = this;
  items = datas.map( function ( data ) {
    return widget.findItemFromData( data );
  } );
  this.selectItems( items );
  return this;
};

/**
 * CheckboxMultioptionWidget is an option widget that looks like a checkbox.
 * The class is used with OO.ui.CheckboxMultiselectWidget to create a selection of checkbox options.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Button_selects_and_option
 *
 * @class
 * @extends OO.ui.MultioptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.CheckboxMultioptionWidget = function OoUiCheckboxMultioptionWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Properties (must be done before parent constructor which calls #setDisabled)
  this.checkbox = new OO.ui.CheckboxInputWidget();

  // Parent constructor
  OO.ui.CheckboxMultioptionWidget.super.call( this, config );

  // Events
  this.checkbox.on( 'change', this.onCheckboxChange.bind( this ) );
  this.$element.on( 'keydown', this.onKeyDown.bind( this ) );

  // Initialization
  this.$element
    .addClass( 'oo-ui-checkboxMultioptionWidget' )
    .prepend( this.checkbox.$element );
};

/* Setup */

OO.inheritClass( OO.ui.CheckboxMultioptionWidget, OO.ui.MultioptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.CheckboxMultioptionWidget.static.tagName = 'label';

/* Methods */

/**
 * Handle checkbox selected state change.
 *
 * @private
 */
OO.ui.CheckboxMultioptionWidget.prototype.onCheckboxChange = function () {
  this.setSelected( this.checkbox.isSelected() );
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultioptionWidget.prototype.setSelected = function ( state ) {
  OO.ui.CheckboxMultioptionWidget.super.prototype.setSelected.call( this, state );
  this.checkbox.setSelected( state );
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultioptionWidget.prototype.setDisabled = function ( disabled ) {
  OO.ui.CheckboxMultioptionWidget.super.prototype.setDisabled.call( this, disabled );
  this.checkbox.setDisabled( this.isDisabled() );
  return this;
};

/**
 * Focus the widget.
 */
OO.ui.CheckboxMultioptionWidget.prototype.focus = function () {
  this.checkbox.focus();
};

/**
 * Handle key down events.
 *
 * @protected
 * @param {jQuery.Event} e
 */
OO.ui.CheckboxMultioptionWidget.prototype.onKeyDown = function ( e ) {
  var
    element = this.getElementGroup(),
    nextItem;

  if ( e.keyCode === OO.ui.Keys.LEFT || e.keyCode === OO.ui.Keys.UP ) {
    nextItem = element.getRelativeFocusableItem( this, -1 );
  } else if ( e.keyCode === OO.ui.Keys.RIGHT || e.keyCode === OO.ui.Keys.DOWN ) {
    nextItem = element.getRelativeFocusableItem( this, 1 );
  }

  if ( nextItem ) {
    e.preventDefault();
    nextItem.focus();
  }
};

/**
 * CheckboxMultiselectWidget is a {@link OO.ui.MultiselectWidget multiselect widget} that contains
 * checkboxes and is used together with OO.ui.CheckboxMultioptionWidget. The
 * CheckboxMultiselectWidget provides an interface for adding, removing and selecting options.
 * Please see the [OOUI documentation on MediaWiki][1] for more information.
 *
 * If you want to use this within an HTML form, such as a OO.ui.FormLayout, use
 * OO.ui.CheckboxMultiselectInputWidget instead.
 *
 *     @example
 *     // A CheckboxMultiselectWidget with CheckboxMultioptions.
 *     var option1 = new OO.ui.CheckboxMultioptionWidget( {
 *             data: 'a',
 *             selected: true,
 *             label: 'Selected checkbox'
 *         } ),
 *         option2 = new OO.ui.CheckboxMultioptionWidget( {
 *             data: 'b',
 *             label: 'Unselected checkbox'
 *         } ),
 *         multiselect = new OO.ui.CheckboxMultiselectWidget( {
 *             items: [ option1, option2 ]
 *         } );
 *     $( document.body ).append( multiselect.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.MultiselectWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.CheckboxMultiselectWidget = function OoUiCheckboxMultiselectWidget( config ) {
  // Parent constructor
  OO.ui.CheckboxMultiselectWidget.super.call( this, config );

  // Properties
  this.$lastClicked = null;

  // Events
  this.$group.on( 'click', this.onClick.bind( this ) );

  // Initialization
  this.$element.addClass( 'oo-ui-checkboxMultiselectWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.CheckboxMultiselectWidget, OO.ui.MultiselectWidget );

/* Methods */

/**
 * Get an option by its position relative to the specified item (or to the start of the
 * option array, if item is `null`). The direction in which to search through the option array
 * is specified with a number: -1 for reverse (the default) or 1 for forward. The method will
 * return an option, or `null` if there are no options in the array.
 *
 * @param {OO.ui.CheckboxMultioptionWidget|null} item Item to describe the start position, or
 *  `null` to start at the beginning of the array.
 * @param {number} direction Direction to move in: -1 to move backward, 1 to move forward
 * @return {OO.ui.CheckboxMultioptionWidget|null} Item at position, `null` if there are no items
 *  in the select.
 */
OO.ui.CheckboxMultiselectWidget.prototype.getRelativeFocusableItem = function ( item, direction ) {
  var currentIndex, nextIndex, i,
    increase = direction > 0 ? 1 : -1,
    len = this.items.length;

  if ( item ) {
    currentIndex = this.items.indexOf( item );
    nextIndex = ( currentIndex + increase + len ) % len;
  } else {
    // If no item is selected and moving forward, start at the beginning.
    // If moving backward, start at the end.
    nextIndex = direction > 0 ? 0 : len - 1;
  }

  for ( i = 0; i < len; i++ ) {
    item = this.items[ nextIndex ];
    if ( item && !item.isDisabled() ) {
      return item;
    }
    nextIndex = ( nextIndex + increase + len ) % len;
  }
  return null;
};

/**
 * Handle click events on checkboxes.
 *
 * @param {jQuery.Event} e
 */
OO.ui.CheckboxMultiselectWidget.prototype.onClick = function ( e ) {
  var $options, lastClickedIndex, nowClickedIndex, i, direction, wasSelected, items,
    $lastClicked = this.$lastClicked,
    $nowClicked = $( e.target ).closest( '.oo-ui-checkboxMultioptionWidget' )
      .not( '.oo-ui-widget-disabled' );

  // Allow selecting multiple options at once by Shift-clicking them
  if ( $lastClicked && $nowClicked.length && e.shiftKey ) {
    $options = this.$group.find( '.oo-ui-checkboxMultioptionWidget' );
    lastClickedIndex = $options.index( $lastClicked );
    nowClickedIndex = $options.index( $nowClicked );
    // If it's the same item, either the user is being silly, or it's a fake event generated
    // by the browser. In either case we don't need custom handling.
    if ( nowClickedIndex !== lastClickedIndex ) {
      items = this.items;
      wasSelected = items[ nowClickedIndex ].isSelected();
      direction = nowClickedIndex > lastClickedIndex ? 1 : -1;

      // This depends on the DOM order of the items and the order of the .items array being
      // the same.
      for ( i = lastClickedIndex; i !== nowClickedIndex; i += direction ) {
        if ( !items[ i ].isDisabled() ) {
          items[ i ].setSelected( !wasSelected );
        }
      }
      // For the now-clicked element, use immediate timeout to allow the browser to do its own
      // handling first, then set our value. The order in which events happen is different for
      // clicks on the <input> and on the <label> and there are additional fake clicks fired
      // for non-click actions that change the checkboxes.
      e.preventDefault();
      setTimeout( function () {
        if ( !items[ nowClickedIndex ].isDisabled() ) {
          items[ nowClickedIndex ].setSelected( !wasSelected );
        }
      } );
    }
  }

  if ( $nowClicked.length ) {
    this.$lastClicked = $nowClicked;
  }
};

/**
 * Focus the widget
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.CheckboxMultiselectWidget.prototype.focus = function () {
  var item;
  if ( !this.isDisabled() ) {
    item = this.getRelativeFocusableItem( null, 1 );
    if ( item ) {
      item.focus();
    }
  }
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectWidget.prototype.simulateLabelClick = function () {
  this.focus();
};

/**
 * Progress bars visually display the status of an operation, such as a download,
 * and can be either determinate or indeterminate:
 *
 * - **determinate** process bars show the percent of an operation that is complete.
 *
 * - **indeterminate** process bars use a visual display of motion to indicate that an operation
 *   is taking place. Because the extent of an indeterminate operation is unknown, the bar does
 *   not use percentages.
 *
 * The value of the `progress` configuration determines whether the bar is determinate
 * or indeterminate.
 *
 *     @example
 *     // Examples of determinate and indeterminate progress bars.
 *     var progressBar1 = new OO.ui.ProgressBarWidget( {
 *         progress: 33
 *     } );
 *     var progressBar2 = new OO.ui.ProgressBarWidget();
 *
 *     // Create a FieldsetLayout to layout progress bars.
 *     var fieldset = new OO.ui.FieldsetLayout;
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( progressBar1, {
 *             label: 'Determinate',
 *             align: 'top'
 *         } ),
 *         new OO.ui.FieldLayout( progressBar2, {
 *             label: 'Indeterminate',
 *             align: 'top'
 *         } )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * @class
 * @extends OO.ui.Widget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {number|boolean} [progress=false] The type of progress bar (determinate or indeterminate).
 *  To create a determinate progress bar, specify a number that reflects the initial
 *  percent complete.
 *  By default, the progress bar is indeterminate.
 */
OO.ui.ProgressBarWidget = function OoUiProgressBarWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.ProgressBarWidget.super.call( this, config );

  // Properties
  this.$bar = $( '<div>' );
  this.progress = null;

  // Initialization
  this.setProgress( config.progress !== undefined ? config.progress : false );
  this.$bar.addClass( 'oo-ui-progressBarWidget-bar' );
  this.$element
    .attr( {
      role: 'progressbar',
      'aria-valuemin': 0,
      'aria-valuemax': 100
    } )
    .addClass( 'oo-ui-progressBarWidget' )
    .append( this.$bar );
};

/* Setup */

OO.inheritClass( OO.ui.ProgressBarWidget, OO.ui.Widget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ProgressBarWidget.static.tagName = 'div';

/* Methods */

/**
 * Get the percent of the progress that has been completed. Indeterminate progresses will
 * return `false`.
 *
 * @return {number|boolean} Progress percent
 */
OO.ui.ProgressBarWidget.prototype.getProgress = function () {
  return this.progress;
};

/**
 * Set the percent of the process completed or `false` for an indeterminate process.
 *
 * @param {number|boolean} progress Progress percent or `false` for indeterminate
 */
OO.ui.ProgressBarWidget.prototype.setProgress = function ( progress ) {
  this.progress = progress;

  if ( progress !== false ) {
    this.$bar.css( 'width', this.progress + '%' );
    this.$element.attr( 'aria-valuenow', this.progress );
  } else {
    this.$bar.css( 'width', '' );
    this.$element.removeAttr( 'aria-valuenow' );
  }
  this.$element.toggleClass( 'oo-ui-progressBarWidget-indeterminate', progress === false );
};

/**
 * InputWidget is the base class for all input widgets, which
 * include {@link OO.ui.TextInputWidget text inputs}, {@link OO.ui.CheckboxInputWidget checkbox
 * inputs}, {@link OO.ui.RadioInputWidget radio inputs}, and
 * {@link OO.ui.ButtonInputWidget button inputs}.
 * See the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @abstract
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.TabIndexedElement
 * @mixins OO.ui.mixin.TitledElement
 * @mixins OO.ui.mixin.AccessKeyedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [name=''] The value of the input’s HTML `name` attribute.
 * @cfg {string} [value=''] The value of the input.
 * @cfg {string} [dir] The directionality of the input (ltr/rtl).
 * @cfg {string} [inputId] The value of the input’s HTML `id` attribute.
 * @cfg {Function} [inputFilter] The name of an input filter function. Input filters modify the
 *  value of an input before it is accepted.
 */
OO.ui.InputWidget = function OoUiInputWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.InputWidget.super.call( this, config );

  // Properties
  // See #reusePreInfuseDOM about config.$input
  this.$input = config.$input || this.getInputElement( config );
  this.value = '';
  this.inputFilter = config.inputFilter;

  // Mixin constructors
  OO.ui.mixin.TabIndexedElement.call( this, $.extend( {
    $tabIndexed: this.$input
  }, config ) );
  OO.ui.mixin.TitledElement.call( this, $.extend( {
    $titled: this.$input
  }, config ) );
  OO.ui.mixin.AccessKeyedElement.call( this, $.extend( {
    $accessKeyed: this.$input
  }, config ) );

  // Events
  this.$input.on( 'keydown mouseup cut paste change input select', this.onEdit.bind( this ) );

  // Initialization
  this.$input
    .addClass( 'oo-ui-inputWidget-input' )
    .attr( 'name', config.name )
    .prop( 'disabled', this.isDisabled() );
  this.$element
    .addClass( 'oo-ui-inputWidget' )
    .append( this.$input );
  this.setValue( config.value );
  if ( config.dir ) {
    this.setDir( config.dir );
  }
  if ( config.inputId !== undefined ) {
    this.setInputId( config.inputId );
  }
};

/* Setup */

OO.inheritClass( OO.ui.InputWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.InputWidget, OO.ui.mixin.TabIndexedElement );
OO.mixinClass( OO.ui.InputWidget, OO.ui.mixin.TitledElement );
OO.mixinClass( OO.ui.InputWidget, OO.ui.mixin.AccessKeyedElement );

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.InputWidget.static.reusePreInfuseDOM = function ( node, config ) {
  config = OO.ui.InputWidget.super.static.reusePreInfuseDOM( node, config );
  // Reusing `$input` lets browsers preserve inputted values across page reloads, see T114134.
  config.$input = $( node ).find( '.oo-ui-inputWidget-input' );
  return config;
};

/**
 * @inheritdoc
 */
OO.ui.InputWidget.static.gatherPreInfuseState = function ( node, config ) {
  var state = OO.ui.InputWidget.super.static.gatherPreInfuseState( node, config );
  if ( config.$input && config.$input.length ) {
    state.value = config.$input.val();
    // Might be better in TabIndexedElement, but it's awkward to do there because
    // mixins are awkward
    state.focus = config.$input.is( ':focus' );
  }
  return state;
};

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the value of the input changes.
 *
 * @param {string} value
 */

/* Methods */

/**
 * Get input element.
 *
 * Subclasses of OO.ui.InputWidget use the `config` parameter to produce different elements in
 * different circumstances. The element must have a `value` property (like form elements).
 *
 * @protected
 * @param {Object} config Configuration options
 * @return {jQuery} Input element
 */
OO.ui.InputWidget.prototype.getInputElement = function () {
  return $( '<input>' );
};

/**
 * Handle potentially value-changing events.
 *
 * @private
 * @param {jQuery.Event} e Key down, mouse up, cut, paste, change, input, or select event
 */
OO.ui.InputWidget.prototype.onEdit = function () {
  var widget = this;
  if ( !this.isDisabled() ) {
    // Allow the stack to clear so the value will be updated
    setTimeout( function () {
      widget.setValue( widget.$input.val() );
    } );
  }
};

/**
 * Get the value of the input.
 *
 * @return {string} Input value
 */
OO.ui.InputWidget.prototype.getValue = function () {
  // Resynchronize our internal data with DOM data. Other scripts executing on the page can modify
  // it, and we won't know unless they're kind enough to trigger a 'change' event.
  var value = this.$input.val();
  if ( this.value !== value ) {
    this.setValue( value );
  }
  return this.value;
};

/**
 * Set the directionality of the input.
 *
 * @param {string} dir Text directionality: 'ltr', 'rtl' or 'auto'
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.InputWidget.prototype.setDir = function ( dir ) {
  this.$input.prop( 'dir', dir );
  return this;
};

/**
 * Set the value of the input.
 *
 * @param {string} value New value
 * @fires change
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.InputWidget.prototype.setValue = function ( value ) {
  value = this.cleanUpValue( value );
  // Update the DOM if it has changed. Note that with cleanUpValue, it
  // is possible for the DOM value to change without this.value changing.
  if ( this.$input.val() !== value ) {
    this.$input.val( value );
  }
  if ( this.value !== value ) {
    this.value = value;
    this.emit( 'change', this.value );
  }
  // The first time that the value is set (probably while constructing the widget),
  // remember it in defaultValue. This property can be later used to check whether
  // the value of the input has been changed since it was created.
  if ( this.defaultValue === undefined ) {
    this.defaultValue = this.value;
    this.$input[ 0 ].defaultValue = this.defaultValue;
  }
  return this;
};

/**
 * Clean up incoming value.
 *
 * Ensures value is a string, and converts undefined and null to empty string.
 *
 * @private
 * @param {string} value Original value
 * @return {string} Cleaned up value
 */
OO.ui.InputWidget.prototype.cleanUpValue = function ( value ) {
  if ( value === undefined || value === null ) {
    return '';
  } else if ( this.inputFilter ) {
    return this.inputFilter( String( value ) );
  } else {
    return String( value );
  }
};

/**
 * @inheritdoc
 */
OO.ui.InputWidget.prototype.setDisabled = function ( state ) {
  OO.ui.InputWidget.super.prototype.setDisabled.call( this, state );
  if ( this.$input ) {
    this.$input.prop( 'disabled', this.isDisabled() );
  }
  return this;
};

/**
 * Set the 'id' attribute of the `<input>` element.
 *
 * @param {string} id
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.InputWidget.prototype.setInputId = function ( id ) {
  this.$input.attr( 'id', id );
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.InputWidget.prototype.restorePreInfuseState = function ( state ) {
  OO.ui.InputWidget.super.prototype.restorePreInfuseState.call( this, state );
  if ( state.value !== undefined && state.value !== this.getValue() ) {
    this.setValue( state.value );
  }
  if ( state.focus ) {
    this.focus();
  }
};

/**
 * Data widget intended for creating `<input type="hidden">` inputs.
 *
 * @class
 * @extends OO.ui.Widget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [value=''] The value of the input.
 * @cfg {string} [name=''] The value of the input’s HTML `name` attribute.
 */
OO.ui.HiddenInputWidget = function OoUiHiddenInputWidget( config ) {
  // Configuration initialization
  config = $.extend( { value: '', name: '' }, config );

  // Parent constructor
  OO.ui.HiddenInputWidget.super.call( this, config );

  // Initialization
  this.$element.attr( {
    type: 'hidden',
    value: config.value,
    name: config.name
  } );
  this.$element.removeAttr( 'aria-disabled' );
};

/* Setup */

OO.inheritClass( OO.ui.HiddenInputWidget, OO.ui.Widget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.HiddenInputWidget.static.tagName = 'input';

/**
 * ButtonInputWidget is used to submit HTML forms and is intended to be used within
 * a OO.ui.FormLayout. If you do not need the button to work with HTML forms, you probably
 * want to use OO.ui.ButtonWidget instead. Button input widgets can be rendered as either an
 * HTML `<button>` (the default) or an HTML `<input>` tags. See the
 * [OOUI documentation on MediaWiki] [1] for more information.
 *
 *     @example
 *     // A ButtonInputWidget rendered as an HTML button, the default.
 *     var button = new OO.ui.ButtonInputWidget( {
 *         label: 'Input button',
 *         icon: 'check',
 *         value: 'check'
 *     } );
 *     $( document.body ).append( button.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs#Button_inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 * @mixins OO.ui.mixin.ButtonElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [type='button'] The value of the HTML `'type'` attribute:
 *  'button', 'submit' or 'reset'.
 * @cfg {boolean} [useInputTag=false] Use an `<input>` tag instead of a `<button>` tag, the default.
 *  Widgets configured to be an `<input>` do not support {@link #icon icons} and
 *  {@link #indicator indicators},
 *  non-plaintext {@link #label labels}, or {@link #value values}. In general, useInputTag should
 *  only be set to `true` when there’s need to support IE 6 in a form with multiple buttons.
 */
OO.ui.ButtonInputWidget = function OoUiButtonInputWidget( config ) {
  // Configuration initialization
  config = $.extend( { type: 'button', useInputTag: false }, config );

  // See InputWidget#reusePreInfuseDOM about config.$input
  if ( config.$input ) {
    config.$input.empty();
  }

  // Properties (must be set before parent constructor, which calls #setValue)
  this.useInputTag = config.useInputTag;

  // Parent constructor
  OO.ui.ButtonInputWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.ButtonElement.call( this, $.extend( {
    $button: this.$input
  }, config ) );
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.IndicatorElement.call( this, config );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.FlaggedElement.call( this, config );

  // Initialization
  if ( !config.useInputTag ) {
    this.$input.append( this.$icon, this.$label, this.$indicator );
  }
  this.$element.addClass( 'oo-ui-buttonInputWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.ButtonInputWidget, OO.ui.InputWidget );
OO.mixinClass( OO.ui.ButtonInputWidget, OO.ui.mixin.ButtonElement );
OO.mixinClass( OO.ui.ButtonInputWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.ButtonInputWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.ButtonInputWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.ButtonInputWidget, OO.ui.mixin.FlaggedElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonInputWidget.static.tagName = 'span';

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.ButtonInputWidget.prototype.getInputElement = function ( config ) {
  var type;
  type = [ 'button', 'submit', 'reset' ].indexOf( config.type ) !== -1 ? config.type : 'button';
  return $( '<' + ( config.useInputTag ? 'input' : 'button' ) + ' type="' + type + '">' );
};

/**
 * Set label value.
 *
 * If #useInputTag is `true`, the label is set as the `value` of the `<input>` tag.
 *
 * @param {jQuery|string|Function|null} label Label nodes, text, a function that returns nodes or
 *  text, or `null` for no label
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonInputWidget.prototype.setLabel = function ( label ) {
  if ( typeof label === 'function' ) {
    label = OO.ui.resolveMsg( label );
  }

  if ( this.useInputTag ) {
    // Discard non-plaintext labels
    if ( typeof label !== 'string' ) {
      label = '';
    }

    this.$input.val( label );
  }

  return OO.ui.mixin.LabelElement.prototype.setLabel.call( this, label );
};

/**
 * Set the value of the input.
 *
 * This method is disabled for button inputs configured as {@link #useInputTag <input> tags}, as
 * they do not support {@link #value values}.
 *
 * @param {string} value New value
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ButtonInputWidget.prototype.setValue = function ( value ) {
  if ( !this.useInputTag ) {
    OO.ui.ButtonInputWidget.super.prototype.setValue.call( this, value );
  }
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.ButtonInputWidget.prototype.getInputId = function () {
  // Disable generating `<label>` elements for buttons. One would very rarely need additional
  // label for a button, and it's already a big clickable target, and it causes
  // unexpected rendering.
  return null;
};

/**
 * CheckboxInputWidgets, like HTML checkboxes, can be selected and/or configured with a value.
 * Note that these {@link OO.ui.InputWidget input widgets} are best laid out
 * in {@link OO.ui.FieldLayout field layouts} that use the {@link OO.ui.FieldLayout#align inline}
 * alignment. For more information, please see the [OOUI documentation on MediaWiki][1].
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 *     @example
 *     // An example of selected, unselected, and disabled checkbox inputs.
 *     var checkbox1 = new OO.ui.CheckboxInputWidget( {
 *             value: 'a',
 *              selected: true
 *         } ),
 *         checkbox2 = new OO.ui.CheckboxInputWidget( {
 *             value: 'b'
 *         } ),
 *         checkbox3 = new OO.ui.CheckboxInputWidget( {
 *             value:'c',
 *             disabled: true
 *         } ),
 *         // Create a fieldset layout with fields for each checkbox.
 *         fieldset = new OO.ui.FieldsetLayout( {
 *             label: 'Checkboxes'
 *         } );
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( checkbox1, { label: 'Selected checkbox', align: 'inline' } ),
 *         new OO.ui.FieldLayout( checkbox2, { label: 'Unselected checkbox', align: 'inline' } ),
 *         new OO.ui.FieldLayout( checkbox3, { label: 'Disabled checkbox', align: 'inline' } ),
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [selected=false] Select the checkbox initially. By default, the checkbox is
 *  not selected.
 * @cfg {boolean} [indeterminate=false] Whether the checkbox is in the indeterminate state.
 */
OO.ui.CheckboxInputWidget = function OoUiCheckboxInputWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.CheckboxInputWidget.super.call( this, config );

  // Properties
  this.checkIcon = new OO.ui.IconWidget( {
    icon: 'check',
    classes: [ 'oo-ui-checkboxInputWidget-checkIcon' ]
  } );

  // Initialization
  this.$element
    .addClass( 'oo-ui-checkboxInputWidget' )
    // Required for pretty styling in WikimediaUI theme
    .append( this.checkIcon.$element );
  this.setSelected( config.selected !== undefined ? config.selected : false );
  this.setIndeterminate( config.indeterminate !== undefined ? config.indeterminate : false );
};

/* Setup */

OO.inheritClass( OO.ui.CheckboxInputWidget, OO.ui.InputWidget );

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the state of the input changes.
 *
 * @param {boolean} selected
 * @param {boolean} indeterminate
 */

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.static.tagName = 'span';

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.static.gatherPreInfuseState = function ( node, config ) {
  var state = OO.ui.CheckboxInputWidget.super.static.gatherPreInfuseState( node, config );
  state.checked = config.$input.prop( 'checked' );
  return state;
};

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.CheckboxInputWidget.prototype.getInputElement = function () {
  return $( '<input>' ).attr( 'type', 'checkbox' );
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.prototype.onEdit = function () {
  var widget = this;
  if ( !this.isDisabled() ) {
    // Allow the stack to clear so the value will be updated
    setTimeout( function () {
      widget.setSelected( widget.$input.prop( 'checked' ) );
      widget.setIndeterminate( widget.$input.prop( 'indeterminate' ) );
    } );
  }
};

/**
 * Set selection state of this checkbox.
 *
 * @param {boolean} state Selected state
 * @param {boolean} internal Used for internal calls to suppress events
 * @chainable
 * @return {OO.ui.CheckboxInputWidget} The widget, for chaining
 */
OO.ui.CheckboxInputWidget.prototype.setSelected = function ( state, internal ) {
  state = !!state;
  if ( this.selected !== state ) {
    this.selected = state;
    this.$input.prop( 'checked', this.selected );
    if ( !internal ) {
      this.setIndeterminate( false, true );
      this.emit( 'change', this.selected, this.indeterminate );
    }
  }
  // The first time that the selection state is set (probably while constructing the widget),
  // remember it in defaultSelected. This property can be later used to check whether
  // the selection state of the input has been changed since it was created.
  if ( this.defaultSelected === undefined ) {
    this.defaultSelected = this.selected;
    this.$input[ 0 ].defaultChecked = this.defaultSelected;
  }
  return this;
};

/**
 * Check if this checkbox is selected.
 *
 * @return {boolean} Checkbox is selected
 */
OO.ui.CheckboxInputWidget.prototype.isSelected = function () {
  // Resynchronize our internal data with DOM data. Other scripts executing on the page can modify
  // it, and we won't know unless they're kind enough to trigger a 'change' event.
  var selected = this.$input.prop( 'checked' );
  if ( this.selected !== selected ) {
    this.setSelected( selected );
  }
  return this.selected;
};

/**
 * Set indeterminate state of this checkbox.
 *
 * @param {boolean} state Indeterminate state
 * @param {boolean} internal Used for internal calls to suppress events
 * @chainable
 * @return {OO.ui.CheckboxInputWidget} The widget, for chaining
 */
OO.ui.CheckboxInputWidget.prototype.setIndeterminate = function ( state, internal ) {
  state = !!state;
  if ( this.indeterminate !== state ) {
    this.indeterminate = state;
    this.$input.prop( 'indeterminate', this.indeterminate );
    if ( !internal ) {
      this.setSelected( false, true );
      this.emit( 'change', this.selected, this.indeterminate );
    }
  }
  return this;
};

/**
 * Check if this checkbox is selected.
 *
 * @return {boolean} Checkbox is selected
 */
OO.ui.CheckboxInputWidget.prototype.isIndeterminate = function () {
  // Resynchronize our internal data with DOM data. Other scripts executing on the page can modify
  // it, and we won't know unless they're kind enough to trigger a 'change' event.
  var indeterminate = this.$input.prop( 'indeterminate' );
  if ( this.indeterminate !== indeterminate ) {
    this.setIndeterminate( indeterminate );
  }
  return this.indeterminate;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.prototype.simulateLabelClick = function () {
  if ( !this.isDisabled() ) {
    this.$handle.trigger( 'click' );
  }
  this.focus();
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxInputWidget.prototype.restorePreInfuseState = function ( state ) {
  OO.ui.CheckboxInputWidget.super.prototype.restorePreInfuseState.call( this, state );
  if ( state.checked !== undefined && state.checked !== this.isSelected() ) {
    this.setSelected( state.checked );
  }
};

/**
 * DropdownInputWidget is a {@link OO.ui.DropdownWidget DropdownWidget} intended to be used
 * within an HTML form, such as a OO.ui.FormLayout. The selected value is synchronized with the
 * value of a hidden HTML `input` tag. Please see the [OOUI documentation on MediaWiki][1] for
 * more information about input widgets.
 *
 * A DropdownInputWidget always has a value (one of the options is always selected), unless there
 * are no options. If no `value` configuration option is provided, the first option is selected.
 * If you need a state representing no value (no option being selected), use a DropdownWidget.
 *
 * This and OO.ui.RadioSelectInputWidget support similar configuration options.
 *
 *     @example
 *     // A DropdownInputWidget with three options.
 *     var dropdownInput = new OO.ui.DropdownInputWidget( {
 *         options: [
 *             { data: 'a', label: 'First' },
 *             { data: 'b', label: 'Second', disabled: true },
 *             { optgroup: 'Group label' },
 *             { data: 'c', label: 'First sub-item)' }
 *         ]
 *     } );
 *     $( document.body ).append( dropdownInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object[]} [options=[]] Array of menu options in the format described above.
 * @cfg {Object} [dropdown] Configuration options for {@link OO.ui.DropdownWidget DropdownWidget}
 * @cfg {jQuery|boolean} [$overlay] Render the menu into a separate layer. This configuration is
 *  useful in cases where the expanded menu is larger than its containing `<div>`. The specified
 *  overlay layer is usually on top of the containing `<div>` and has a larger area. By default,
 *  the menu uses relative positioning. Pass 'true' to use the default overlay.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.DropdownInputWidget = function OoUiDropdownInputWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Properties (must be done before parent constructor which calls #setDisabled)
  this.dropdownWidget = new OO.ui.DropdownWidget( $.extend(
    {
      $overlay: config.$overlay
    },
    config.dropdown
  ) );
  // Set up the options before parent constructor, which uses them to validate config.value.
  // Use this instead of setOptions() because this.$input is not set up yet.
  this.setOptionsData( config.options || [] );

  // Parent constructor
  OO.ui.DropdownInputWidget.super.call( this, config );

  // Events
  this.dropdownWidget.getMenu().connect( this, {
    select: 'onMenuSelect'
  } );

  // Initialization
  this.$element
    .addClass( 'oo-ui-dropdownInputWidget' )
    .append( this.dropdownWidget.$element );
  if ( OO.ui.isMobile() ) {
    this.$element.addClass( 'oo-ui-isMobile' );
  }
  this.setTabIndexedElement( this.dropdownWidget.$tabIndexed );
  this.setTitledElement( this.dropdownWidget.$handle );
};

/* Setup */

OO.inheritClass( OO.ui.DropdownInputWidget, OO.ui.InputWidget );

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.DropdownInputWidget.prototype.getInputElement = function () {
  return $( '<select>' ).addClass( 'oo-ui-indicator-down' );
};

/**
 * Handles menu select events.
 *
 * @private
 * @param {OO.ui.MenuOptionWidget|null} item Selected menu item
 */
OO.ui.DropdownInputWidget.prototype.onMenuSelect = function ( item ) {
  this.setValue( item ? item.getData() : '' );
};

/**
 * @inheritdoc
 */
OO.ui.DropdownInputWidget.prototype.setValue = function ( value ) {
  var selected;
  value = this.cleanUpValue( value );
  // Only allow setting values that are actually present in the dropdown
  selected = this.dropdownWidget.getMenu().findItemFromData( value ) ||
    this.dropdownWidget.getMenu().findFirstSelectableItem();
  this.dropdownWidget.getMenu().selectItem( selected );
  value = selected ? selected.getData() : '';
  OO.ui.DropdownInputWidget.super.prototype.setValue.call( this, value );
  if ( this.optionsDirty ) {
    // We reached this from the constructor or from #setOptions.
    // We have to update the <select> element.
    this.updateOptionsInterface();
  }
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.DropdownInputWidget.prototype.setDisabled = function ( state ) {
  this.dropdownWidget.setDisabled( state );
  OO.ui.DropdownInputWidget.super.prototype.setDisabled.call( this, state );
  return this;
};

/**
 * Set the options available for this input.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: … }`
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.DropdownInputWidget.prototype.setOptions = function ( options ) {
  var value = this.getValue();

  this.setOptionsData( options );

  // Re-set the value to update the visible interface (DropdownWidget and <select>).
  // In case the previous value is no longer an available option, select the first valid one.
  this.setValue( value );

  return this;
};

/**
 * Set the internal list of options, used e.g. by setValue() to see which options are allowed.
 *
 * This method may be called before the parent constructor, so various properties may not be
 * initialized yet.
 *
 * @param {Object[]} options Array of menu options (see #constructor for details).
 * @private
 */
OO.ui.DropdownInputWidget.prototype.setOptionsData = function ( options ) {
  var optionWidgets, optIndex, opt, previousOptgroup, optionWidget, optValue,
    widget = this;

  this.optionsDirty = true;

  // Go through all the supplied option configs and create either
  // MenuSectionOption or MenuOption widgets from each.
  optionWidgets = [];
  for ( optIndex = 0; optIndex < options.length; optIndex++ ) {
    opt = options[ optIndex ];

    if ( opt.optgroup !== undefined ) {
      // Create a <optgroup> menu item.
      optionWidget = widget.createMenuSectionOptionWidget( opt.optgroup );
      previousOptgroup = optionWidget;

    } else {
      // Create a normal <option> menu item.
      optValue = widget.cleanUpValue( opt.data );
      optionWidget = widget.createMenuOptionWidget(
        optValue,
        opt.label !== undefined ? opt.label : optValue
      );
    }

    // Disable the menu option if it is itself disabled or if its parent optgroup is disabled.
    if (
      opt.disabled !== undefined ||
      previousOptgroup instanceof OO.ui.MenuSectionOptionWidget &&
      previousOptgroup.isDisabled()
    ) {
      optionWidget.setDisabled( true );
    }

    optionWidgets.push( optionWidget );
  }

  this.dropdownWidget.getMenu().clearItems().addItems( optionWidgets );
};

/**
 * Create a menu option widget.
 *
 * @protected
 * @param {string} data Item data
 * @param {string} label Item label
 * @return {OO.ui.MenuOptionWidget} Option widget
 */
OO.ui.DropdownInputWidget.prototype.createMenuOptionWidget = function ( data, label ) {
  return new OO.ui.MenuOptionWidget( {
    data: data,
    label: label
  } );
};

/**
 * Create a menu section option widget.
 *
 * @protected
 * @param {string} label Section item label
 * @return {OO.ui.MenuSectionOptionWidget} Menu section option widget
 */
OO.ui.DropdownInputWidget.prototype.createMenuSectionOptionWidget = function ( label ) {
  return new OO.ui.MenuSectionOptionWidget( {
    label: label
  } );
};

/**
 * Update the user-visible interface to match the internal list of options and value.
 *
 * This method must only be called after the parent constructor.
 *
 * @private
 */
OO.ui.DropdownInputWidget.prototype.updateOptionsInterface = function () {
  var
    $optionsContainer = this.$input,
    defaultValue = this.defaultValue,
    widget = this;

  this.$input.empty();

  this.dropdownWidget.getMenu().getItems().forEach( function ( optionWidget ) {
    var $optionNode;

    if ( !( optionWidget instanceof OO.ui.MenuSectionOptionWidget ) ) {
      $optionNode = $( '<option>' )
        .attr( 'value', optionWidget.getData() )
        .text( optionWidget.getLabel() );

      // Remember original selection state. This property can be later used to check whether
      // the selection state of the input has been changed since it was created.
      $optionNode[ 0 ].defaultSelected = ( optionWidget.getData() === defaultValue );

      $optionsContainer.append( $optionNode );
    } else {
      $optionNode = $( '<optgroup>' )
        .attr( 'label', optionWidget.getLabel() );
      widget.$input.append( $optionNode );
      $optionsContainer = $optionNode;
    }

    // Disable the option or optgroup if required.
    if ( optionWidget.isDisabled() ) {
      $optionNode.prop( 'disabled', true );
    }
  } );

  this.optionsDirty = false;
};

/**
 * @inheritdoc
 */
OO.ui.DropdownInputWidget.prototype.focus = function () {
  this.dropdownWidget.focus();
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.DropdownInputWidget.prototype.blur = function () {
  this.dropdownWidget.blur();
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.DropdownInputWidget.prototype.setLabelledBy = function ( id ) {
  this.dropdownWidget.setLabelledBy( id );
};

/**
 * RadioInputWidget creates a single radio button. Because radio buttons are usually used as a set,
 * in most cases you will want to use a {@link OO.ui.RadioSelectWidget radio select}
 * with {@link OO.ui.RadioOptionWidget radio options} instead of this class. For more information,
 * please see the [OOUI documentation on MediaWiki][1].
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 *     @example
 *     // An example of selected, unselected, and disabled radio inputs
 *     var radio1 = new OO.ui.RadioInputWidget( {
 *         value: 'a',
 *         selected: true
 *     } );
 *     var radio2 = new OO.ui.RadioInputWidget( {
 *         value: 'b'
 *     } );
 *     var radio3 = new OO.ui.RadioInputWidget( {
 *         value: 'c',
 *         disabled: true
 *     } );
 *     // Create a fieldset layout with fields for each radio button.
 *     var fieldset = new OO.ui.FieldsetLayout( {
 *         label: 'Radio inputs'
 *     } );
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( radio1, { label: 'Selected', align: 'inline' } ),
 *         new OO.ui.FieldLayout( radio2, { label: 'Unselected', align: 'inline' } ),
 *         new OO.ui.FieldLayout( radio3, { label: 'Disabled', align: 'inline' } ),
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [selected=false] Select the radio button initially. By default, the radio button
 *  is not selected.
 */
OO.ui.RadioInputWidget = function OoUiRadioInputWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.RadioInputWidget.super.call( this, config );

  // Initialization
  this.$element
    .addClass( 'oo-ui-radioInputWidget' )
    // Required for pretty styling in WikimediaUI theme
    .append( $( '<span>' ) );
  this.setSelected( config.selected !== undefined ? config.selected : false );
};

/* Setup */

OO.inheritClass( OO.ui.RadioInputWidget, OO.ui.InputWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.RadioInputWidget.static.tagName = 'span';

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.RadioInputWidget.static.gatherPreInfuseState = function ( node, config ) {
  var state = OO.ui.RadioInputWidget.super.static.gatherPreInfuseState( node, config );
  state.checked = config.$input.prop( 'checked' );
  return state;
};

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.RadioInputWidget.prototype.getInputElement = function () {
  return $( '<input>' ).attr( 'type', 'radio' );
};

/**
 * @inheritdoc
 */
OO.ui.RadioInputWidget.prototype.onEdit = function () {
  // RadioInputWidget doesn't track its state.
};

/**
 * Set selection state of this radio button.
 *
 * @param {boolean} state `true` for selected
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.RadioInputWidget.prototype.setSelected = function ( state ) {
  // RadioInputWidget doesn't track its state.
  this.$input.prop( 'checked', state );
  // The first time that the selection state is set (probably while constructing the widget),
  // remember it in defaultSelected. This property can be later used to check whether
  // the selection state of the input has been changed since it was created.
  if ( this.defaultSelected === undefined ) {
    this.defaultSelected = state;
    this.$input[ 0 ].defaultChecked = this.defaultSelected;
  }
  return this;
};

/**
 * Check if this radio button is selected.
 *
 * @return {boolean} Radio is selected
 */
OO.ui.RadioInputWidget.prototype.isSelected = function () {
  return this.$input.prop( 'checked' );
};

/**
 * @inheritdoc
 */
OO.ui.RadioInputWidget.prototype.simulateLabelClick = function () {
  if ( !this.isDisabled() ) {
    this.$input.trigger( 'click' );
  }
  this.focus();
};

/**
 * @inheritdoc
 */
OO.ui.RadioInputWidget.prototype.restorePreInfuseState = function ( state ) {
  OO.ui.RadioInputWidget.super.prototype.restorePreInfuseState.call( this, state );
  if ( state.checked !== undefined && state.checked !== this.isSelected() ) {
    this.setSelected( state.checked );
  }
};

/**
 * RadioSelectInputWidget is a {@link OO.ui.RadioSelectWidget RadioSelectWidget} intended to be
 * used within an HTML form, such as a OO.ui.FormLayout. The selected value is synchronized with
 * the value of a hidden HTML `input` tag. Please see the [OOUI documentation on MediaWiki][1] for
 * more information about input widgets.
 *
 * This and OO.ui.DropdownInputWidget support similar configuration options.
 *
 *     @example
 *     // A RadioSelectInputWidget with three options
 *     var radioSelectInput = new OO.ui.RadioSelectInputWidget( {
 *         options: [
 *             { data: 'a', label: 'First' },
 *             { data: 'b', label: 'Second'},
 *             { data: 'c', label: 'Third' }
 *         ]
 *     } );
 *     $( document.body ).append( radioSelectInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object[]} [options=[]] Array of menu options in the format `{ data: …, label: … }`
 */
OO.ui.RadioSelectInputWidget = function OoUiRadioSelectInputWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Properties (must be done before parent constructor which calls #setDisabled)
  this.radioSelectWidget = new OO.ui.RadioSelectWidget();
  // Set up the options before parent constructor, which uses them to validate config.value.
  // Use this instead of setOptions() because this.$input is not set up yet
  this.setOptionsData( config.options || [] );

  // Parent constructor
  OO.ui.RadioSelectInputWidget.super.call( this, config );

  // Events
  this.radioSelectWidget.connect( this, {
    select: 'onMenuSelect'
  } );

  // Initialization
  this.$element
    .addClass( 'oo-ui-radioSelectInputWidget' )
    .append( this.radioSelectWidget.$element );
  this.setTabIndexedElement( this.radioSelectWidget.$tabIndexed );
};

/* Setup */

OO.inheritClass( OO.ui.RadioSelectInputWidget, OO.ui.InputWidget );

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.static.gatherPreInfuseState = function ( node, config ) {
  var state = OO.ui.RadioSelectInputWidget.super.static.gatherPreInfuseState( node, config );
  state.value = $( node ).find( '.oo-ui-radioInputWidget .oo-ui-inputWidget-input:checked' ).val();
  return state;
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.static.reusePreInfuseDOM = function ( node, config ) {
  config = OO.ui.RadioSelectInputWidget.super.static.reusePreInfuseDOM( node, config );
  // Cannot reuse the `<input type=radio>` set
  delete config.$input;
  return config;
};

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.RadioSelectInputWidget.prototype.getInputElement = function () {
  // Use this instead of <input type="hidden">, because hidden inputs do not have separate
  // 'value' and 'defaultValue' properties, and InputWidget wants to handle 'defaultValue'.
  return $( '<input>' ).addClass( 'oo-ui-element-hidden' );
};

/**
 * Handles menu select events.
 *
 * @private
 * @param {OO.ui.RadioOptionWidget} item Selected menu item
 */
OO.ui.RadioSelectInputWidget.prototype.onMenuSelect = function ( item ) {
  this.setValue( item.getData() );
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.prototype.setValue = function ( value ) {
  var selected;
  value = this.cleanUpValue( value );
  // Only allow setting values that are actually present in the dropdown
  selected = this.radioSelectWidget.findItemFromData( value ) ||
    this.radioSelectWidget.findFirstSelectableItem();
  this.radioSelectWidget.selectItem( selected );
  value = selected ? selected.getData() : '';
  OO.ui.RadioSelectInputWidget.super.prototype.setValue.call( this, value );
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.prototype.setDisabled = function ( state ) {
  this.radioSelectWidget.setDisabled( state );
  OO.ui.RadioSelectInputWidget.super.prototype.setDisabled.call( this, state );
  return this;
};

/**
 * Set the options available for this input.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: … }`
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.RadioSelectInputWidget.prototype.setOptions = function ( options ) {
  var value = this.getValue();

  this.setOptionsData( options );

  // Re-set the value to update the visible interface (RadioSelectWidget).
  // In case the previous value is no longer an available option, select the first valid one.
  this.setValue( value );

  return this;
};

/**
 * Set the internal list of options, used e.g. by setValue() to see which options are allowed.
 *
 * This method may be called before the parent constructor, so various properties may not be
 * intialized yet.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: … }`
 * @private
 */
OO.ui.RadioSelectInputWidget.prototype.setOptionsData = function ( options ) {
  var widget = this;

  this.radioSelectWidget
    .clearItems()
    .addItems( options.map( function ( opt ) {
      var optValue = widget.cleanUpValue( opt.data );
      return new OO.ui.RadioOptionWidget( {
        data: optValue,
        label: opt.label !== undefined ? opt.label : optValue
      } );
    } ) );
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.prototype.focus = function () {
  this.radioSelectWidget.focus();
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.RadioSelectInputWidget.prototype.blur = function () {
  this.radioSelectWidget.blur();
  return this;
};

/**
 * CheckboxMultiselectInputWidget is a
 * {@link OO.ui.CheckboxMultiselectWidget CheckboxMultiselectWidget} intended to be used within a
 * HTML form, such as a OO.ui.FormLayout. The selected values are synchronized with the value of
 * HTML `<input type=checkbox>` tags. Please see the [OOUI documentation on MediaWiki][1] for
 * more information about input widgets.
 *
 *     @example
 *     // A CheckboxMultiselectInputWidget with three options.
 *     var multiselectInput = new OO.ui.CheckboxMultiselectInputWidget( {
 *         options: [
 *             { data: 'a', label: 'First' },
 *             { data: 'b', label: 'Second' },
 *             { data: 'c', label: 'Third' }
 *         ]
 *     } );
 *     $( document.body ).append( multiselectInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object[]} [options=[]] Array of menu options in the format
 *  `{ data: …, label: …, disabled: … }`
 */
OO.ui.CheckboxMultiselectInputWidget = function OoUiCheckboxMultiselectInputWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Properties (must be done before parent constructor which calls #setDisabled)
  this.checkboxMultiselectWidget = new OO.ui.CheckboxMultiselectWidget();
  // Must be set before the #setOptionsData call below
  this.inputName = config.name;
  // Set up the options before parent constructor, which uses them to validate config.value.
  // Use this instead of setOptions() because this.$input is not set up yet
  this.setOptionsData( config.options || [] );

  // Parent constructor
  OO.ui.CheckboxMultiselectInputWidget.super.call( this, config );

  // Events
  this.checkboxMultiselectWidget.connect( this, {
    select: 'onCheckboxesSelect'
  } );

  // Initialization
  this.$element
    .addClass( 'oo-ui-checkboxMultiselectInputWidget' )
    .append( this.checkboxMultiselectWidget.$element );
  // We don't use this.$input, but rather the CheckboxInputWidgets inside each option
  this.$input.detach();
};

/* Setup */

OO.inheritClass( OO.ui.CheckboxMultiselectInputWidget, OO.ui.InputWidget );

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.static.gatherPreInfuseState = function ( node, config ) {
  var state = OO.ui.CheckboxMultiselectInputWidget.super.static.gatherPreInfuseState(
    node, config
  );
  state.value = $( node ).find( '.oo-ui-checkboxInputWidget .oo-ui-inputWidget-input:checked' )
    .toArray().map( function ( el ) { return el.value; } );
  return state;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.static.reusePreInfuseDOM = function ( node, config ) {
  config = OO.ui.CheckboxMultiselectInputWidget.super.static.reusePreInfuseDOM( node, config );
  // Cannot reuse the `<input type=checkbox>` set
  delete config.$input;
  return config;
};

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.getInputElement = function () {
  // Actually unused
  return $( '<unused>' );
};

/**
 * Handles CheckboxMultiselectWidget select events.
 *
 * @private
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.onCheckboxesSelect = function () {
  this.setValue( this.checkboxMultiselectWidget.findSelectedItemsData() );
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.getValue = function () {
  var value = this.$element.find( '.oo-ui-checkboxInputWidget .oo-ui-inputWidget-input:checked' )
    .toArray().map( function ( el ) { return el.value; } );
  if ( this.value !== value ) {
    this.setValue( value );
  }
  return this.value;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.setValue = function ( value ) {
  value = this.cleanUpValue( value );
  this.checkboxMultiselectWidget.selectItemsByData( value );
  OO.ui.CheckboxMultiselectInputWidget.super.prototype.setValue.call( this, value );
  if ( this.optionsDirty ) {
    // We reached this from the constructor or from #setOptions.
    // We have to update the <select> element.
    this.updateOptionsInterface();
  }
  return this;
};

/**
 * Clean up incoming value.
 *
 * @param {string[]} value Original value
 * @return {string[]} Cleaned up value
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.cleanUpValue = function ( value ) {
  var i, singleValue,
    cleanValue = [];
  if ( !Array.isArray( value ) ) {
    return cleanValue;
  }
  for ( i = 0; i < value.length; i++ ) {
    singleValue = OO.ui.CheckboxMultiselectInputWidget.super.prototype.cleanUpValue
      .call( this, value[ i ] );
    // Remove options that we don't have here
    if ( !this.checkboxMultiselectWidget.findItemFromData( singleValue ) ) {
      continue;
    }
    cleanValue.push( singleValue );
  }
  return cleanValue;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.setDisabled = function ( state ) {
  this.checkboxMultiselectWidget.setDisabled( state );
  OO.ui.CheckboxMultiselectInputWidget.super.prototype.setDisabled.call( this, state );
  return this;
};

/**
 * Set the options available for this input.
 *
 * @param {Object[]} options Array of menu options in the format
 *  `{ data: …, label: …, disabled: … }`
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.setOptions = function ( options ) {
  var value = this.getValue();

  this.setOptionsData( options );

  // Re-set the value to update the visible interface (CheckboxMultiselectWidget).
  // This will also get rid of any stale options that we just removed.
  this.setValue( value );

  return this;
};

/**
 * Set the internal list of options, used e.g. by setValue() to see which options are allowed.
 *
 * This method may be called before the parent constructor, so various properties may not be
 * intialized yet.
 *
 * @param {Object[]} options Array of menu options in the format
 *  `{ data: …, label: … }`
 * @private
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.setOptionsData = function ( options ) {
  var widget = this;

  this.optionsDirty = true;

  this.checkboxMultiselectWidget
    .clearItems()
    .addItems( options.map( function ( opt ) {
      var optValue, item, optDisabled;
      optValue = OO.ui.CheckboxMultiselectInputWidget.super.prototype.cleanUpValue
        .call( widget, opt.data );
      optDisabled = opt.disabled !== undefined ? opt.disabled : false;
      item = new OO.ui.CheckboxMultioptionWidget( {
        data: optValue,
        label: opt.label !== undefined ? opt.label : optValue,
        disabled: optDisabled
      } );
      // Set the 'name' and 'value' for form submission
      item.checkbox.$input.attr( 'name', widget.inputName );
      item.checkbox.setValue( optValue );
      return item;
    } ) );
};

/**
 * Update the user-visible interface to match the internal list of options and value.
 *
 * This method must only be called after the parent constructor.
 *
 * @private
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.updateOptionsInterface = function () {
  var defaultValue = this.defaultValue;

  this.checkboxMultiselectWidget.getItems().forEach( function ( item ) {
    // Remember original selection state. This property can be later used to check whether
    // the selection state of the input has been changed since it was created.
    var isDefault = defaultValue.indexOf( item.getData() ) !== -1;
    item.checkbox.defaultSelected = isDefault;
    item.checkbox.$input[ 0 ].defaultChecked = isDefault;
  } );

  this.optionsDirty = false;
};

/**
 * @inheritdoc
 */
OO.ui.CheckboxMultiselectInputWidget.prototype.focus = function () {
  this.checkboxMultiselectWidget.focus();
  return this;
};

/**
 * TextInputWidgets, like HTML text inputs, can be configured with options that customize the
 * size of the field as well as its presentation. In addition, these widgets can be configured
 * with {@link OO.ui.mixin.IconElement icons}, {@link OO.ui.mixin.IndicatorElement indicators}, an
 * optional validation-pattern (used to determine if an input value is valid or not) and an input
 * filter, which modifies incoming values rather than validating them.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 *     @example
 *     // A TextInputWidget.
 *     var textInput = new OO.ui.TextInputWidget( {
 *         value: 'Text input'
 *     } );
 *     $( document.body ).append( textInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 * @class
 * @extends OO.ui.InputWidget
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.PendingElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [type='text'] The value of the HTML `type` attribute: 'text', 'password'
 *  'email', 'url' or 'number'.
 * @cfg {string} [placeholder] Placeholder text
 * @cfg {boolean} [autofocus=false] Use an HTML `autofocus` attribute to
 *  instruct the browser to focus this widget.
 * @cfg {boolean} [readOnly=false] Prevent changes to the value of the text input.
 * @cfg {number} [maxLength] Maximum number of characters allowed in the input.
 *
 *  For unfortunate historical reasons, this counts the number of UTF-16 code units rather than
 *  Unicode codepoints, which means that codepoints outside the Basic Multilingual Plane (e.g.
 *  many emojis) count as 2 characters each.
 * @cfg {string} [labelPosition='after'] The position of the inline label relative to that of
 *  the value or placeholder text: `'before'` or `'after'`
 * @cfg {boolean} [required=false] Mark the field as required with `true`. Implies `indicator:
 *  'required'`. Note that `false` & setting `indicator: 'required' will result in no indicator
 *  shown.
 * @cfg {boolean} [autocomplete=true] Should the browser support autocomplete for this field
 * @cfg {boolean} [spellcheck] Should the browser support spellcheck for this field (`undefined`
 *  means leaving it up to the browser).
 * @cfg {RegExp|Function|string} [validate] Validation pattern: when string, a symbolic name of a
 *  pattern defined by the class: 'non-empty' (the value cannot be an empty string) or 'integer'
 *  (the value must contain only numbers); when RegExp, a regular expression that must match the
 *  value for it to be considered valid; when Function, a function receiving the value as parameter
 *  that must return true, or promise resolving to true, for it to be considered valid.
 */
OO.ui.TextInputWidget = function OoUiTextInputWidget( config ) {
  // Configuration initialization
  config = $.extend( {
    type: 'text',
    labelPosition: 'after'
  }, config );

  // Parent constructor
  OO.ui.TextInputWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.IndicatorElement.call( this, config );
  OO.ui.mixin.PendingElement.call( this, $.extend( { $pending: this.$input }, config ) );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.FlaggedElement.call( this, config );

  // Properties
  this.type = this.getSaneType( config );
  this.readOnly = false;
  this.required = false;
  this.validate = null;
  this.scrollWidth = null;

  this.setValidation( config.validate );
  this.setLabelPosition( config.labelPosition );

  // Events
  this.$input.on( {
    keypress: this.onKeyPress.bind( this ),
    blur: this.onBlur.bind( this ),
    focus: this.onFocus.bind( this )
  } );
  this.$icon.on( 'mousedown', this.onIconMouseDown.bind( this ) );
  this.$indicator.on( 'mousedown', this.onIndicatorMouseDown.bind( this ) );
  this.on( 'labelChange', this.updatePosition.bind( this ) );
  this.on( 'change', OO.ui.debounce( this.onDebouncedChange.bind( this ), 250 ) );

  // Initialization
  this.$element
    .addClass( 'oo-ui-textInputWidget oo-ui-textInputWidget-type-' + this.type )
    .append( this.$icon, this.$indicator );
  this.setReadOnly( !!config.readOnly );
  this.setRequired( !!config.required );
  if ( config.placeholder !== undefined ) {
    this.$input.attr( 'placeholder', config.placeholder );
  }
  if ( config.maxLength !== undefined ) {
    this.$input.attr( 'maxlength', config.maxLength );
  }
  if ( config.autofocus ) {
    this.$input.attr( 'autofocus', 'autofocus' );
  }
  if ( config.autocomplete === false ) {
    this.$input.attr( 'autocomplete', 'off' );
    // Turning off autocompletion also disables "form caching" when the user navigates to a
    // different page and then clicks "Back". Re-enable it when leaving.
    // Borrowed from jQuery UI.
    $( window ).on( {
      beforeunload: function () {
        this.$input.removeAttr( 'autocomplete' );
      }.bind( this ),
      pageshow: function () {
        // Browsers don't seem to actually fire this event on "Back", they instead just
        // reload the whole page... it shouldn't hurt, though.
        this.$input.attr( 'autocomplete', 'off' );
      }.bind( this )
    } );
  }
  if ( config.spellcheck !== undefined ) {
    this.$input.attr( 'spellcheck', config.spellcheck ? 'true' : 'false' );
  }
  if ( this.label ) {
    this.isWaitingToBeAttached = true;
    this.installParentChangeDetector();
  }
};

/* Setup */

OO.inheritClass( OO.ui.TextInputWidget, OO.ui.InputWidget );
OO.mixinClass( OO.ui.TextInputWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.TextInputWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.TextInputWidget, OO.ui.mixin.PendingElement );
OO.mixinClass( OO.ui.TextInputWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.TextInputWidget, OO.ui.mixin.FlaggedElement );

/* Static Properties */

OO.ui.TextInputWidget.static.validationPatterns = {
  'non-empty': /.+/,
  integer: /^\d+$/
};

/* Events */

/**
 * An `enter` event is emitted when the user presses Enter key inside the text box.
 *
 * @event enter
 */

/* Methods */

/**
 * Handle icon mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.TextInputWidget.prototype.onIconMouseDown = function ( e ) {
  if ( e.which === OO.ui.MouseButtons.LEFT ) {
    this.focus();
    return false;
  }
};

/**
 * Handle indicator mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.TextInputWidget.prototype.onIndicatorMouseDown = function ( e ) {
  if ( e.which === OO.ui.MouseButtons.LEFT ) {
    this.focus();
    return false;
  }
};

/**
 * Handle key press events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @fires enter If Enter key is pressed
 */
OO.ui.TextInputWidget.prototype.onKeyPress = function ( e ) {
  if ( e.which === OO.ui.Keys.ENTER ) {
    this.emit( 'enter', e );
  }
};

/**
 * Handle blur events.
 *
 * @private
 * @param {jQuery.Event} e Blur event
 */
OO.ui.TextInputWidget.prototype.onBlur = function () {
  this.setValidityFlag();
};

/**
 * Handle focus events.
 *
 * @private
 * @param {jQuery.Event} e Focus event
 */
OO.ui.TextInputWidget.prototype.onFocus = function () {
  if ( this.isWaitingToBeAttached ) {
    // If we've received focus, then we must be attached to the document, and if
    // isWaitingToBeAttached is still true, that means the handler never fired. Fire it now.
    this.onElementAttach();
  }
  this.setValidityFlag( true );
};

/**
 * Handle element attach events.
 *
 * @private
 * @param {jQuery.Event} e Element attach event
 */
OO.ui.TextInputWidget.prototype.onElementAttach = function () {
  this.isWaitingToBeAttached = false;
  // Any previously calculated size is now probably invalid if we reattached elsewhere
  this.valCache = null;
  this.positionLabel();
};

/**
 * Handle debounced change events.
 *
 * @param {string} value
 * @private
 */
OO.ui.TextInputWidget.prototype.onDebouncedChange = function () {
  this.setValidityFlag();
};

/**
 * Check if the input is {@link #readOnly read-only}.
 *
 * @return {boolean}
 */
OO.ui.TextInputWidget.prototype.isReadOnly = function () {
  return this.readOnly;
};

/**
 * Set the {@link #readOnly read-only} state of the input.
 *
 * @param {boolean} state Make input read-only
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.setReadOnly = function ( state ) {
  this.readOnly = !!state;
  this.$input.prop( 'readOnly', this.readOnly );
  return this;
};

/**
 * Check if the input is {@link #required required}.
 *
 * @return {boolean}
 */
OO.ui.TextInputWidget.prototype.isRequired = function () {
  return this.required;
};

/**
 * Set the {@link #required required} state of the input.
 *
 * @param {boolean} state Make input required
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.setRequired = function ( state ) {
  this.required = !!state;
  if ( this.required ) {
    this.$input
      .prop( 'required', true )
      .attr( 'aria-required', 'true' );
    if ( this.getIndicator() === null ) {
      this.setIndicator( 'required' );
    }
  } else {
    this.$input
      .prop( 'required', false )
      .removeAttr( 'aria-required' );
    if ( this.getIndicator() === 'required' ) {
      this.setIndicator( null );
    }
  }
  return this;
};

/**
 * Support function for making #onElementAttach work across browsers.
 *
 * This whole function could be replaced with one line of code using the DOMNodeInsertedIntoDocument
 * event, but it's not supported by Firefox and allegedly deprecated, so we only use it as fallback.
 *
 * Due to MutationObserver performance woes, #onElementAttach is only somewhat reliably called the
 * first time that the element gets attached to the documented.
 */
OO.ui.TextInputWidget.prototype.installParentChangeDetector = function () {
  var mutationObserver, onRemove, topmostNode, fakeParentNode,
    MutationObserver = window.MutationObserver ||
      window.WebKitMutationObserver ||
      window.MozMutationObserver,
    widget = this;

  if ( MutationObserver ) {
    // The new way. If only it wasn't so ugly.

    if ( this.isElementAttached() ) {
      // Widget is attached already, do nothing. This breaks the functionality of this
      // function when the widget is detached and reattached. Alas, doing this correctly with
      // MutationObserver would require observation of the whole document, which would hurt
      // performance of other, more important code.
      return;
    }

    // Find topmost node in the tree
    topmostNode = this.$element[ 0 ];
    while ( topmostNode.parentNode ) {
      topmostNode = topmostNode.parentNode;
    }

    // We have no way to detect the $element being attached somewhere without observing the
    // entire DOM with subtree modifications, which would hurt performance. So we cheat: we hook
    // to the parent node of $element, and instead detect when $element is removed from it (and
    // thus probably attached somewhere else). If there is no parent, we create a "fake" one. If
    // it doesn't get attached, we end up back here and create the parent.
    mutationObserver = new MutationObserver( function ( mutations ) {
      var i, j, removedNodes;
      for ( i = 0; i < mutations.length; i++ ) {
        removedNodes = mutations[ i ].removedNodes;
        for ( j = 0; j < removedNodes.length; j++ ) {
          if ( removedNodes[ j ] === topmostNode ) {
            setTimeout( onRemove, 0 );
            return;
          }
        }
      }
    } );

    onRemove = function () {
      // If the node was attached somewhere else, report it
      if ( widget.isElementAttached() ) {
        widget.onElementAttach();
      }
      mutationObserver.disconnect();
      widget.installParentChangeDetector();
    };

    // Create a fake parent and observe it
    fakeParentNode = $( '<div>' ).append( topmostNode )[ 0 ];
    mutationObserver.observe( fakeParentNode, { childList: true } );
  } else {
    // Using the DOMNodeInsertedIntoDocument event is much nicer and less magical, and works for
    // detachment and reattachment, but it's not supported by Firefox and allegedly deprecated.
    this.$element.on( 'DOMNodeInsertedIntoDocument', this.onElementAttach.bind( this ) );
  }
};

/**
 * @inheritdoc
 * @protected
 */
OO.ui.TextInputWidget.prototype.getInputElement = function ( config ) {
  if ( this.getSaneType( config ) === 'number' ) {
    return $( '<input>' )
      .attr( 'step', 'any' )
      .attr( 'type', 'number' );
  } else {
    return $( '<input>' ).attr( 'type', this.getSaneType( config ) );
  }
};

/**
 * Get sanitized value for 'type' for given config.
 *
 * @param {Object} config Configuration options
 * @return {string|null}
 * @protected
 */
OO.ui.TextInputWidget.prototype.getSaneType = function ( config ) {
  var allowedTypes = [
    'text',
    'password',
    'email',
    'url',
    'number'
  ];
  return allowedTypes.indexOf( config.type ) !== -1 ? config.type : 'text';
};

/**
 * Focus the input and select a specified range within the text.
 *
 * @param {number} from Select from offset
 * @param {number} [to] Select to offset, defaults to from
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.selectRange = function ( from, to ) {
  var isBackwards, start, end,
    input = this.$input[ 0 ];

  to = to || from;

  isBackwards = to < from;
  start = isBackwards ? to : from;
  end = isBackwards ? from : to;

  this.focus();

  try {
    input.setSelectionRange( start, end, isBackwards ? 'backward' : 'forward' );
  } catch ( e ) {
    // IE throws an exception if you call setSelectionRange on a unattached DOM node.
    // Rather than expensively check if the input is attached every time, just check
    // if it was the cause of an error being thrown. If not, rethrow the error.
    if ( this.getElementDocument().body.contains( input ) ) {
      throw e;
    }
  }
  return this;
};

/**
 * Get an object describing the current selection range in a directional manner
 *
 * @return {Object} Object containing 'from' and 'to' offsets
 */
OO.ui.TextInputWidget.prototype.getRange = function () {
  var input = this.$input[ 0 ],
    start = input.selectionStart,
    end = input.selectionEnd,
    isBackwards = input.selectionDirection === 'backward';

  return {
    from: isBackwards ? end : start,
    to: isBackwards ? start : end
  };
};

/**
 * Get the length of the text input value.
 *
 * This could differ from the length of #getValue if the
 * value gets filtered
 *
 * @return {number} Input length
 */
OO.ui.TextInputWidget.prototype.getInputLength = function () {
  return this.$input[ 0 ].value.length;
};

/**
 * Focus the input and select the entire text.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.select = function () {
  return this.selectRange( 0, this.getInputLength() );
};

/**
 * Focus the input and move the cursor to the start.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.moveCursorToStart = function () {
  return this.selectRange( 0 );
};

/**
 * Focus the input and move the cursor to the end.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.moveCursorToEnd = function () {
  return this.selectRange( this.getInputLength() );
};

/**
 * Insert new content into the input.
 *
 * @param {string} content Content to be inserted
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.insertContent = function ( content ) {
  var start, end,
    range = this.getRange(),
    value = this.getValue();

  start = Math.min( range.from, range.to );
  end = Math.max( range.from, range.to );

  this.setValue( value.slice( 0, start ) + content + value.slice( end ) );
  this.selectRange( start + content.length );
  return this;
};

/**
 * Insert new content either side of a selection.
 *
 * @param {string} pre Content to be inserted before the selection
 * @param {string} post Content to be inserted after the selection
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.encapsulateContent = function ( pre, post ) {
  var start, end,
    range = this.getRange(),
    offset = pre.length;

  start = Math.min( range.from, range.to );
  end = Math.max( range.from, range.to );

  this.selectRange( start ).insertContent( pre );
  this.selectRange( offset + end ).insertContent( post );

  this.selectRange( offset + start, offset + end );
  return this;
};

/**
 * Set the validation pattern.
 *
 * The validation pattern is either a regular expression, a function, or the symbolic name of a
 * pattern defined by the class: 'non-empty' (the value cannot be an empty string) or 'integer' (the
 * value must contain only numbers).
 *
 * @param {RegExp|Function|string|null} validate Regular expression, function, or the symbolic name
 *  of a pattern (either ‘integer’ or ‘non-empty’) defined by the class.
 */
OO.ui.TextInputWidget.prototype.setValidation = function ( validate ) {
  if ( validate instanceof RegExp || validate instanceof Function ) {
    this.validate = validate;
  } else {
    this.validate = this.constructor.static.validationPatterns[ validate ] || /.*/;
  }
};

/**
 * Sets the 'invalid' flag appropriately.
 *
 * @param {boolean} [isValid] Optionally override validation result
 */
OO.ui.TextInputWidget.prototype.setValidityFlag = function ( isValid ) {
  var widget = this,
    setFlag = function ( valid ) {
      if ( !valid ) {
        widget.$input.attr( 'aria-invalid', 'true' );
      } else {
        widget.$input.removeAttr( 'aria-invalid' );
      }
      widget.setFlags( { invalid: !valid } );
    };

  if ( isValid !== undefined ) {
    setFlag( isValid );
  } else {
    this.getValidity().then( function () {
      setFlag( true );
    }, function () {
      setFlag( false );
    } );
  }
};

/**
 * Get the validity of current value.
 *
 * This method returns a promise that resolves if the value is valid and rejects if
 * it isn't. Uses the {@link #validate validation pattern}  to check for validity.
 *
 * @return {jQuery.Promise} A promise that resolves if the value is valid, rejects if not.
 */
OO.ui.TextInputWidget.prototype.getValidity = function () {
  var result;

  function rejectOrResolve( valid ) {
    if ( valid ) {
      return $.Deferred().resolve().promise();
    } else {
      return $.Deferred().reject().promise();
    }
  }

  // Check browser validity and reject if it is invalid
  if (
    this.$input[ 0 ].checkValidity !== undefined &&
    this.$input[ 0 ].checkValidity() === false
  ) {
    return rejectOrResolve( false );
  }

  // Run our checks if the browser thinks the field is valid
  if ( this.validate instanceof Function ) {
    result = this.validate( this.getValue() );
    if ( result && typeof result.promise === 'function' ) {
      return result.promise().then( function ( valid ) {
        return rejectOrResolve( valid );
      } );
    } else {
      return rejectOrResolve( result );
    }
  } else {
    return rejectOrResolve( this.getValue().match( this.validate ) );
  }
};

/**
 * Set the position of the inline label relative to that of the value: `‘before’` or `‘after’`.
 *
 * @param {string} labelPosition Label position, 'before' or 'after'
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.setLabelPosition = function ( labelPosition ) {
  this.labelPosition = labelPosition;
  if ( this.label ) {
    // If there is no label and we only change the position, #updatePosition is a no-op,
    // but it takes really a lot of work to do nothing.
    this.updatePosition();
  }
  return this;
};

/**
 * Update the position of the inline label.
 *
 * This method is called by #setLabelPosition, and can also be called on its own if
 * something causes the label to be mispositioned.
 *
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.updatePosition = function () {
  var after = this.labelPosition === 'after';

  this.$element
    .toggleClass( 'oo-ui-textInputWidget-labelPosition-after', !!this.label && after )
    .toggleClass( 'oo-ui-textInputWidget-labelPosition-before', !!this.label && !after );

  this.valCache = null;
  this.scrollWidth = null;
  this.positionLabel();

  return this;
};

/**
 * Position the label by setting the correct padding on the input.
 *
 * @private
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TextInputWidget.prototype.positionLabel = function () {
  var after, rtl, property, newCss;

  if ( this.isWaitingToBeAttached ) {
    // #onElementAttach will be called soon, which calls this method
    return this;
  }

  newCss = {
    'padding-right': '',
    'padding-left': ''
  };

  if ( this.label ) {
    this.$element.append( this.$label );
  } else {
    this.$label.detach();
    // Clear old values if present
    this.$input.css( newCss );
    return;
  }

  after = this.labelPosition === 'after';
  rtl = this.$element.css( 'direction' ) === 'rtl';
  property = after === rtl ? 'padding-left' : 'padding-right';

  newCss[ property ] = this.$label.outerWidth( true ) + ( after ? this.scrollWidth : 0 );
  // We have to clear the padding on the other side, in case the element direction changed
  this.$input.css( newCss );

  return this;
};

/**
 * SearchInputWidgets are TextInputWidgets with `type="search"` assigned and feature a
 * {@link OO.ui.mixin.IconElement search icon} by default.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs#SearchInputWidget
 *
 * @class
 * @extends OO.ui.TextInputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.SearchInputWidget = function OoUiSearchInputWidget( config ) {
  config = $.extend( {
    icon: 'search'
  }, config );

  // Parent constructor
  OO.ui.SearchInputWidget.super.call( this, config );

  // Events
  this.connect( this, {
    change: 'onChange'
  } );
  this.$indicator.on( 'click', this.onIndicatorClick.bind( this ) );
  this.$indicator.on( 'keydown', this.onIndicatorKeyDown.bind( this ) );

  // Initialization
  this.updateSearchIndicator();
  this.connect( this, {
    disable: 'onDisable'
  } );
  this.$indicator
    .attr( 'tabindex', -1 )
    .attr( 'role', 'button' );
};

/* Setup */

OO.inheritClass( OO.ui.SearchInputWidget, OO.ui.TextInputWidget );

/* Methods */

/**
 * @inheritdoc
 * @protected
 */
OO.ui.SearchInputWidget.prototype.getSaneType = function () {
  return 'search';
};

/**
 * Handle key down events on the indicator
 *
 * @param {jQuery.Event} e KeyDown event
 * @return {boolean}
 */
OO.ui.SearchInputWidget.prototype.onIndicatorKeyDown = function ( e ) {
  if ( e.keyCode === OO.ui.Keys.ENTER ) {
    // Clear the text field
    this.setValue( '' );
    this.focus();
    return false;
  }
};

/**
 * Handle click events on the indicator
 *
 * @param {jQuery.Event} e Click event
 * @return {boolean}
 */
OO.ui.SearchInputWidget.prototype.onIndicatorClick = function ( e ) {
  if ( e.which === OO.ui.MouseButtons.LEFT ) {
    // Clear the text field
    this.setValue( '' );
    this.focus();
    return false;
  }
};

/**
 * Update the 'clear' indicator displayed on type: 'search' text
 * fields, hiding it when the field is already empty or when it's not
 * editable.
 */
OO.ui.SearchInputWidget.prototype.updateSearchIndicator = function () {
  if ( this.getValue() === '' || this.isDisabled() || this.isReadOnly() ) {
    this.setIndicator( null );
  } else {
    this.setIndicator( 'clear' );
    this.$indicator.attr( 'aria-label', OO.ui.msg( 'ooui-item-remove' ) );
  }
};

/**
 * Handle change events.
 *
 * @private
 */
OO.ui.SearchInputWidget.prototype.onChange = function () {
  this.updateSearchIndicator();
};

/**
 * Handle disable events.
 *
 * @param {boolean} disabled Element is disabled
 * @private
 */
OO.ui.SearchInputWidget.prototype.onDisable = function () {
  this.updateSearchIndicator();
};

/**
 * @inheritdoc
 */
OO.ui.SearchInputWidget.prototype.setReadOnly = function ( state ) {
  OO.ui.SearchInputWidget.super.prototype.setReadOnly.call( this, state );
  this.updateSearchIndicator();
  return this;
};

/**
 * MultilineTextInputWidgets, like HTML textareas, are featuring customization options to
 * configure number of rows visible. In addition, these widgets can be autosized to fit user
 * inputs and can show {@link OO.ui.mixin.IconElement icons} and
 * {@link OO.ui.mixin.IndicatorElement indicators}.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 *     @example
 *     // A MultilineTextInputWidget.
 *     var multilineTextInput = new OO.ui.MultilineTextInputWidget( {
 *         value: 'Text input on multiple lines'
 *     } );
 *     $( document.body ).append( multilineTextInput.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs#MultilineTextInputWidget
 *
 * @class
 * @extends OO.ui.TextInputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {number} [rows] Number of visible lines in textarea. If used with `autosize`,
 *  specifies minimum number of rows to display.
 * @cfg {boolean} [autosize=false] Automatically resize the text input to fit its content.
 *  Use the #maxRows config to specify a maximum number of displayed rows.
 * @cfg {number} [maxRows] Maximum number of rows to display when #autosize is set to true.
 *  Defaults to the maximum of `10` and `2 * rows`, or `10` if `rows` isn't provided.
 */
OO.ui.MultilineTextInputWidget = function OoUiMultilineTextInputWidget( config ) {
  config = $.extend( {
    type: 'text'
  }, config );
  // Parent constructor
  OO.ui.MultilineTextInputWidget.super.call( this, config );

  // Properties
  this.autosize = !!config.autosize;
  this.styleHeight = null;
  this.minRows = config.rows !== undefined ? config.rows : '';
  this.maxRows = config.maxRows || Math.max( 2 * ( this.minRows || 0 ), 10 );

  // Clone for resizing
  if ( this.autosize ) {
    this.$clone = this.$input
      .clone()
      .removeAttr( 'id' )
      .removeAttr( 'name' )
      .insertAfter( this.$input )
      .attr( 'aria-hidden', 'true' )
      .addClass( 'oo-ui-element-hidden' );
  }

  // Events
  this.connect( this, {
    change: 'onChange'
  } );

  // Initialization
  if ( config.rows ) {
    this.$input.attr( 'rows', config.rows );
  }
  if ( this.autosize ) {
    this.$input.addClass( 'oo-ui-textInputWidget-autosized' );
    this.isWaitingToBeAttached = true;
    this.installParentChangeDetector();
  }
};

/* Setup */

OO.inheritClass( OO.ui.MultilineTextInputWidget, OO.ui.TextInputWidget );

/* Events */

/**
 * An `resize` event is emitted when the widget changes size via the autosize functionality.
 *
 * @event resize
 */

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.MultilineTextInputWidget.static.gatherPreInfuseState = function ( node, config ) {
  var state = OO.ui.MultilineTextInputWidget.super.static.gatherPreInfuseState( node, config );
  state.scrollTop = config.$input.scrollTop();
  return state;
};

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.MultilineTextInputWidget.prototype.onElementAttach = function () {
  OO.ui.MultilineTextInputWidget.super.prototype.onElementAttach.call( this );
  this.adjustSize();
};

/**
 * Handle change events.
 *
 * @private
 */
OO.ui.MultilineTextInputWidget.prototype.onChange = function () {
  this.adjustSize();
};

/**
 * @inheritdoc
 */
OO.ui.MultilineTextInputWidget.prototype.updatePosition = function () {
  OO.ui.MultilineTextInputWidget.super.prototype.updatePosition.call( this );
  this.adjustSize();
};

/**
 * @inheritdoc
 *
 * Modify to emit 'enter' on Ctrl/Meta+Enter, instead of plain Enter
 */
OO.ui.MultilineTextInputWidget.prototype.onKeyPress = function ( e ) {
  if (
    ( e.which === OO.ui.Keys.ENTER && ( e.ctrlKey || e.metaKey ) ) ||
    // Some platforms emit keycode 10 for Control+Enter keypress in a textarea
    e.which === 10
  ) {
    this.emit( 'enter', e );
  }
};

/**
 * Automatically adjust the size of the text input.
 *
 * This only affects multiline inputs that are {@link #autosize autosized}.
 *
 * @chainable
 * @param {boolean} [force] Force an update, even if the value hasn't changed
 * @return {OO.ui.Widget} The widget, for chaining
 * @fires resize
 */
OO.ui.MultilineTextInputWidget.prototype.adjustSize = function ( force ) {
  var scrollHeight, innerHeight, outerHeight, maxInnerHeight, measurementError,
    idealHeight, newHeight, scrollWidth, property;

  if ( force || this.$input.val() !== this.valCache ) {
    if ( this.autosize ) {
      this.$clone
        .val( this.$input.val() )
        .attr( 'rows', this.minRows )
        // Set inline height property to 0 to measure scroll height
        .css( 'height', 0 );

      this.$clone.removeClass( 'oo-ui-element-hidden' );

      this.valCache = this.$input.val();

      scrollHeight = this.$clone[ 0 ].scrollHeight;

      // Remove inline height property to measure natural heights
      this.$clone.css( 'height', '' );
      innerHeight = this.$clone.innerHeight();
      outerHeight = this.$clone.outerHeight();

      // Measure max rows height
      this.$clone
        .attr( 'rows', this.maxRows )
        .css( 'height', 'auto' )
        .val( '' );
      maxInnerHeight = this.$clone.innerHeight();

      // Difference between reported innerHeight and scrollHeight with no scrollbars present.
      // This is sometimes non-zero on Blink-based browsers, depending on zoom level.
      measurementError = maxInnerHeight - this.$clone[ 0 ].scrollHeight;
      idealHeight = Math.min( maxInnerHeight, scrollHeight + measurementError );

      this.$clone.addClass( 'oo-ui-element-hidden' );

      // Only apply inline height when expansion beyond natural height is needed
      // Use the difference between the inner and outer height as a buffer
      newHeight = idealHeight > innerHeight ? idealHeight + ( outerHeight - innerHeight ) : '';
      if ( newHeight !== this.styleHeight ) {
        this.$input.css( 'height', newHeight );
        this.styleHeight = newHeight;
        this.emit( 'resize' );
      }
    }
    scrollWidth = this.$input[ 0 ].offsetWidth - this.$input[ 0 ].clientWidth;
    if ( scrollWidth !== this.scrollWidth ) {
      property = this.$element.css( 'direction' ) === 'rtl' ? 'left' : 'right';
      // Reset
      this.$label.css( { right: '', left: '' } );
      this.$indicator.css( { right: '', left: '' } );

      if ( scrollWidth ) {
        this.$indicator.css( property, scrollWidth );
        if ( this.labelPosition === 'after' ) {
          this.$label.css( property, scrollWidth );
        }
      }

      this.scrollWidth = scrollWidth;
      this.positionLabel();
    }
  }
  return this;
};

/**
 * @inheritdoc
 * @protected
 */
OO.ui.MultilineTextInputWidget.prototype.getInputElement = function () {
  return $( '<textarea>' );
};

/**
 * Check if the input automatically adjusts its size.
 *
 * @return {boolean}
 */
OO.ui.MultilineTextInputWidget.prototype.isAutosizing = function () {
  return !!this.autosize;
};

/**
 * @inheritdoc
 */
OO.ui.MultilineTextInputWidget.prototype.restorePreInfuseState = function ( state ) {
  OO.ui.MultilineTextInputWidget.super.prototype.restorePreInfuseState.call( this, state );
  if ( state.scrollTop !== undefined ) {
    this.$input.scrollTop( state.scrollTop );
  }
};

/**
 * ComboBoxInputWidgets combine a {@link OO.ui.TextInputWidget text input} (where a value
 * can be entered manually) and a {@link OO.ui.MenuSelectWidget menu of options} (from which
 * a value can be chosen instead). Users can choose options from the combo box in one of two ways:
 *
 * - by typing a value in the text input field. If the value exactly matches the value of a menu
 *   option, that option will appear to be selected.
 * - by choosing a value from the menu. The value of the chosen option will then appear in the text
 *   input field.
 *
 * After the user chooses an option, its `data` will be used as a new value for the widget.
 * A `label` also can be specified for each option: if given, it will be shown instead of the
 * `data` in the dropdown menu.
 *
 * This widget can be used inside an HTML form, such as a OO.ui.FormLayout.
 *
 * For more information about menus and options, please see the
 * [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // A ComboBoxInputWidget.
 *     var comboBox = new OO.ui.ComboBoxInputWidget( {
 *         value: 'Option 1',
 *         options: [
 *             { data: 'Option 1' },
 *             { data: 'Option 2' },
 *             { data: 'Option 3' }
 *         ]
 *     } );
 *     $( document.body ).append( comboBox.$element );
 *
 *     @example
 *     // Example: A ComboBoxInputWidget with additional option labels.
 *     var comboBox = new OO.ui.ComboBoxInputWidget( {
 *         value: 'Option 1',
 *         options: [
 *             {
 *                 data: 'Option 1',
 *                 label: 'Option One'
 *             },
 *             {
 *                 data: 'Option 2',
 *                 label: 'Option Two'
 *             },
 *             {
 *                 data: 'Option 3',
 *                 label: 'Option Three'
 *             }
 *         ]
 *     } );
 *     $( document.body ).append( comboBox.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Menu_selects_and_options
 *
 * @class
 * @extends OO.ui.TextInputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object[]} [options=[]] Array of menu options in the format `{ data: …, label: … }`
 * @cfg {Object} [menu] Configuration options to pass to the {@link OO.ui.MenuSelectWidget menu
 *  select widget}.
 * @cfg {jQuery} [$overlay] Render the menu into a separate layer. This configuration is useful
 *  in cases where the expanded menu is larger than its containing `<div>`. The specified overlay
 *  layer is usually on top of the containing `<div>` and has a larger area. By default, the menu
 *  uses relative positioning.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.ComboBoxInputWidget = function OoUiComboBoxInputWidget( config ) {
  // Configuration initialization
  config = $.extend( {
    autocomplete: false
  }, config );

  // ComboBoxInputWidget shouldn't support `multiline`
  config.multiline = false;

  // See InputWidget#reusePreInfuseDOM about `config.$input`
  if ( config.$input ) {
    config.$input.removeAttr( 'list' );
  }

  // Parent constructor
  OO.ui.ComboBoxInputWidget.super.call( this, config );

  // Properties
  this.$overlay = ( config.$overlay === true ?
    OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;
  this.dropdownButton = new OO.ui.ButtonWidget( {
    classes: [ 'oo-ui-comboBoxInputWidget-dropdownButton' ],
    label: OO.ui.msg( 'ooui-combobox-button-label' ),
    indicator: 'down',
    invisibleLabel: true,
    disabled: this.disabled
  } );
  this.menu = new OO.ui.MenuSelectWidget( $.extend(
    {
      widget: this,
      input: this,
      $floatableContainer: this.$element,
      disabled: this.isDisabled()
    },
    config.menu
  ) );

  // Events
  this.connect( this, {
    change: 'onInputChange',
    enter: 'onInputEnter'
  } );
  this.dropdownButton.connect( this, {
    click: 'onDropdownButtonClick'
  } );
  this.menu.connect( this, {
    choose: 'onMenuChoose',
    add: 'onMenuItemsChange',
    remove: 'onMenuItemsChange',
    toggle: 'onMenuToggle'
  } );

  // Initialization
  this.$input.attr( {
    role: 'combobox',
    'aria-owns': this.menu.getElementId(),
    'aria-autocomplete': 'list'
  } );
  this.dropdownButton.$button.attr( {
    'aria-controls': this.menu.getElementId()
  } );
  // Do not override options set via config.menu.items
  if ( config.options !== undefined ) {
    this.setOptions( config.options );
  }
  this.$field = $( '<div>' )
    .addClass( 'oo-ui-comboBoxInputWidget-field' )
    .append( this.$input, this.dropdownButton.$element );
  this.$element
    .addClass( 'oo-ui-comboBoxInputWidget' )
    .append( this.$field );
  this.$overlay.append( this.menu.$element );
  this.onMenuItemsChange();
};

/* Setup */

OO.inheritClass( OO.ui.ComboBoxInputWidget, OO.ui.TextInputWidget );

/* Methods */

/**
 * Get the combobox's menu.
 *
 * @return {OO.ui.MenuSelectWidget} Menu widget
 */
OO.ui.ComboBoxInputWidget.prototype.getMenu = function () {
  return this.menu;
};

/**
 * Get the combobox's text input widget.
 *
 * @return {OO.ui.TextInputWidget} Text input widget
 */
OO.ui.ComboBoxInputWidget.prototype.getInput = function () {
  return this;
};

/**
 * Handle input change events.
 *
 * @private
 * @param {string} value New value
 */
OO.ui.ComboBoxInputWidget.prototype.onInputChange = function ( value ) {
  var match = this.menu.findItemFromData( value );

  this.menu.selectItem( match );
  if ( this.menu.findHighlightedItem() ) {
    this.menu.highlightItem( match );
  }

  if ( !this.isDisabled() ) {
    this.menu.toggle( true );
  }
};

/**
 * Handle input enter events.
 *
 * @private
 */
OO.ui.ComboBoxInputWidget.prototype.onInputEnter = function () {
  if ( !this.isDisabled() ) {
    this.menu.toggle( false );
  }
};

/**
 * Handle button click events.
 *
 * @private
 */
OO.ui.ComboBoxInputWidget.prototype.onDropdownButtonClick = function () {
  this.menu.toggle();
  this.focus();
};

/**
 * Handle menu choose events.
 *
 * @private
 * @param {OO.ui.OptionWidget} item Chosen item
 */
OO.ui.ComboBoxInputWidget.prototype.onMenuChoose = function ( item ) {
  this.setValue( item.getData() );
};

/**
 * Handle menu item change events.
 *
 * @private
 */
OO.ui.ComboBoxInputWidget.prototype.onMenuItemsChange = function () {
  var match = this.menu.findItemFromData( this.getValue() );
  this.menu.selectItem( match );
  if ( this.menu.findHighlightedItem() ) {
    this.menu.highlightItem( match );
  }
  this.$element.toggleClass( 'oo-ui-comboBoxInputWidget-empty', this.menu.isEmpty() );
};

/**
 * Handle menu toggle events.
 *
 * @private
 * @param {boolean} isVisible Open state of the menu
 */
OO.ui.ComboBoxInputWidget.prototype.onMenuToggle = function ( isVisible ) {
  this.$element.toggleClass( 'oo-ui-comboBoxInputWidget-open', isVisible );
};

/**
 * Update the disabled state of the controls
 *
 * @chainable
 * @protected
 * @return {OO.ui.ComboBoxInputWidget} The widget, for chaining
 */
OO.ui.ComboBoxInputWidget.prototype.updateControlsDisabled = function () {
  var disabled = this.isDisabled() || this.isReadOnly();
  if ( this.dropdownButton ) {
    this.dropdownButton.setDisabled( disabled );
  }
  if ( this.menu ) {
    this.menu.setDisabled( disabled );
  }
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.ComboBoxInputWidget.prototype.setDisabled = function () {
  // Parent method
  OO.ui.ComboBoxInputWidget.super.prototype.setDisabled.apply( this, arguments );
  this.updateControlsDisabled();
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.ComboBoxInputWidget.prototype.setReadOnly = function () {
  // Parent method
  OO.ui.ComboBoxInputWidget.super.prototype.setReadOnly.apply( this, arguments );
  this.updateControlsDisabled();
  return this;
};

/**
 * Set the options available for this input.
 *
 * @param {Object[]} options Array of menu options in the format `{ data: …, label: … }`
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ComboBoxInputWidget.prototype.setOptions = function ( options ) {
  this.getMenu()
    .clearItems()
    .addItems( options.map( function ( opt ) {
      return new OO.ui.MenuOptionWidget( {
        data: opt.data,
        label: opt.label !== undefined ? opt.label : opt.data
      } );
    } ) );

  return this;
};

/**
 * FieldLayouts are used with OO.ui.FieldsetLayout. Each FieldLayout requires a field-widget,
 * which is a widget that is specified by reference before any optional configuration settings.
 *
 * Field layouts can be configured with help text and/or labels. Labels are aligned in one of
 * four ways:
 *
 * - **left**: The label is placed before the field-widget and aligned with the left margin.
 *   A left-alignment is used for forms with many fields.
 * - **right**: The label is placed before the field-widget and aligned to the right margin.
 *   A right-alignment is used for long but familiar forms which users tab through,
 *   verifying the current field with a quick glance at the label.
 * - **top**: The label is placed above the field-widget. A top-alignment is used for brief forms
 *   that users fill out from top to bottom.
 * - **inline**: The label is placed after the field-widget and aligned to the left.
 *   An inline-alignment is best used with checkboxes or radio buttons.
 *
 * Help text can either be:
 *
 * - accessed via a help icon that appears in the upper right corner of the rendered field layout,
 *   or
 * - shown as a subtle explanation below the label.
 *
 * If the help text is brief, or is essential to always expose it, set `helpInline` to `true`.
 * If it is long or not essential, leave `helpInline` to its default, `false`.
 *
 * Please see the [OOUI documentation on MediaWiki] [1] for examples and more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Layouts/Fields_and_Fieldsets
 *
 * @class
 * @extends OO.ui.Layout
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {OO.ui.Widget} fieldWidget Field widget
 * @param {Object} [config] Configuration options
 * @cfg {string} [align='left'] Alignment of the label: 'left', 'right', 'top'
 *  or 'inline'
 * @cfg {Array} [errors] Error messages about the widget, which will be
 *  displayed below the widget.
 * @cfg {Array} [warnings] Warning messages about the widget, which will be
 *  displayed below the widget.
 * @cfg {Array} [successMessages] Success messages on user interactions with the widget,
 *  which will be displayed below the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 * @cfg {Array} [notices] Notices about the widget, which will be displayed
 *  below the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 *  These are more visible than `help` messages when `helpInline` is set, and so
 *  might be good for transient messages.
 * @cfg {string|OO.ui.HtmlSnippet} [help] Help text. When help text is specified
 *  and `helpInline` is `false`, a "help" icon will appear in the upper-right
 *  corner of the rendered field; clicking it will display the text in a popup.
 *  If `helpInline` is `true`, then a subtle description will be shown after the
 *  label.
 * @cfg {boolean} [helpInline=false] Whether or not the help should be inline,
 *  or shown when the "help" icon is clicked.
 * @cfg {jQuery} [$overlay] Passed to OO.ui.PopupButtonWidget for help popup, if
 * `help` is given.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 *
 * @throws {Error} An error is thrown if no widget is specified
 */
OO.ui.FieldLayout = function OoUiFieldLayout( fieldWidget, config ) {
  var id;

  // Allow passing positional parameters inside the config object
  if ( OO.isPlainObject( fieldWidget ) && config === undefined ) {
    config = fieldWidget;
    fieldWidget = config.fieldWidget;
  }

  // Make sure we have required constructor arguments
  if ( fieldWidget === undefined ) {
    throw new Error( 'Widget not found' );
  }

  // Configuration initialization
  config = $.extend( { align: 'left', helpInline: false }, config );

  // Parent constructor
  OO.ui.FieldLayout.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.LabelElement.call( this, $.extend( {
    $label: $( '<label>' )
  }, config ) );
  OO.ui.mixin.TitledElement.call( this, $.extend( { $titled: this.$label }, config ) );

  // Properties
  this.fieldWidget = fieldWidget;
  this.errors = [];
  this.warnings = [];
  this.successMessages = [];
  this.notices = [];
  this.$field = this.isFieldInline() ? $( '<span>' ) : $( '<div>' );
  this.$messages = $( '<div>' );
  this.$header = $( '<span>' );
  this.$body = $( '<div>' );
  this.align = null;
  this.helpInline = config.helpInline;

  // Events
  this.fieldWidget.connect( this, {
    disable: 'onFieldDisable'
  } );

  // Initialization
  this.$help = config.help ?
    this.createHelpElement( config.help, config.$overlay ) :
    $( [] );
  if ( this.fieldWidget.getInputId() ) {
    this.$label.attr( 'for', this.fieldWidget.getInputId() );
    if ( this.helpInline ) {
      this.$help.attr( 'for', this.fieldWidget.getInputId() );
    }
  } else {
    // We can't use `label for` with non-form elements, use `aria-labelledby` instead
    id = OO.ui.generateElementId();
    this.$label.attr( 'id', id );
    this.fieldWidget.setLabelledBy( id );

    // Forward clicks on the label to the widget, like `label for` would do
    this.$label.on( 'click', function () {
      this.fieldWidget.simulateLabelClick();
    }.bind( this ) );
    if ( this.helpInline ) {
      this.$help.on( 'click', function () {
        this.fieldWidget.simulateLabelClick();
      }.bind( this ) );
    }
  }
  this.$element
    .addClass( 'oo-ui-fieldLayout' )
    .toggleClass( 'oo-ui-fieldLayout-disabled', this.fieldWidget.isDisabled() )
    .append( this.$body );
  this.$body.addClass( 'oo-ui-fieldLayout-body' );
  this.$header.addClass( 'oo-ui-fieldLayout-header' );
  this.$messages.addClass( 'oo-ui-fieldLayout-messages' );
  this.$field
    .addClass( 'oo-ui-fieldLayout-field' )
    .append( this.fieldWidget.$element );

  this.setErrors( config.errors || [] );
  this.setWarnings( config.warnings || [] );
  this.setSuccess( config.successMessages || [] );
  this.setNotices( config.notices || [] );
  this.setAlignment( config.align );
  // Call this again to take into account the widget's accessKey
  this.updateTitle();
};

/* Setup */

OO.inheritClass( OO.ui.FieldLayout, OO.ui.Layout );
OO.mixinClass( OO.ui.FieldLayout, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.FieldLayout, OO.ui.mixin.TitledElement );

/* Methods */

/**
 * Handle field disable events.
 *
 * @private
 * @param {boolean} value Field is disabled
 */
OO.ui.FieldLayout.prototype.onFieldDisable = function ( value ) {
  this.$element.toggleClass( 'oo-ui-fieldLayout-disabled', value );
};

/**
 * Get the widget contained by the field.
 *
 * @return {OO.ui.Widget} Field widget
 */
OO.ui.FieldLayout.prototype.getField = function () {
  return this.fieldWidget;
};

/**
 * Return `true` if the given field widget can be used with `'inline'` alignment (see
 * #setAlignment). Return `false` if it can't or if this can't be determined.
 *
 * @return {boolean}
 */
OO.ui.FieldLayout.prototype.isFieldInline = function () {
  // This is very simplistic, but should be good enough.
  return this.getField().$element.prop( 'tagName' ).toLowerCase() === 'span';
};

/**
 * @protected
 * @param {string} kind 'error' or 'notice'
 * @param {string|OO.ui.HtmlSnippet} text
 * @return {jQuery}
 */
OO.ui.FieldLayout.prototype.makeMessage = function ( kind, text ) {
  return new OO.ui.MessageWidget( {
    type: kind,
    inline: true,
    label: text
  } ).$element;
};

/**
 * Set the field alignment mode.
 *
 * @private
 * @param {string} value Alignment mode, either 'left', 'right', 'top' or 'inline'
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.FieldLayout.prototype.setAlignment = function ( value ) {
  if ( value !== this.align ) {
    // Default to 'left'
    if ( [ 'left', 'right', 'top', 'inline' ].indexOf( value ) === -1 ) {
      value = 'left';
    }
    // Validate
    if ( value === 'inline' && !this.isFieldInline() ) {
      value = 'top';
    }
    // Reorder elements

    if ( this.helpInline ) {
      if ( value === 'top' ) {
        this.$header.append( this.$label );
        this.$body.append( this.$header, this.$field, this.$help );
      } else if ( value === 'inline' ) {
        this.$header.append( this.$label, this.$help );
        this.$body.append( this.$field, this.$header );
      } else {
        this.$header.append( this.$label, this.$help );
        this.$body.append( this.$header, this.$field );
      }
    } else {
      if ( value === 'top' ) {
        this.$header.append( this.$help, this.$label );
        this.$body.append( this.$header, this.$field );
      } else if ( value === 'inline' ) {
        this.$header.append( this.$help, this.$label );
        this.$body.append( this.$field, this.$header );
      } else {
        this.$header.append( this.$label );
        this.$body.append( this.$header, this.$help, this.$field );
      }
    }
    // Set classes. The following classes can be used here:
    // * oo-ui-fieldLayout-align-left
    // * oo-ui-fieldLayout-align-right
    // * oo-ui-fieldLayout-align-top
    // * oo-ui-fieldLayout-align-inline
    if ( this.align ) {
      this.$element.removeClass( 'oo-ui-fieldLayout-align-' + this.align );
    }
    this.$element.addClass( 'oo-ui-fieldLayout-align-' + value );
    this.align = value;
  }

  return this;
};

/**
 * Set the list of error messages.
 *
 * @param {Array} errors Error messages about the widget, which will be displayed below the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.FieldLayout.prototype.setErrors = function ( errors ) {
  this.errors = errors.slice();
  this.updateMessages();
  return this;
};

/**
 * Set the list of warning messages.
 *
 * @param {Array} warnings Warning messages about the widget, which will be displayed below
 *  the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.FieldLayout.prototype.setWarnings = function ( warnings ) {
  this.warnings = warnings.slice();
  this.updateMessages();
  return this;
};

/**
 * Set the list of success messages.
 *
 * @param {Array} successMessages Success messages about the widget, which will be displayed below
 *  the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.FieldLayout.prototype.setSuccess = function ( successMessages ) {
  this.successMessages = successMessages.slice();
  this.updateMessages();
  return this;
};

/**
 * Set the list of notice messages.
 *
 * @param {Array} notices Notices about the widget, which will be displayed below the widget.
 *  The array may contain strings or OO.ui.HtmlSnippet instances.
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.FieldLayout.prototype.setNotices = function ( notices ) {
  this.notices = notices.slice();
  this.updateMessages();
  return this;
};

/**
 * Update the rendering of error, warning, success and notice messages.
 *
 * @private
 */
OO.ui.FieldLayout.prototype.updateMessages = function () {
  var i;
  this.$messages.empty();

  if (
    this.errors.length ||
    this.warnings.length ||
    this.successMessages.length ||
    this.notices.length
  ) {
    this.$body.after( this.$messages );
  } else {
    this.$messages.remove();
    return;
  }

  for ( i = 0; i < this.errors.length; i++ ) {
    this.$messages.append( this.makeMessage( 'error', this.errors[ i ] ) );
  }
  for ( i = 0; i < this.warnings.length; i++ ) {
    this.$messages.append( this.makeMessage( 'warning', this.warnings[ i ] ) );
  }
  for ( i = 0; i < this.successMessages.length; i++ ) {
    this.$messages.append( this.makeMessage( 'success', this.successMessages[ i ] ) );
  }
  for ( i = 0; i < this.notices.length; i++ ) {
    this.$messages.append( this.makeMessage( 'notice', this.notices[ i ] ) );
  }
};

/**
 * Include information about the widget's accessKey in our title. TitledElement calls this method.
 * (This is a bit of a hack.)
 *
 * @protected
 * @param {string} title Tooltip label for 'title' attribute
 * @return {string}
 */
OO.ui.FieldLayout.prototype.formatTitleWithAccessKey = function ( title ) {
  if ( this.fieldWidget && this.fieldWidget.formatTitleWithAccessKey ) {
    return this.fieldWidget.formatTitleWithAccessKey( title );
  }
  return title;
};

/**
 * Creates and returns the help element. Also sets the `aria-describedby`
 * attribute on the main element of the `fieldWidget`.
 *
 * @private
 * @param {string|OO.ui.HtmlSnippet} [help] Help text.
 * @param {jQuery} [$overlay] Passed to OO.ui.PopupButtonWidget for help popup.
 * @return {jQuery} The element that should become `this.$help`.
 */
OO.ui.FieldLayout.prototype.createHelpElement = function ( help, $overlay ) {
  var helpId, helpWidget;

  if ( this.helpInline ) {
    helpWidget = new OO.ui.LabelWidget( {
      label: help,
      classes: [ 'oo-ui-inline-help' ]
    } );

    helpId = helpWidget.getElementId();
  } else {
    helpWidget = new OO.ui.PopupButtonWidget( {
      $overlay: $overlay,
      popup: {
        padded: true
      },
      classes: [ 'oo-ui-fieldLayout-help' ],
      framed: false,
      icon: 'info',
      label: OO.ui.msg( 'ooui-field-help' ),
      invisibleLabel: true
    } );

    helpWidget.popup.on( 'ready', function () {
      var $popupElement = helpWidget.popup.$element;
      $popupElement.attr( 'tabindex', 0 );
      $popupElement.trigger( 'focus' );
    } );

    helpWidget.popup.on( 'closing', function () {
      helpWidget.$button.trigger( 'focus' );
    } );

    if ( help instanceof OO.ui.HtmlSnippet ) {
      helpWidget.getPopup().$body.html( help.toString() );
    } else {
      helpWidget.getPopup().$body.text( help );
    }

    helpId = helpWidget.getPopup().getBodyId();
  }

  // Set the 'aria-describedby' attribute on the fieldWidget
  // Preference given to an input or a button
  (
    this.fieldWidget.$input ||
    this.fieldWidget.$button ||
    this.fieldWidget.$element
  ).attr( 'aria-describedby', helpId );

  return helpWidget.$element;
};

/**
 * ActionFieldLayouts are used with OO.ui.FieldsetLayout. The layout consists of a field-widget,
 * a button, and an optional label and/or help text. The field-widget (e.g., a
 * {@link OO.ui.TextInputWidget TextInputWidget}), is required and is specified before any optional
 * configuration settings.
 *
 * Labels can be aligned in one of four ways:
 *
 * - **left**: The label is placed before the field-widget and aligned with the left margin.
 *   A left-alignment is used for forms with many fields.
 * - **right**: The label is placed before the field-widget and aligned to the right margin.
 *   A right-alignment is used for long but familiar forms which users tab through,
 *   verifying the current field with a quick glance at the label.
 * - **top**: The label is placed above the field-widget. A top-alignment is used for brief forms
 *   that users fill out from top to bottom.
 * - **inline**: The label is placed after the field-widget and aligned to the left.
 *   An inline-alignment is best used with checkboxes or radio buttons.
 *
 * Help text is accessed via a help icon that appears in the upper right corner of the rendered
 * field layout when help text is specified.
 *
 *     @example
 *     // Example of an ActionFieldLayout
 *     var actionFieldLayout = new OO.ui.ActionFieldLayout(
 *         new OO.ui.TextInputWidget( {
 *             placeholder: 'Field widget'
 *         } ),
 *         new OO.ui.ButtonWidget( {
 *             label: 'Button'
 *         } ),
 *         {
 *             label: 'An ActionFieldLayout. This label is aligned top',
 *             align: 'top',
 *             help: 'This is help text'
 *         }
 *     );
 *
 *     $( document.body ).append( actionFieldLayout.$element );
 *
 * @class
 * @extends OO.ui.FieldLayout
 *
 * @constructor
 * @param {OO.ui.Widget} fieldWidget Field widget
 * @param {OO.ui.ButtonWidget} buttonWidget Button widget
 * @param {Object} config
 */
OO.ui.ActionFieldLayout = function OoUiActionFieldLayout( fieldWidget, buttonWidget, config ) {
  // Allow passing positional parameters inside the config object
  if ( OO.isPlainObject( fieldWidget ) && config === undefined ) {
    config = fieldWidget;
    fieldWidget = config.fieldWidget;
    buttonWidget = config.buttonWidget;
  }

  // Parent constructor
  OO.ui.ActionFieldLayout.super.call( this, fieldWidget, config );

  // Properties
  this.buttonWidget = buttonWidget;
  this.$button = $( '<span>' );
  this.$input = this.isFieldInline() ? $( '<span>' ) : $( '<div>' );

  // Initialization
  this.$element.addClass( 'oo-ui-actionFieldLayout' );
  this.$button
    .addClass( 'oo-ui-actionFieldLayout-button' )
    .append( this.buttonWidget.$element );
  this.$input
    .addClass( 'oo-ui-actionFieldLayout-input' )
    .append( this.fieldWidget.$element );
  this.$field.append( this.$input, this.$button );
};

/* Setup */

OO.inheritClass( OO.ui.ActionFieldLayout, OO.ui.FieldLayout );

/**
 * FieldsetLayouts are composed of one or more {@link OO.ui.FieldLayout FieldLayouts},
 * which each contain an individual widget and, optionally, a label. Each Fieldset can be
 * configured with a label as well. For more information and examples,
 * please see the [OOUI documentation on MediaWiki][1].
 *
 *     @example
 *     // Example of a fieldset layout
 *     var input1 = new OO.ui.TextInputWidget( {
 *         placeholder: 'A text input field'
 *     } );
 *
 *     var input2 = new OO.ui.TextInputWidget( {
 *         placeholder: 'A text input field'
 *     } );
 *
 *     var fieldset = new OO.ui.FieldsetLayout( {
 *         label: 'Example of a fieldset layout'
 *     } );
 *
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( input1, {
 *             label: 'Field One'
 *         } ),
 *         new OO.ui.FieldLayout( input2, {
 *             label: 'Field Two'
 *         } )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Layouts/Fields_and_Fieldsets
 *
 * @class
 * @extends OO.ui.Layout
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.FieldLayout[]} [items] An array of fields to add to the fieldset.
 *  See OO.ui.FieldLayout for more information about fields.
 * @cfg {string|OO.ui.HtmlSnippet} [help] Help text. When help text is specified
 *  and `helpInline` is `false`, a "help" icon will appear in the upper-right
 *  corner of the rendered field; clicking it will display the text in a popup.
 *  If `helpInline` is `true`, then a subtle description will be shown after the
 *  label.
 *  For feedback messages, you are advised to use `notices`.
 * @cfg {boolean} [helpInline=false] Whether or not the help should be inline,
 *  or shown when the "help" icon is clicked.
 * @cfg {jQuery} [$overlay] Passed to OO.ui.PopupButtonWidget for help popup, if `help` is given.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.FieldsetLayout = function OoUiFieldsetLayout( config ) {
  var helpWidget;

  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.FieldsetLayout.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.GroupElement.call( this, config );

  // Properties
  this.$header = $( '<legend>' );

  // Initialization
  this.$header
    .addClass( 'oo-ui-fieldsetLayout-header' )
    .append( this.$icon, this.$label );
  this.$group.addClass( 'oo-ui-fieldsetLayout-group' );
  this.$element
    .addClass( 'oo-ui-fieldsetLayout' )
    .prepend( this.$header, this.$group );

  // Help
  if ( config.help ) {
    if ( config.helpInline ) {
      helpWidget = new OO.ui.LabelWidget( {
        label: config.help,
        classes: [ 'oo-ui-inline-help' ]
      } );
      this.$element.prepend( this.$header, helpWidget.$element, this.$group );
    } else {
      helpWidget = new OO.ui.PopupButtonWidget( {
        $overlay: config.$overlay,
        popup: {
          padded: true
        },
        classes: [ 'oo-ui-fieldsetLayout-help' ],
        framed: false,
        icon: 'info',
        label: OO.ui.msg( 'ooui-field-help' ),
        invisibleLabel: true
      } );
      if ( config.help instanceof OO.ui.HtmlSnippet ) {
        helpWidget.getPopup().$body.html( config.help.toString() );
      } else {
        helpWidget.getPopup().$body.text( config.help );
      }
      this.$header.append( helpWidget.$element );
    }
  }
  if ( Array.isArray( config.items ) ) {
    this.addItems( config.items );
  }
};

/* Setup */

OO.inheritClass( OO.ui.FieldsetLayout, OO.ui.Layout );
OO.mixinClass( OO.ui.FieldsetLayout, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.FieldsetLayout, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.FieldsetLayout, OO.ui.mixin.GroupElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.FieldsetLayout.static.tagName = 'fieldset';

/**
 * FormLayouts are used to wrap {@link OO.ui.FieldsetLayout FieldsetLayouts} when you intend to use
 * browser-based form submission for the fields instead of handling them in JavaScript. Form layouts
 * can be configured with an HTML form action, an encoding type, and a method using the #action,
 * #enctype, and #method configs, respectively.
 * See the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * Only widgets from the {@link OO.ui.InputWidget InputWidget} family support form submission. It
 * includes standard form elements like {@link OO.ui.CheckboxInputWidget checkboxes}, {@link
 * OO.ui.RadioInputWidget radio buttons} and {@link OO.ui.TextInputWidget text fields}, as well as
 * some fancier controls. Some controls have both regular and InputWidget variants, for example
 * OO.ui.DropdownWidget and OO.ui.DropdownInputWidget – only the latter support form submission and
 * often have simplified APIs to match the capabilities of HTML forms.
 * See the [OOUI documentation on MediaWiki] [2] for more information about InputWidgets.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Layouts/Forms
 * [2]: https://www.mediawiki.org/wiki/OOUI/Widgets/Inputs
 *
 *     @example
 *     // Example of a form layout that wraps a fieldset layout.
 *     var input1 = new OO.ui.TextInputWidget( {
 *             placeholder: 'Username'
 *         } ),
 *         input2 = new OO.ui.TextInputWidget( {
 *             placeholder: 'Password',
 *             type: 'password'
 *         } ),
 *         submit = new OO.ui.ButtonInputWidget( {
 *             label: 'Submit'
 *         } ),
 *         fieldset = new OO.ui.FieldsetLayout( {
 *             label: 'A form layout'
 *         } );
 *
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( input1, {
 *             label: 'Username',
 *             align: 'top'
 *         } ),
 *         new OO.ui.FieldLayout( input2, {
 *             label: 'Password',
 *             align: 'top'
 *         } ),
 *         new OO.ui.FieldLayout( submit )
 *     ] );
 *     var form = new OO.ui.FormLayout( {
 *         items: [ fieldset ],
 *         action: '/api/formhandler',
 *         method: 'get'
 *     } )
 *     $( document.body ).append( form.$element );
 *
 * @class
 * @extends OO.ui.Layout
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [method] HTML form `method` attribute
 * @cfg {string} [action] HTML form `action` attribute
 * @cfg {string} [enctype] HTML form `enctype` attribute
 * @cfg {OO.ui.FieldsetLayout[]} [items] Fieldset layouts to add to the form layout.
 */
OO.ui.FormLayout = function OoUiFormLayout( config ) {
  var action;

  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.FormLayout.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.GroupElement.call( this, $.extend( { $group: this.$element }, config ) );

  // Events
  this.$element.on( 'submit', this.onFormSubmit.bind( this ) );

  // Make sure the action is safe
  action = config.action;
  if ( action !== undefined && !OO.ui.isSafeUrl( action ) ) {
    action = './' + action;
  }

  // Initialization
  this.$element
    .addClass( 'oo-ui-formLayout' )
    .attr( {
      method: config.method,
      action: action,
      enctype: config.enctype
    } );
  if ( Array.isArray( config.items ) ) {
    this.addItems( config.items );
  }
};

/* Setup */

OO.inheritClass( OO.ui.FormLayout, OO.ui.Layout );
OO.mixinClass( OO.ui.FormLayout, OO.ui.mixin.GroupElement );

/* Events */

/**
 * A 'submit' event is emitted when the form is submitted.
 *
 * @event submit
 */

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.FormLayout.static.tagName = 'form';

/* Methods */

/**
 * Handle form submit events.
 *
 * @private
 * @param {jQuery.Event} e Submit event
 * @fires submit
 * @return {OO.ui.FormLayout} The layout, for chaining
 */
OO.ui.FormLayout.prototype.onFormSubmit = function () {
  if ( this.emit( 'submit' ) ) {
    return false;
  }
};

/**
 * PanelLayouts expand to cover the entire area of their parent. They can be configured with
 * scrolling, padding, and a frame, and are often used together with
 * {@link OO.ui.StackLayout StackLayouts}.
 *
 *     @example
 *     // Example of a panel layout
 *     var panel = new OO.ui.PanelLayout( {
 *         expanded: false,
 *         framed: true,
 *         padded: true,
 *         $content: $( '<p>A panel layout with padding and a frame.</p>' )
 *     } );
 *     $( document.body ).append( panel.$element );
 *
 * @class
 * @extends OO.ui.Layout
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [scrollable=false] Allow vertical scrolling
 * @cfg {boolean} [padded=false] Add padding between the content and the edges of the panel.
 * @cfg {boolean} [expanded=true] Expand the panel to fill the entire parent element.
 * @cfg {boolean} [framed=false] Render the panel with a frame to visually separate it from outside
 *  content.
 */
OO.ui.PanelLayout = function OoUiPanelLayout( config ) {
  // Configuration initialization
  config = $.extend( {
    scrollable: false,
    padded: false,
    expanded: true,
    framed: false
  }, config );

  // Parent constructor
  OO.ui.PanelLayout.super.call( this, config );

  // Initialization
  this.$element.addClass( 'oo-ui-panelLayout' );
  if ( config.scrollable ) {
    this.$element.addClass( 'oo-ui-panelLayout-scrollable' );
  }
  if ( config.padded ) {
    this.$element.addClass( 'oo-ui-panelLayout-padded' );
  }
  if ( config.expanded ) {
    this.$element.addClass( 'oo-ui-panelLayout-expanded' );
  }
  if ( config.framed ) {
    this.$element.addClass( 'oo-ui-panelLayout-framed' );
  }
};

/* Setup */

OO.inheritClass( OO.ui.PanelLayout, OO.ui.Layout );

/* Static Methods */

/**
 * @inheritdoc
 */
OO.ui.PanelLayout.static.reusePreInfuseDOM = function ( node, config ) {
  config = OO.ui.PanelLayout.super.static.reusePreInfuseDOM( node, config );
  if ( config.preserveContent !== false ) {
    config.$content = $( node ).contents();
  }
  return config;
};

/* Methods */

/**
 * Focus the panel layout
 *
 * The default implementation just focuses the first focusable element in the panel
 */
OO.ui.PanelLayout.prototype.focus = function () {
  OO.ui.findFocusable( this.$element ).focus();
};

/**
 * HorizontalLayout arranges its contents in a single line (using `display: inline-block` for its
 * items), with small margins between them. Convenient when you need to put a number of block-level
 * widgets on a single line next to each other.
 *
 * Note that inline elements, such as OO.ui.ButtonWidgets, do not need this wrapper.
 *
 *     @example
 *     // HorizontalLayout with a text input and a label.
 *     var layout = new OO.ui.HorizontalLayout( {
 *       items: [
 *         new OO.ui.LabelWidget( { label: 'Label' } ),
 *         new OO.ui.TextInputWidget( { value: 'Text' } )
 *       ]
 *     } );
 *     $( document.body ).append( layout.$element );
 *
 * @class
 * @extends OO.ui.Layout
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.Widget[]|OO.ui.Layout[]} [items] Widgets or other layouts to add to the layout.
 */
OO.ui.HorizontalLayout = function OoUiHorizontalLayout( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.HorizontalLayout.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.GroupElement.call( this, $.extend( { $group: this.$element }, config ) );

  // Initialization
  this.$element.addClass( 'oo-ui-horizontalLayout' );
  if ( Array.isArray( config.items ) ) {
    this.addItems( config.items );
  }
};

/* Setup */

OO.inheritClass( OO.ui.HorizontalLayout, OO.ui.Layout );
OO.mixinClass( OO.ui.HorizontalLayout, OO.ui.mixin.GroupElement );

/**
 * NumberInputWidgets combine a {@link OO.ui.TextInputWidget text input} (where a value
 * can be entered manually) and two {@link OO.ui.ButtonWidget button widgets}
 * (to adjust the value in increments) to allow the user to enter a number.
 *
 *     @example
 *     // A NumberInputWidget.
 *     var numberInput = new OO.ui.NumberInputWidget( {
 *         label: 'NumberInputWidget',
 *         input: { value: 5 },
 *         min: 1,
 *         max: 10
 *     } );
 *     $( document.body ).append( numberInput.$element );
 *
 * @class
 * @extends OO.ui.TextInputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {Object} [minusButton] Configuration options to pass to the
 *  {@link OO.ui.ButtonWidget decrementing button widget}.
 * @cfg {Object} [plusButton] Configuration options to pass to the
 *  {@link OO.ui.ButtonWidget incrementing button widget}.
 * @cfg {number} [min=-Infinity] Minimum allowed value
 * @cfg {number} [max=Infinity] Maximum allowed value
 * @cfg {number|null} [step] If specified, the field only accepts values that are multiples of this.
 * @cfg {number} [buttonStep=step||1] Delta when using the buttons or Up/Down arrow keys.
 *  Defaults to `step` if specified, otherwise `1`.
 * @cfg {number} [pageStep=10*buttonStep] Delta when using the Page-up/Page-down keys.
 *  Defaults to 10 times `buttonStep`.
 * @cfg {boolean} [showButtons=true] Whether to show the plus and minus buttons.
 */
OO.ui.NumberInputWidget = function OoUiNumberInputWidget( config ) {
  var $field = $( '<div>' ).addClass( 'oo-ui-numberInputWidget-field' );

  // Configuration initialization
  config = $.extend( {
    min: -Infinity,
    max: Infinity,
    showButtons: true
  }, config );

  // For backward compatibility
  $.extend( config, config.input );
  this.input = this;

  // Parent constructor
  OO.ui.NumberInputWidget.super.call( this, $.extend( config, {
    type: 'number'
  } ) );

  if ( config.showButtons ) {
    this.minusButton = new OO.ui.ButtonWidget( $.extend(
      {
        disabled: this.isDisabled(),
        tabIndex: -1,
        classes: [ 'oo-ui-numberInputWidget-minusButton' ],
        icon: 'subtract'
      },
      config.minusButton
    ) );
    this.minusButton.$element.attr( 'aria-hidden', 'true' );
    this.plusButton = new OO.ui.ButtonWidget( $.extend(
      {
        disabled: this.isDisabled(),
        tabIndex: -1,
        classes: [ 'oo-ui-numberInputWidget-plusButton' ],
        icon: 'add'
      },
      config.plusButton
    ) );
    this.plusButton.$element.attr( 'aria-hidden', 'true' );
  }

  // Events
  this.$input.on( {
    keydown: this.onKeyDown.bind( this ),
    'wheel mousewheel DOMMouseScroll': this.onWheel.bind( this )
  } );
  if ( config.showButtons ) {
    this.plusButton.connect( this, {
      click: [ 'onButtonClick', +1 ]
    } );
    this.minusButton.connect( this, {
      click: [ 'onButtonClick', -1 ]
    } );
  }

  // Build the field
  $field.append( this.$input );
  if ( config.showButtons ) {
    $field
      .prepend( this.minusButton.$element )
      .append( this.plusButton.$element );
  }

  // Initialization
  if ( config.allowInteger || config.isInteger ) {
    // Backward compatibility
    config.step = 1;
  }
  this.setRange( config.min, config.max );
  this.setStep( config.buttonStep, config.pageStep, config.step );
  // Set the validation method after we set step and range
  // so that it doesn't immediately call setValidityFlag
  this.setValidation( this.validateNumber.bind( this ) );

  this.$element
    .addClass( 'oo-ui-numberInputWidget' )
    .toggleClass( 'oo-ui-numberInputWidget-buttoned', config.showButtons )
    .append( $field );
};

/* Setup */

OO.inheritClass( OO.ui.NumberInputWidget, OO.ui.TextInputWidget );

/* Methods */

// Backward compatibility
OO.ui.NumberInputWidget.prototype.setAllowInteger = function ( flag ) {
  this.setStep( flag ? 1 : null );
};
// Backward compatibility
OO.ui.NumberInputWidget.prototype.setIsInteger = OO.ui.NumberInputWidget.prototype.setAllowInteger;

// Backward compatibility
OO.ui.NumberInputWidget.prototype.getAllowInteger = function () {
  return this.step === 1;
};
// Backward compatibility
OO.ui.NumberInputWidget.prototype.getIsInteger = OO.ui.NumberInputWidget.prototype.getAllowInteger;

/**
 * Set the range of allowed values
 *
 * @param {number} min Minimum allowed value
 * @param {number} max Maximum allowed value
 */
OO.ui.NumberInputWidget.prototype.setRange = function ( min, max ) {
  if ( min > max ) {
    throw new Error( 'Minimum (' + min + ') must not be greater than maximum (' + max + ')' );
  }
  this.min = min;
  this.max = max;
  this.$input.attr( 'min', this.min );
  this.$input.attr( 'max', this.max );
  this.setValidityFlag();
};

/**
 * Get the current range
 *
 * @return {number[]} Minimum and maximum values
 */
OO.ui.NumberInputWidget.prototype.getRange = function () {
  return [ this.min, this.max ];
};

/**
 * Set the stepping deltas
 *
 * @param {number} [buttonStep=step||1] Delta when using the buttons or up/down arrow keys.
 *  Defaults to `step` if specified, otherwise `1`.
 * @param {number} [pageStep=10*buttonStep] Delta when using the page-up/page-down keys.
 *  Defaults to 10 times `buttonStep`.
 * @param {number|null} [step] If specified, the field only accepts values that are multiples
 *  of this.
 */
OO.ui.NumberInputWidget.prototype.setStep = function ( buttonStep, pageStep, step ) {
  if ( buttonStep === undefined ) {
    buttonStep = step || 1;
  }
  if ( pageStep === undefined ) {
    pageStep = 10 * buttonStep;
  }
  if ( step !== null && step <= 0 ) {
    throw new Error( 'Step value, if given, must be positive' );
  }
  if ( buttonStep <= 0 ) {
    throw new Error( 'Button step value must be positive' );
  }
  if ( pageStep <= 0 ) {
    throw new Error( 'Page step value must be positive' );
  }
  this.step = step;
  this.buttonStep = buttonStep;
  this.pageStep = pageStep;
  this.$input.attr( 'step', this.step || 'any' );
  this.setValidityFlag();
};

/**
 * @inheritdoc
 */
OO.ui.NumberInputWidget.prototype.setValue = function ( value ) {
  if ( value === '' ) {
    // Some browsers allow a value in the input even if there isn't one reported by $input.val()
    // so here we make sure an 'empty' value is actually displayed as such.
    this.$input.val( '' );
  }
  return OO.ui.NumberInputWidget.super.prototype.setValue.call( this, value );
};

/**
 * Get the current stepping values
 *
 * @return {number[]} Button step, page step, and validity step
 */
OO.ui.NumberInputWidget.prototype.getStep = function () {
  return [ this.buttonStep, this.pageStep, this.step ];
};

/**
 * Get the current value of the widget as a number
 *
 * @return {number} May be NaN, or an invalid number
 */
OO.ui.NumberInputWidget.prototype.getNumericValue = function () {
  return +this.getValue();
};

/**
 * Adjust the value of the widget
 *
 * @param {number} delta Adjustment amount
 */
OO.ui.NumberInputWidget.prototype.adjustValue = function ( delta ) {
  var n, v = this.getNumericValue();

  delta = +delta;
  if ( isNaN( delta ) || !isFinite( delta ) ) {
    throw new Error( 'Delta must be a finite number' );
  }

  if ( isNaN( v ) ) {
    n = 0;
  } else {
    n = v + delta;
    n = Math.max( Math.min( n, this.max ), this.min );
    if ( this.step ) {
      n = Math.round( n / this.step ) * this.step;
    }
  }

  if ( n !== v ) {
    this.setValue( n );
  }
};
/**
 * Validate input
 *
 * @private
 * @param {string} value Field value
 * @return {boolean}
 */
OO.ui.NumberInputWidget.prototype.validateNumber = function ( value ) {
  var n = +value;
  if ( value === '' ) {
    return !this.isRequired();
  }

  if ( isNaN( n ) || !isFinite( n ) ) {
    return false;
  }

  if ( this.step && Math.floor( n / this.step ) !== n / this.step ) {
    return false;
  }

  if ( n < this.min || n > this.max ) {
    return false;
  }

  return true;
};

/**
 * Handle mouse click events.
 *
 * @private
 * @param {number} dir +1 or -1
 */
OO.ui.NumberInputWidget.prototype.onButtonClick = function ( dir ) {
  this.adjustValue( dir * this.buttonStep );
};

/**
 * Handle mouse wheel events.
 *
 * @private
 * @param {jQuery.Event} event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.NumberInputWidget.prototype.onWheel = function ( event ) {
  var delta = 0;

  if ( this.isDisabled() || this.isReadOnly() ) {
    return;
  }

  if ( this.$input.is( ':focus' ) ) {
    // Standard 'wheel' event
    if ( event.originalEvent.deltaMode !== undefined ) {
      this.sawWheelEvent = true;
    }
    if ( event.originalEvent.deltaY ) {
      delta = -event.originalEvent.deltaY;
    } else if ( event.originalEvent.deltaX ) {
      delta = event.originalEvent.deltaX;
    }

    // Non-standard events
    if ( !this.sawWheelEvent ) {
      if ( event.originalEvent.wheelDeltaX ) {
        delta = -event.originalEvent.wheelDeltaX;
      } else if ( event.originalEvent.wheelDeltaY ) {
        delta = event.originalEvent.wheelDeltaY;
      } else if ( event.originalEvent.wheelDelta ) {
        delta = event.originalEvent.wheelDelta;
      } else if ( event.originalEvent.detail ) {
        delta = -event.originalEvent.detail;
      }
    }

    if ( delta ) {
      delta = delta < 0 ? -1 : 1;
      this.adjustValue( delta * this.buttonStep );
    }

    return false;
  }
};

/**
 * Handle key down events.
 *
 * @private
 * @param {jQuery.Event} e Key down event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.NumberInputWidget.prototype.onKeyDown = function ( e ) {
  if ( this.isDisabled() || this.isReadOnly() ) {
    return;
  }

  switch ( e.which ) {
    case OO.ui.Keys.UP:
      this.adjustValue( this.buttonStep );
      return false;
    case OO.ui.Keys.DOWN:
      this.adjustValue( -this.buttonStep );
      return false;
    case OO.ui.Keys.PAGEUP:
      this.adjustValue( this.pageStep );
      return false;
    case OO.ui.Keys.PAGEDOWN:
      this.adjustValue( -this.pageStep );
      return false;
  }
};

/**
 * Update the disabled state of the controls
 *
 * @chainable
 * @protected
 * @return {OO.ui.NumberInputWidget} The widget, for chaining
 */
OO.ui.NumberInputWidget.prototype.updateControlsDisabled = function () {
  var disabled = this.isDisabled() || this.isReadOnly();
  if ( this.minusButton ) {
    this.minusButton.setDisabled( disabled );
  }
  if ( this.plusButton ) {
    this.plusButton.setDisabled( disabled );
  }
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.NumberInputWidget.prototype.setDisabled = function ( disabled ) {
  // Parent method
  OO.ui.NumberInputWidget.super.prototype.setDisabled.call( this, disabled );
  this.updateControlsDisabled();
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.NumberInputWidget.prototype.setReadOnly = function () {
  // Parent method
  OO.ui.NumberInputWidget.super.prototype.setReadOnly.apply( this, arguments );
  this.updateControlsDisabled();
  return this;
};

/**
 * SelectFileInputWidgets allow for selecting files, using <input type="file">. These
 * widgets can be configured with {@link OO.ui.mixin.IconElement icons}, {@link
 * OO.ui.mixin.IndicatorElement indicators} and {@link OO.ui.mixin.TitledElement titles}.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * SelectFileInputWidgets must be used in HTML forms, as getValue only returns the filename.
 *
 *     @example
 *     // A file select input widget.
 *     var selectFile = new OO.ui.SelectFileInputWidget();
 *     $( document.body ).append( selectFile.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets
 *
 * @class
 * @extends OO.ui.InputWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string[]|null} [accept=null] MIME types to accept. null accepts all types.
 * @cfg {boolean} [multiple=false] Allow multiple files to be selected.
 * @cfg {string} [placeholder] Text to display when no file is selected.
 * @cfg {Object} [button] Config to pass to select file button.
 * @cfg {string} [icon] Icon to show next to file info
 */
OO.ui.SelectFileInputWidget = function OoUiSelectFileInputWidget( config ) {
  var widget = this;

  config = config || {};

  // Construct buttons before parent method is called (calling setDisabled)
  this.selectButton = new OO.ui.ButtonWidget( $.extend( {
    $element: $( '<label>' ),
    classes: [ 'oo-ui-selectFileInputWidget-selectButton' ],
    label: OO.ui.msg( 'ooui-selectfile-button-select' )
  }, config.button ) );

  // Configuration initialization
  config = $.extend( {
    accept: null,
    placeholder: OO.ui.msg( 'ooui-selectfile-placeholder' ),
    $tabIndexed: this.selectButton.$tabIndexed
  }, config );

  this.info = new OO.ui.SearchInputWidget( {
    classes: [ 'oo-ui-selectFileInputWidget-info' ],
    placeholder: config.placeholder,
    // Pass an empty collection so that .focus() always does nothing
    $tabIndexed: $( [] )
  } ).setIcon( config.icon );
  // Set tabindex manually on $input as $tabIndexed has been overridden
  this.info.$input.attr( 'tabindex', -1 );
  // This indicator serves as the only way to clear the file, so it must be keyboard-accessible
  this.info.$indicator.attr( 'tabindex', 0 );

  // Parent constructor
  OO.ui.SelectFileInputWidget.super.call( this, config );

  // Properties
  this.currentFiles = this.filterFiles( this.$input[ 0 ].files || [] );
  if ( Array.isArray( config.accept ) ) {
    this.accept = config.accept;
  } else {
    this.accept = null;
  }
  this.multiple = !!config.multiple;

  // Events
  this.info.connect( this, { change: 'onInfoChange' } );
  this.selectButton.$button.on( {
    keypress: this.onKeyPress.bind( this )
  } );
  this.$input.on( {
    change: this.onFileSelected.bind( this ),
    // Support: IE11
    // In IE 11, focussing a file input (by clicking on it) displays a text cursor and scrolls
    // the cursor into view (in this case, it scrolls the button, which has 'overflow: hidden').
    // Since this messes with our custom styling (the file input has large dimensions and this
    // causes the label to scroll out of view), scroll the button back to top. (T192131)
    focus: function () {
      widget.$input.parent().prop( 'scrollTop', 0 );
    }
  } );
  this.connect( this, { change: 'updateUI' } );

  this.fieldLayout = new OO.ui.ActionFieldLayout( this.info, this.selectButton, { align: 'top' } );

  this.$input
    .attr( {
      type: 'file',
      // this.selectButton is tabindexed
      tabindex: -1,
      // Infused input may have previously by
      // TabIndexed, so remove aria-disabled attr.
      'aria-disabled': null
    } );

  if ( this.accept ) {
    this.$input.attr( 'accept', this.accept.join( ', ' ) );
  }
  if ( this.multiple ) {
    this.$input.attr( 'multiple', '' );
  }
  this.selectButton.$button.append( this.$input );

  this.$element
    .addClass( 'oo-ui-selectFileInputWidget' )
    .append( this.fieldLayout.$element );

  this.updateUI();
};

/* Setup */

OO.inheritClass( OO.ui.SelectFileInputWidget, OO.ui.InputWidget );

/* Static properties */

// Set empty title so that browser default tooltips like "No file chosen" don't appear.
// On SelectFileWidget this tooltip will often be incorrect, so create a consistent
// experience on SelectFileInputWidget.
OO.ui.SelectFileInputWidget.static.title = '';

/* Methods */

/**
 * Get the filename of the currently selected file.
 *
 * @return {string} Filename
 */
OO.ui.SelectFileInputWidget.prototype.getFilename = function () {
  if ( this.currentFiles.length ) {
    return this.currentFiles.map( function ( file ) {
      return file.name;
    } ).join( ', ' );
  } else {
    // Try to strip leading fakepath.
    return this.getValue().split( '\\' ).pop();
  }
};

/**
 * @inheritdoc
 */
OO.ui.SelectFileInputWidget.prototype.setValue = function ( value ) {
  if ( value === undefined ) {
    // Called during init, don't replace value if just infusing.
    return;
  }
  if ( value ) {
    // We need to update this.value, but without trying to modify
    // the DOM value, which would throw an exception.
    if ( this.value !== value ) {
      this.value = value;
      this.emit( 'change', this.value );
    }
  } else {
    this.currentFiles = [];
    // Parent method
    OO.ui.SelectFileInputWidget.super.prototype.setValue.call( this, '' );
  }
};

/**
 * Handle file selection from the input.
 *
 * @protected
 * @param {jQuery.Event} e
 */
OO.ui.SelectFileInputWidget.prototype.onFileSelected = function ( e ) {
  this.currentFiles = this.filterFiles( e.target.files || [] );
};

/**
 * Update the user interface when a file is selected or unselected.
 *
 * @protected
 */
OO.ui.SelectFileInputWidget.prototype.updateUI = function () {
  this.info.setValue( this.getFilename() );
};

/**
 * Determine if we should accept this file.
 *
 * @private
 * @param {FileList|File[]} files Files to filter
 * @return {File[]} Filter files
 */
OO.ui.SelectFileInputWidget.prototype.filterFiles = function ( files ) {
  var accept = this.accept;

  function mimeAllowed( file ) {
    var i, mimeTest,
      mimeType = file.type;

    if ( !accept || !mimeType ) {
      return true;
    }

    for ( i = 0; i < accept.length; i++ ) {
      mimeTest = accept[ i ];
      if ( mimeTest === mimeType ) {
        return true;
      } else if ( mimeTest.substr( -2 ) === '/*' ) {
        mimeTest = mimeTest.substr( 0, mimeTest.length - 1 );
        if ( mimeType.substr( 0, mimeTest.length ) === mimeTest ) {
          return true;
        }
      }
    }
    return false;
  }

  return Array.prototype.filter.call( files, mimeAllowed );
};

/**
 * Handle info input change events
 *
 * The info widget can only be changed by the user
 * with the clear button.
 *
 * @private
 * @param {string} value
 */
OO.ui.SelectFileInputWidget.prototype.onInfoChange = function ( value ) {
  if ( value === '' ) {
    this.setValue( null );
  }
};

/**
 * Handle key press events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.SelectFileInputWidget.prototype.onKeyPress = function ( e ) {
  if ( !this.isDisabled() && this.$input &&
    ( e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER )
  ) {
    // Emit a click to open the file selector.
    this.$input.trigger( 'click' );
    // Taking focus from the selectButton means keyUp isn't fired, so fire it manually.
    this.selectButton.onDocumentKeyUp( e );
    return false;
  }
};

/**
 * @inheritdoc
 */
OO.ui.SelectFileInputWidget.prototype.setDisabled = function ( disabled ) {
  // Parent method
  OO.ui.SelectFileInputWidget.super.prototype.setDisabled.call( this, disabled );

  this.selectButton.setDisabled( disabled );
  this.info.setDisabled( disabled );

  return this;
};

}( OO ) );

//# sourceMappingURL=oojs-ui-core.js.map.json
/*!
 * OOUI v0.40.0
 * https://www.mediawiki.org/wiki/OOUI
 *
 * Copyright 2011–2020 OOUI Team and other contributors.
 * Released under the MIT license
 * http://oojs.mit-license.org
 *
 * Date: 2020-08-03T17:53:06Z
 */
( function ( OO ) {

'use strict';

/**
 * DraggableElement is a mixin class used to create elements that can be clicked
 * and dragged by a mouse to a new position within a group. This class must be used
 * in conjunction with OO.ui.mixin.DraggableGroupElement, which provides a container for
 * the draggable elements.
 *
 * @abstract
 * @class
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$handle] The part of the element which can be used for dragging, defaults to
 *  the whole element
 * @cfg {boolean} [draggable] The items are draggable. This can change with #toggleDraggable
 *  but the draggable state should be called from the DraggableGroupElement, which updates
 *  the whole group
 */
OO.ui.mixin.DraggableElement = function OoUiMixinDraggableElement( config ) {
  config = config || {};

  // Properties
  this.index = null;
  this.$handle = config.$handle || this.$element;
  this.wasHandleUsed = null;

  // Initialize and events
  this.$element
    .addClass( 'oo-ui-draggableElement' )
    .on( {
      mousedown: this.onDragMouseDown.bind( this ),
      dragstart: this.onDragStart.bind( this ),
      dragover: this.onDragOver.bind( this ),
      dragend: this.onDragEnd.bind( this ),
      drop: this.onDrop.bind( this )
    } );
  this.$handle.addClass( 'oo-ui-draggableElement-handle' );
  this.toggleDraggable( config.draggable === undefined ? true : !!config.draggable );
};

OO.initClass( OO.ui.mixin.DraggableElement );

/* Events */

/**
 * @event dragstart
 *
 * A dragstart event is emitted when the user clicks and begins dragging an item.
 * @param {OO.ui.mixin.DraggableElement} item The item the user has clicked and is dragging with
 *  the mouse.
 */

/**
 * @event dragend
 * A dragend event is emitted when the user drags an item and releases the mouse,
 * thus terminating the drag operation.
 */

/**
 * @event drop
 * A drop event is emitted when the user drags an item and then releases the mouse button
 * over a valid target.
 */

/* Static Properties */

/**
 * @inheritdoc OO.ui.mixin.ButtonElement
 */
OO.ui.mixin.DraggableElement.static.cancelButtonMouseDownEvents = false;

/* Methods */

/**
 * Change the draggable state of this widget.
 * This allows users to temporarily halt the dragging operations.
 *
 * @param {boolean} isDraggable Widget supports draggable operations
 * @fires draggable
 */
OO.ui.mixin.DraggableElement.prototype.toggleDraggable = function ( isDraggable ) {
  isDraggable = isDraggable !== undefined ? !!isDraggable : !this.draggable;

  if ( this.draggable !== isDraggable ) {
    this.draggable = isDraggable;

    this.$handle.toggleClass( 'oo-ui-draggableElement-undraggable', !this.draggable );

    // We make the entire element draggable, not just the handle, so that
    // the whole element appears to move. wasHandleUsed prevents drags from
    // starting outside the handle
    this.$element.prop( 'draggable', this.draggable );
  }
};

/**
 * Check the draggable state of this widget.
 *
 * @return {boolean} Widget supports draggable operations
 */
OO.ui.mixin.DraggableElement.prototype.isDraggable = function () {
  return this.draggable;
};

/**
 * Respond to mousedown event.
 *
 * @private
 * @param {jQuery.Event} e Drag event
 */
OO.ui.mixin.DraggableElement.prototype.onDragMouseDown = function ( e ) {
  if ( !this.isDraggable() ) {
    return;
  }

  this.wasHandleUsed =
    // Optimization: if the handle is the whole element this is always true
    this.$handle[ 0 ] === this.$element[ 0 ] ||
    // Check the mousedown occurred inside the handle
    OO.ui.contains( this.$handle[ 0 ], e.target, true );
};

/**
 * Respond to dragstart event.
 *
 * @private
 * @param {jQuery.Event} e Drag event
 * @return {boolean} False if the event is cancelled
 * @fires dragstart
 */
OO.ui.mixin.DraggableElement.prototype.onDragStart = function ( e ) {
  var element = this,
    dataTransfer = e.originalEvent.dataTransfer;

  if ( !this.wasHandleUsed || !this.isDraggable() ) {
    return false;
  }

  // Define drop effect
  dataTransfer.dropEffect = 'none';
  dataTransfer.effectAllowed = 'move';
  // Support: Firefox
  // We must set up a dataTransfer data property or Firefox seems to
  // ignore the fact the element is draggable.
  try {
    dataTransfer.setData( 'application-x/OOUI-draggable', this.getIndex() );
  } catch ( err ) {
    // The above is only for Firefox. Move on if it fails.
  }
  // Briefly add a 'clone' class to style the browser's native drag image
  this.$element.addClass( 'oo-ui-draggableElement-clone' );
  // Add placeholder class after the browser has rendered the clone
  setTimeout( function () {
    element.$element
      .removeClass( 'oo-ui-draggableElement-clone' )
      .addClass( 'oo-ui-draggableElement-placeholder' );
  } );
  // Emit event
  this.emit( 'dragstart', this );
  return true;
};

/**
 * Respond to dragend event.
 *
 * @private
 * @fires dragend
 */
OO.ui.mixin.DraggableElement.prototype.onDragEnd = function () {
  this.$element.removeClass( 'oo-ui-draggableElement-placeholder' );
  this.emit( 'dragend' );
};

/**
 * Handle drop event.
 *
 * @private
 * @param {jQuery.Event} e Drop event
 * @fires drop
 */
OO.ui.mixin.DraggableElement.prototype.onDrop = function ( e ) {
  e.preventDefault();
  this.emit( 'drop', e );
};

/**
 * In order for drag/drop to work, the dragover event must
 * return false and stop propogation.
 *
 * @param {jQuery.Event} e Drag event
 * @private
 */
OO.ui.mixin.DraggableElement.prototype.onDragOver = function ( e ) {
  e.preventDefault();
};

/**
 * Set item index.
 * Store it in the DOM so we can access from the widget drag event.
 *
 * @private
 * @param {number} index Item index
 */
OO.ui.mixin.DraggableElement.prototype.setIndex = function ( index ) {
  if ( this.index !== index ) {
    this.index = index;
    this.$element.data( 'index', index );
  }
};

/**
 * Get item index.
 *
 * @private
 * @return {number} Item index
 */
OO.ui.mixin.DraggableElement.prototype.getIndex = function () {
  return this.index;
};

/**
 * DraggableGroupElement is a mixin class used to create a group element to
 * contain draggable elements, which are items that can be clicked and dragged by a mouse.
 * The class is used with OO.ui.mixin.DraggableElement.
 *
 * @abstract
 * @class
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [orientation] Item orientation: 'horizontal' or 'vertical'. The orientation
 *  should match the layout of the items. Items displayed in a single row
 *  or in several rows should use horizontal orientation. The vertical orientation should only be
 *  used when the items are displayed in a single column. Defaults to 'vertical'
 * @cfg {boolean} [draggable] The items are draggable. This can change with #toggleDraggable
 */
OO.ui.mixin.DraggableGroupElement = function OoUiMixinDraggableGroupElement( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.mixin.GroupElement.call( this, config );

  // Properties
  this.orientation = config.orientation || 'vertical';
  this.dragItem = null;
  this.itemKeys = {};
  this.dir = null;
  this.itemsOrder = null;
  this.draggable = config.draggable === undefined ? true : !!config.draggable;

  // Events
  this.aggregate( {
    dragstart: 'itemDragStart',
    dragend: 'itemDragEnd',
    drop: 'itemDrop'
  } );
  this.connect( this, {
    itemDragStart: 'onItemDragStart',
    itemDrop: 'onItemDropOrDragEnd',
    itemDragEnd: 'onItemDropOrDragEnd'
  } );

  // Initialize
  if ( Array.isArray( config.items ) ) {
    this.addItems( config.items );
  }
  this.$element
    .addClass( 'oo-ui-draggableGroupElement' )
    .toggleClass( 'oo-ui-draggableGroupElement-horizontal', this.orientation === 'horizontal' );
};

/* Setup */
OO.mixinClass( OO.ui.mixin.DraggableGroupElement, OO.ui.mixin.GroupElement );

/* Events */

/**
 * An item has been dragged to a new position, but not yet dropped.
 *
 * @event drag
 * @param {OO.ui.mixin.DraggableElement} item Dragged item
 * @param {number} [newIndex] New index for the item
 */

/**
 * An item has been dropped at a new position.
 *
 * @event reorder
 * @param {OO.ui.mixin.DraggableElement} item Reordered item
 * @param {number} [newIndex] New index for the item
 */

/**
 * Draggable state of this widget has changed.
 *
 * @event draggable
 * @param {boolean} [draggable] Widget is draggable
 */

/* Methods */

/**
 * Change the draggable state of this widget.
 * This allows users to temporarily halt the dragging operations.
 *
 * @param {boolean} isDraggable Widget supports draggable operations
 * @fires draggable
 */
OO.ui.mixin.DraggableGroupElement.prototype.toggleDraggable = function ( isDraggable ) {
  isDraggable = isDraggable !== undefined ? !!isDraggable : !this.draggable;

  if ( this.draggable !== isDraggable ) {
    this.draggable = isDraggable;

    // Tell the items their draggable state changed
    this.getItems().forEach( function ( item ) {
      item.toggleDraggable( this.draggable );
    }.bind( this ) );

    // Emit event
    this.emit( 'draggable', this.draggable );
  }
};

/**
 * Check the draggable state of this widget
 *
 * @return {boolean} Widget supports draggable operations
 */
OO.ui.mixin.DraggableGroupElement.prototype.isDraggable = function () {
  return this.draggable;
};

/**
 * Respond to item drag start event
 *
 * @private
 * @param {OO.ui.mixin.DraggableElement} item Dragged item
 */
OO.ui.mixin.DraggableGroupElement.prototype.onItemDragStart = function ( item ) {
  if ( !this.isDraggable() ) {
    return;
  }
  // Make a shallow copy of this.items so we can re-order it during previews
  // without affecting the original array.
  this.itemsOrder = this.items.slice();
  this.updateIndexes();
  if ( this.orientation === 'horizontal' ) {
    // Calculate and cache directionality on drag start - it's a little
    // expensive and it shouldn't change while dragging.
    this.dir = this.$element.css( 'direction' );
  }
  this.setDragItem( item );
};

/**
 * Update the index properties of the items
 */
OO.ui.mixin.DraggableGroupElement.prototype.updateIndexes = function () {
  var i, len;

  // Map the index of each object
  for ( i = 0, len = this.itemsOrder.length; i < len; i++ ) {
    this.itemsOrder[ i ].setIndex( i );
  }
};

/**
 * Handle drop or dragend event and switch the order of the items accordingly
 *
 * @private
 * @param {OO.ui.mixin.DraggableElement} item Dropped item
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.DraggableGroupElement.prototype.onItemDropOrDragEnd = function () {
  var targetIndex, originalIndex,
    item = this.getDragItem();

  // TODO: Figure out a way to configure a list of legally droppable
  // elements even if they are not yet in the list
  if ( item ) {
    originalIndex = this.items.indexOf( item );
    // If the item has moved forward, add one to the index to account for the left shift
    targetIndex = item.getIndex() + ( item.getIndex() > originalIndex ? 1 : 0 );
    if ( targetIndex !== originalIndex ) {
      this.reorder( this.getDragItem(), targetIndex );
      this.emit( 'reorder', this.getDragItem(), targetIndex );
    }
    this.updateIndexes();
  }
  this.unsetDragItem();
  // Return false to prevent propogation
  return false;
};

/**
 * Respond to dragover event
 *
 * @private
 * @param {jQuery.Event} e Dragover event
 * @fires reorder
 */
OO.ui.mixin.DraggableGroupElement.prototype.onDragOver = function ( e ) {
  var overIndex, targetIndex,
    item = this.getDragItem(),
    dragItemIndex = item.getIndex();

  // Get the OptionWidget item we are dragging over
  overIndex = $( e.target ).closest( '.oo-ui-draggableElement' ).data( 'index' );

  if ( overIndex !== undefined && overIndex !== dragItemIndex ) {
    targetIndex = overIndex + ( overIndex > dragItemIndex ? 1 : 0 );

    if ( targetIndex > 0 ) {
      this.$group.children().eq( targetIndex - 1 ).after( item.$element );
    } else {
      this.$group.prepend( item.$element );
    }
    // Move item in itemsOrder array
    this.itemsOrder.splice( overIndex, 0,
      this.itemsOrder.splice( dragItemIndex, 1 )[ 0 ]
    );
    this.updateIndexes();
    this.emit( 'drag', item, targetIndex );
  }
  // Prevent default
  e.preventDefault();
};

/**
 * Reorder the items in the group
 *
 * @param {OO.ui.mixin.DraggableElement} item Reordered item
 * @param {number} newIndex New index
 */
OO.ui.mixin.DraggableGroupElement.prototype.reorder = function ( item, newIndex ) {
  this.addItems( [ item ], newIndex );
};

/**
 * Set a dragged item
 *
 * @param {OO.ui.mixin.DraggableElement} item Dragged item
 */
OO.ui.mixin.DraggableGroupElement.prototype.setDragItem = function ( item ) {
  if ( this.dragItem !== item ) {
    this.dragItem = item;
    this.$element.on( 'dragover', this.onDragOver.bind( this ) );
    this.$element.addClass( 'oo-ui-draggableGroupElement-dragging' );
  }
};

/**
 * Unset the current dragged item
 */
OO.ui.mixin.DraggableGroupElement.prototype.unsetDragItem = function () {
  if ( this.dragItem ) {
    this.dragItem = null;
    this.$element.off( 'dragover' );
    this.$element.removeClass( 'oo-ui-draggableGroupElement-dragging' );
  }
};

/**
 * Get the item that is currently being dragged.
 *
 * @return {OO.ui.mixin.DraggableElement|null} The currently dragged item, or `null` if no item is
 *  being dragged
 */
OO.ui.mixin.DraggableGroupElement.prototype.getDragItem = function () {
  return this.dragItem;
};

/**
 * RequestManager is a mixin that manages the lifecycle of a promise-backed request for a widget,
 * such as the {@link OO.ui.mixin.LookupElement}.
 *
 * @class
 * @abstract
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [showPendingRequest=true] Show pending state while request data is being fetched.
 *  Requires widget to have also mixed in {@link OO.ui.mixin.PendingElement}.
 */
OO.ui.mixin.RequestManager = function OoUiMixinRequestManager( config ) {
  this.requestCache = {};
  this.requestQuery = null;
  this.requestRequest = null;
  this.showPendingRequest = !!this.pushPending && config.showPendingRequest !== false;
};

/* Setup */

OO.initClass( OO.ui.mixin.RequestManager );

/**
 * Get request results for the current query.
 *
 * @return {jQuery.Promise} Promise object which will be passed response data as the first argument
 *  of the done event. If the request was aborted to make way for a subsequent request, this
 *  promise may not be rejected, depending on what jQuery feels like doing.
 */
OO.ui.mixin.RequestManager.prototype.getRequestData = function () {
  var widget = this,
    value = this.getRequestQuery(),
    deferred = $.Deferred(),
    ourRequest;

  this.abortRequest();
  if ( Object.prototype.hasOwnProperty.call( this.requestCache, value ) ) {
    deferred.resolve( this.requestCache[ value ] );
  } else {
    if ( this.showPendingRequest ) {
      this.pushPending();
    }
    this.requestQuery = value;
    ourRequest = this.requestRequest = this.getRequest();
    ourRequest
      .always( function () {
        // We need to pop pending even if this is an old request, otherwise
        // the widget will remain pending forever.
        // TODO: this assumes that an aborted request will fail or succeed soon after
        // being aborted, or at least eventually. It would be nice if we could popPending()
        // at abort time, but only if we knew that we hadn't already called popPending()
        // for that request.
        if ( widget.showPendingRequest ) {
          widget.popPending();
        }
      } )
      .done( function ( response ) {
        // If this is an old request (and aborting it somehow caused it to still succeed),
        // ignore its success completely
        if ( ourRequest === widget.requestRequest ) {
          widget.requestQuery = null;
          widget.requestRequest = null;
          widget.requestCache[ value ] =
            widget.getRequestCacheDataFromResponse( response );
          deferred.resolve( widget.requestCache[ value ] );
        }
      } )
      .fail( function () {
        // If this is an old request (or a request failing because it's being aborted),
        // ignore its failure completely
        if ( ourRequest === widget.requestRequest ) {
          widget.requestQuery = null;
          widget.requestRequest = null;
          deferred.reject();
        }
      } );
  }
  return deferred.promise();
};

/**
 * Abort the currently pending request, if any.
 *
 * @private
 */
OO.ui.mixin.RequestManager.prototype.abortRequest = function () {
  var oldRequest = this.requestRequest;
  if ( oldRequest ) {
    // First unset this.requestRequest to the fail handler will notice
    // that the request is no longer current
    this.requestRequest = null;
    this.requestQuery = null;
    oldRequest.abort();
  }
};

/**
 * Get the query to be made.
 *
 * @protected
 * @method
 * @abstract
 * @return {string} query to be used
 */
OO.ui.mixin.RequestManager.prototype.getRequestQuery = null;

/**
 * Get a new request object of the current query value.
 *
 * @protected
 * @method
 * @abstract
 * @return {jQuery.Promise} jQuery AJAX object, or promise object with an .abort() method
 */
OO.ui.mixin.RequestManager.prototype.getRequest = null;

/**
 * Pre-process data returned by the request from #getRequest.
 *
 * The return value of this function will be cached, and any further queries for the given value
 * will use the cache rather than doing API requests.
 *
 * @protected
 * @method
 * @abstract
 * @param {Mixed} response Response from server
 * @return {Mixed} Cached result data
 */
OO.ui.mixin.RequestManager.prototype.getRequestCacheDataFromResponse = null;

/**
 * LookupElement is a mixin that creates a {@link OO.ui.MenuSelectWidget menu} of suggested
 * values for a {@link OO.ui.TextInputWidget text input widget}. Suggested values are based on
 * the characters the user types into the text input field and, in general, the menu is only
 * displayed when the user types. If a suggested value is chosen from the lookup menu, that value
 * becomes the value of the input field.
 *
 * Note that a new menu of suggested items is displayed when a value is chosen from the
 * lookup menu. If this is not the desired behavior, disable lookup menus with the
 * #setLookupsDisabled method, then set the value, then re-enable lookups.
 *
 * See the [OOUI demos][1] for an example.
 *
 * [1]: https://doc.wikimedia.org/oojs-ui/master/demos/#LookupElement-try-inputting-an-integer
 *
 * @class
 * @abstract
 * @mixins OO.ui.mixin.RequestManager
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {jQuery} [$overlay] Overlay for the lookup menu; defaults to relative positioning.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 * @cfg {jQuery} [$container=this.$element] The container element. The lookup menu is rendered
 *  beneath the specified element.
 * @cfg {Object} [menu] Configuration options to pass to
 *  {@link OO.ui.MenuSelectWidget menu select widget}
 * @cfg {boolean} [allowSuggestionsWhenEmpty=false] Request and display a lookup menu when the
 *  text input is empty.
 *  By default, the lookup menu is not generated and displayed until the user begins to type.
 * @cfg {boolean} [highlightFirst=true] Whether the first lookup result should be highlighted
 *  (so, that the user can take it over into the input with simply pressing return) automatically
 *  or not.
 * @cfg {boolean} [showSuggestionsOnFocus=true] Show suggestions when focusing the input. If this
 *  is set to false, suggestions will still be shown on a mousedown triggered focus. This matches
 *  browser autocomplete behavior.
 */
OO.ui.mixin.LookupElement = function OoUiMixinLookupElement( config ) {
  // Configuration initialization
  config = $.extend( { highlightFirst: true }, config );

  // Mixin constructors
  OO.ui.mixin.RequestManager.call( this, config );

  // Properties
  this.$overlay = ( config.$overlay === true ?
    OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;
  this.lookupMenu = new OO.ui.MenuSelectWidget( $.extend( {
    widget: this,
    input: this,
    $floatableContainer: config.$container || this.$element
  }, config.menu ) );

  this.allowSuggestionsWhenEmpty = config.allowSuggestionsWhenEmpty || false;

  this.lookupsDisabled = false;
  this.lookupInputFocused = false;
  this.lookupHighlightFirstItem = config.highlightFirst;
  this.showSuggestionsOnFocus = config.showSuggestionsOnFocus !== false;

  // Events
  this.$input.on( {
    focus: this.onLookupInputFocus.bind( this ),
    blur: this.onLookupInputBlur.bind( this ),
    mousedown: this.onLookupInputMouseDown.bind( this )
  } );
  this.connect( this, {
    change: 'onLookupInputChange'
  } );
  this.lookupMenu.connect( this, {
    toggle: 'onLookupMenuToggle',
    choose: 'onLookupMenuChoose'
  } );

  // Initialization
  this.$input.attr( {
    role: 'combobox',
    'aria-owns': this.lookupMenu.getElementId(),
    'aria-autocomplete': 'list'
  } );
  this.$element.addClass( 'oo-ui-lookupElement' );
  this.lookupMenu.$element.addClass( 'oo-ui-lookupElement-menu' );
  this.$overlay.append( this.lookupMenu.$element );
};

/* Setup */

OO.mixinClass( OO.ui.mixin.LookupElement, OO.ui.mixin.RequestManager );

/* Methods */

/**
 * Handle input focus event.
 *
 * @protected
 * @param {jQuery.Event} e Input focus event
 */
OO.ui.mixin.LookupElement.prototype.onLookupInputFocus = function () {
  this.lookupInputFocused = true;
  if ( this.showSuggestionsOnFocus ) {
    this.populateLookupMenu();
  }
};

/**
 * Handle input blur event.
 *
 * @protected
 * @param {jQuery.Event} e Input blur event
 */
OO.ui.mixin.LookupElement.prototype.onLookupInputBlur = function () {
  this.closeLookupMenu();
  this.lookupInputFocused = false;
};

/**
 * Handle input mouse down event.
 *
 * @protected
 * @param {jQuery.Event} e Input mouse down event
 */
OO.ui.mixin.LookupElement.prototype.onLookupInputMouseDown = function () {
  if (
    !this.lookupMenu.isVisible() &&
    (
      // Open the menu if the input was already focused.
      // This way we allow the user to open the menu again after closing it with Escape (esc)
      // by clicking in the input.
      this.lookupInputFocused ||
      // If showSuggestionsOnFocus is disabled, still open the menu on mousedown.
      !this.showSuggestionsOnFocus
    )
  ) {
    this.populateLookupMenu();
  }
};

/**
 * Handle input change event.
 *
 * @protected
 * @param {string} value New input value
 */
OO.ui.mixin.LookupElement.prototype.onLookupInputChange = function () {
  if ( this.lookupInputFocused ) {
    this.populateLookupMenu();
  }
};

/**
 * Handle the lookup menu being shown/hidden.
 *
 * @protected
 * @param {boolean} visible Whether the lookup menu is now visible.
 */
OO.ui.mixin.LookupElement.prototype.onLookupMenuToggle = function ( visible ) {
  if ( !visible ) {
    // When the menu is hidden, abort any active request and clear the menu.
    // This has to be done here in addition to closeLookupMenu(), because
    // MenuSelectWidget will close itself when the user presses Escape (esc).
    this.abortLookupRequest();
    this.lookupMenu.clearItems();
  }
};

/**
 * Handle menu item 'choose' event, updating the text input value to the value of the clicked item.
 *
 * @protected
 * @param {OO.ui.MenuOptionWidget} item Selected item
 */
OO.ui.mixin.LookupElement.prototype.onLookupMenuChoose = function ( item ) {
  this.setValue( item.getData() );
};

/**
 * Get lookup menu.
 *
 * @private
 * @return {OO.ui.MenuSelectWidget}
 */
OO.ui.mixin.LookupElement.prototype.getLookupMenu = function () {
  return this.lookupMenu;
};

/**
 * Disable or re-enable lookups.
 *
 * When lookups are disabled, calls to #populateLookupMenu will be ignored.
 *
 * @param {boolean} disabled Disable lookups
 */
OO.ui.mixin.LookupElement.prototype.setLookupsDisabled = function ( disabled ) {
  this.lookupsDisabled = !!disabled;
};

/**
 * Open the menu. If there are no entries in the menu, this does nothing.
 *
 * @private
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LookupElement.prototype.openLookupMenu = function () {
  if ( !this.lookupMenu.isEmpty() ) {
    this.lookupMenu.toggle( true );
  }
  return this;
};

/**
 * Close the menu, empty it, and abort any pending request.
 *
 * @private
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LookupElement.prototype.closeLookupMenu = function () {
  this.lookupMenu.toggle( false );
  this.abortLookupRequest();
  this.lookupMenu.clearItems();
  return this;
};

/**
 * Request menu items based on the input's current value, and when they arrive,
 * populate the menu with these items and show the menu.
 *
 * If lookups have been disabled with #setLookupsDisabled, this function does nothing.
 *
 * @private
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LookupElement.prototype.populateLookupMenu = function () {
  var widget = this,
    value = this.getValue();

  if ( this.lookupsDisabled || this.isReadOnly() ) {
    return;
  }

  // If the input is empty, clear the menu, unless suggestions when empty are allowed.
  if ( !this.allowSuggestionsWhenEmpty && value === '' ) {
    this.closeLookupMenu();
  // Skip population if there is already a request pending for the current value
  } else if ( value !== this.lookupQuery ) {
    this.getLookupMenuItems()
      .done( function ( items ) {
        widget.lookupMenu.clearItems();
        if ( items.length ) {
          widget.lookupMenu
            .addItems( items )
            .toggle( true );
          widget.initializeLookupMenuSelection();
        } else {
          widget.lookupMenu.toggle( false );
        }
      } )
      .fail( function () {
        widget.lookupMenu.clearItems();
        widget.lookupMenu.toggle( false );
      } );
  }

  return this;
};

/**
 * Highlight the first selectable item in the menu, if configured.
 *
 * @private
 * @chainable
 */
OO.ui.mixin.LookupElement.prototype.initializeLookupMenuSelection = function () {
  if ( this.lookupHighlightFirstItem && !this.lookupMenu.findSelectedItem() ) {
    this.lookupMenu.highlightItem( this.lookupMenu.findFirstSelectableItem() );
  }
};

/**
 * Get lookup menu items for the current query.
 *
 * @private
 * @return {jQuery.Promise} Promise object which will be passed menu items as the first argument of
 *   the done event. If the request was aborted to make way for a subsequent request, this promise
 *   will not be rejected: it will remain pending forever.
 */
OO.ui.mixin.LookupElement.prototype.getLookupMenuItems = function () {
  return this.getRequestData().then( function ( data ) {
    return this.getLookupMenuOptionsFromData( data );
  }.bind( this ) );
};

/**
 * Abort the currently pending lookup request, if any.
 *
 * @private
 */
OO.ui.mixin.LookupElement.prototype.abortLookupRequest = function () {
  this.abortRequest();
};

/**
 * Get a new request object of the current lookup query value.
 *
 * @protected
 * @method
 * @abstract
 * @return {jQuery.Promise} jQuery AJAX object, or promise object with an .abort() method
 */
OO.ui.mixin.LookupElement.prototype.getLookupRequest = null;

/**
 * Pre-process data returned by the request from #getLookupRequest.
 *
 * The return value of this function will be cached, and any further queries for the given value
 * will use the cache rather than doing API requests.
 *
 * @protected
 * @method
 * @abstract
 * @param {Mixed} response Response from server
 * @return {Mixed} Cached result data
 */
OO.ui.mixin.LookupElement.prototype.getLookupCacheDataFromResponse = null;

/**
 * Get a list of menu option widgets from the (possibly cached) data returned by
 * #getLookupCacheDataFromResponse.
 *
 * @protected
 * @method
 * @abstract
 * @param {Mixed} data Cached result data, usually an array
 * @return {OO.ui.MenuOptionWidget[]} Menu items
 */
OO.ui.mixin.LookupElement.prototype.getLookupMenuOptionsFromData = null;

/**
 * Set the read-only state of the widget.
 *
 * This will also disable/enable the lookups functionality.
 *
 * @param {boolean} readOnly Make input read-only
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.mixin.LookupElement.prototype.setReadOnly = function ( readOnly ) {
  // Parent method
  // Note: Calling #setReadOnly this way assumes this is mixed into an OO.ui.TextInputWidget
  OO.ui.TextInputWidget.prototype.setReadOnly.call( this, readOnly );

  // During construction, #setReadOnly is called before the OO.ui.mixin.LookupElement constructor.
  if ( this.isReadOnly() && this.lookupMenu ) {
    this.closeLookupMenu();
  }

  return this;
};

/**
 * @inheritdoc OO.ui.mixin.RequestManager
 */
OO.ui.mixin.LookupElement.prototype.getRequestQuery = function () {
  return this.getValue();
};

/**
 * @inheritdoc OO.ui.mixin.RequestManager
 */
OO.ui.mixin.LookupElement.prototype.getRequest = function () {
  return this.getLookupRequest();
};

/**
 * @inheritdoc OO.ui.mixin.RequestManager
 */
OO.ui.mixin.LookupElement.prototype.getRequestCacheDataFromResponse = function ( response ) {
  return this.getLookupCacheDataFromResponse( response );
};

/**
 * TabPanelLayouts are used within {@link OO.ui.IndexLayout index layouts} to create tab panels that
 * users can select and display from the index's optional {@link OO.ui.TabSelectWidget tab}
 * navigation. TabPanels are usually not instantiated directly, rather extended to include the
 * required content and functionality.
 *
 * Each tab panel must have a unique symbolic name, which is passed to the constructor. In addition,
 * the tab panel's tab item is customized (with a label) using the #setupTabItem method. See
 * {@link OO.ui.IndexLayout IndexLayout} for an example.
 *
 * @class
 * @extends OO.ui.PanelLayout
 *
 * @constructor
 * @param {string} name Unique symbolic name of tab panel
 * @param {Object} [config] Configuration options
 * @cfg {jQuery|string|Function|OO.ui.HtmlSnippet} [label] Label for tab panel's tab
 * @cfg {Object} [tabItemConfig] Additional tab item config
 */
OO.ui.TabPanelLayout = function OoUiTabPanelLayout( name, config ) {
  // Allow passing positional parameters inside the config object
  if ( OO.isPlainObject( name ) && config === undefined ) {
    config = name;
    name = config.name;
  }

  // Configuration initialization
  config = $.extend( { scrollable: true }, config );

  // Parent constructor
  OO.ui.TabPanelLayout.super.call( this, config );

  // Properties
  this.name = name;
  this.label = config.label;
  this.tabItemConfig = config.tabItemConfig || {};
  this.tabItem = null;
  this.active = false;

  // Initialization
  this.$element
    .addClass( 'oo-ui-tabPanelLayout' )
    .attr( 'role', 'tabpanel' );
};

/* Setup */

OO.inheritClass( OO.ui.TabPanelLayout, OO.ui.PanelLayout );

/* Events */

/**
 * An 'active' event is emitted when the tab panel becomes active. Tab panels become active when
 * they are shown in a index layout that is configured to display only one tab panel at a time.
 *
 * @event active
 * @param {boolean} active Tab panel is active
 */

/* Methods */

/**
 * Get the symbolic name of the tab panel.
 *
 * @return {string} Symbolic name of tab panel
 */
OO.ui.TabPanelLayout.prototype.getName = function () {
  return this.name;
};

/**
 * Check if tab panel is active.
 *
 * Tab panels become active when they are shown in a {@link OO.ui.IndexLayout index layout} that is
 * configured to display only one tab panel at a time. Additional CSS is applied to the tab panel's
 * tab item to reflect the active state.
 *
 * @return {boolean} Tab panel is active
 */
OO.ui.TabPanelLayout.prototype.isActive = function () {
  return this.active;
};

/**
 * Get tab item.
 *
 * The tab item allows users to access the tab panel from the index's tab
 * navigation. The tab item itself can be customized (with a label, level, etc.) using the
 * #setupTabItem method.
 *
 * @return {OO.ui.TabOptionWidget|null} Tab option widget
 */
OO.ui.TabPanelLayout.prototype.getTabItem = function () {
  return this.tabItem;
};

/**
 * Get config for creating a tab item.
 *
 * @return {Object} Tab option config
 */
OO.ui.TabPanelLayout.prototype.getTabItemConfig = function () {
  return this.tabItemConfig;
};

/**
 * Set or unset the tab item.
 *
 * Specify a {@link OO.ui.TabOptionWidget tab option} to set it,
 * or `null` to clear the tab item. To customize the tab item itself (e.g., to set a label or tab
 * level), use #setupTabItem instead of this method.
 *
 * @param {OO.ui.TabOptionWidget|null} tabItem Tab option widget, null to clear
 * @chainable
 * @return {OO.ui.TabPanelLayout} The layout, for chaining
 */
OO.ui.TabPanelLayout.prototype.setTabItem = function ( tabItem ) {
  this.tabItem = tabItem || null;
  if ( tabItem ) {
    this.setupTabItem();
  }
  return this;
};

/**
 * Set up the tab item.
 *
 * Use this method to customize the tab item (e.g., to add a label or tab level). To set or unset
 * the tab item itself (with a {@link OO.ui.TabOptionWidget tab option} or `null`), use
 * the #setTabItem method instead.
 *
 * @param {OO.ui.TabOptionWidget} tabItem Tab option widget to set up
 * @chainable
 * @return {OO.ui.TabPanelLayout} The layout, for chaining
 */
OO.ui.TabPanelLayout.prototype.setupTabItem = function () {
  this.$element.attr( 'aria-labelledby', this.tabItem.getElementId() );

  this.tabItem.$element.attr( 'aria-controls', this.getElementId() );

  if ( this.label ) {
    this.tabItem.setLabel( this.label );
  }
  return this;
};

/**
 * Set the tab panel to its 'active' state.
 *
 * Tab panels become active when they are shown in a index layout that is configured to display only
 * one tab panel at a time. Additional CSS is applied to the tab item to reflect the tab panel's
 * active state. Outside of the index context, setting the active state on a tab panel does nothing.
 *
 * @param {boolean} active Tab panel is active
 * @fires active
 */
OO.ui.TabPanelLayout.prototype.setActive = function ( active ) {
  active = !!active;

  if ( active !== this.active ) {
    this.active = active;
    this.$element.toggleClass( 'oo-ui-tabPanelLayout-active', this.active );
    this.emit( 'active', this.active );
  }
};

/**
 * PageLayouts are used within {@link OO.ui.BookletLayout booklet layouts} to create pages that
 * users can select and display from the booklet's optional
 * {@link OO.ui.OutlineSelectWidget outline} navigation. Pages are usually not instantiated
 * directly, rather extended to include the required content and functionality.
 *
 * Each page must have a unique symbolic name, which is passed to the constructor. In addition, the
 * page's outline item is customized (with a label, outline level, etc.) using the
 * #setupOutlineItem method. See {@link OO.ui.BookletLayout BookletLayout} for an example.
 *
 * @class
 * @extends OO.ui.PanelLayout
 *
 * @constructor
 * @param {string} name Unique symbolic name of page
 * @param {Object} [config] Configuration options
 */
OO.ui.PageLayout = function OoUiPageLayout( name, config ) {
  // Allow passing positional parameters inside the config object
  if ( OO.isPlainObject( name ) && config === undefined ) {
    config = name;
    name = config.name;
  }

  // Configuration initialization
  config = $.extend( { scrollable: true }, config );

  // Parent constructor
  OO.ui.PageLayout.super.call( this, config );

  // Properties
  this.name = name;
  this.outlineItem = null;
  this.active = false;

  // Initialization
  this.$element.addClass( 'oo-ui-pageLayout' );
};

/* Setup */

OO.inheritClass( OO.ui.PageLayout, OO.ui.PanelLayout );

/* Events */

/**
 * An 'active' event is emitted when the page becomes active. Pages become active when they are
 * shown in a booklet layout that is configured to display only one page at a time.
 *
 * @event active
 * @param {boolean} active Page is active
 */

/* Methods */

/**
 * Get the symbolic name of the page.
 *
 * @return {string} Symbolic name of page
 */
OO.ui.PageLayout.prototype.getName = function () {
  return this.name;
};

/**
 * Check if page is active.
 *
 * Pages become active when they are shown in a {@link OO.ui.BookletLayout booklet layout} that is
 * configured to display only one page at a time. Additional CSS is applied to the page's outline
 * item to reflect the active state.
 *
 * @return {boolean} Page is active
 */
OO.ui.PageLayout.prototype.isActive = function () {
  return this.active;
};

/**
 * Get outline item.
 *
 * The outline item allows users to access the page from the booklet's outline
 * navigation. The outline item itself can be customized (with a label, level, etc.) using the
 * #setupOutlineItem method.
 *
 * @return {OO.ui.OutlineOptionWidget|null} Outline option widget
 */
OO.ui.PageLayout.prototype.getOutlineItem = function () {
  return this.outlineItem;
};

/**
 * Set or unset the outline item.
 *
 * Specify an {@link OO.ui.OutlineOptionWidget outline option} to set it,
 * or `null` to clear the outline item. To customize the outline item itself (e.g., to set a label
 * or outline level), use #setupOutlineItem instead of this method.
 *
 * @param {OO.ui.OutlineOptionWidget|null} outlineItem Outline option widget, null to clear
 * @chainable
 * @return {OO.ui.PageLayout} The layout, for chaining
 */
OO.ui.PageLayout.prototype.setOutlineItem = function ( outlineItem ) {
  this.outlineItem = outlineItem || null;
  if ( outlineItem ) {
    this.setupOutlineItem();
  }
  return this;
};

/**
 * Set up the outline item.
 *
 * Use this method to customize the outline item (e.g., to add a label or outline level). To set or
 * unset the outline item itself (with an {@link OO.ui.OutlineOptionWidget outline option} or
 * `null`), use the #setOutlineItem method instead.
 *
 * @param {OO.ui.OutlineOptionWidget} outlineItem Outline option widget to set up
 * @chainable
 * @return {OO.ui.PageLayout} The layout, for chaining
 */
OO.ui.PageLayout.prototype.setupOutlineItem = function () {
  return this;
};

/**
 * Set the page to its 'active' state.
 *
 * Pages become active when they are shown in a booklet layout that is configured to display only
 * one page at a time. Additional CSS is applied to the outline item to reflect the page's active
 * state. Outside of the booklet context, setting the active state on a page does nothing.
 *
 * @param {boolean} active Page is active
 * @fires active
 */
OO.ui.PageLayout.prototype.setActive = function ( active ) {
  active = !!active;

  if ( active !== this.active ) {
    this.active = active;
    this.$element.toggleClass( 'oo-ui-pageLayout-active', active );
    this.emit( 'active', this.active );
  }
};

/**
 * StackLayouts contain a series of {@link OO.ui.PanelLayout panel layouts}. By default, only one
 * panel is displayed at a time, though the stack layout can also be configured to show all
 * contained panels, one after another, by setting the #continuous option to 'true'.
 *
 *     @example
 *     // A stack layout with two panels, configured to be displayed continuously
 *     var myStack = new OO.ui.StackLayout( {
 *         items: [
 *             new OO.ui.PanelLayout( {
 *                 $content: $( '<p>Panel One</p>' ),
 *                 padded: true,
 *                 framed: true
 *             } ),
 *             new OO.ui.PanelLayout( {
 *                 $content: $( '<p>Panel Two</p>' ),
 *                 padded: true,
 *                 framed: true
 *             } )
 *         ],
 *         continuous: true
 *     } );
 *     $( document.body ).append( myStack.$element );
 *
 * @class
 * @extends OO.ui.PanelLayout
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [continuous=false] Show all panels, one after another. By default, only one panel
 *  is displayed at a time.
 * @cfg {OO.ui.Layout[]} [items] Panel layouts to add to the stack layout.
 */
OO.ui.StackLayout = function OoUiStackLayout( config ) {
  // Configuration initialization
  // Make the layout scrollable in continuous mode, otherwise each
  // panel is responsible for its own scrolling.
  config = $.extend( { scrollable: !!( config && config.continuous ) }, config );

  // Parent constructor
  OO.ui.StackLayout.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.GroupElement.call( this, $.extend( { $group: this.$element }, config ) );

  // Properties
  this.currentItem = null;
  this.continuous = !!config.continuous;

  // Initialization
  this.$element.addClass( 'oo-ui-stackLayout' );
  if ( this.continuous ) {
    this.$element.addClass( 'oo-ui-stackLayout-continuous' );
    this.$element.on( 'scroll', OO.ui.debounce( this.onScroll.bind( this ), 250 ) );
  }
  if ( Array.isArray( config.items ) ) {
    this.addItems( config.items );
  }
};

/* Setup */

OO.inheritClass( OO.ui.StackLayout, OO.ui.PanelLayout );
OO.mixinClass( OO.ui.StackLayout, OO.ui.mixin.GroupElement );

/* Events */

/**
 * A 'set' event is emitted when panels are {@link #addItems added}, {@link #removeItems removed},
 * {@link #clearItems cleared} or {@link #setItem displayed}.
 *
 * @event set
 * @param {OO.ui.Layout|null} item Current panel or `null` if no panel is shown
 */

/**
 * When used in continuous mode, this event is emitted when the user scrolls down
 * far enough such that currentItem is no longer visible.
 *
 * @event visibleItemChange
 * @param {OO.ui.PanelLayout} panel The next visible item in the layout
 */

/* Methods */

/**
 * Handle scroll events from the layout element
 *
 * @param {jQuery.Event} e
 * @fires visibleItemChange
 */
OO.ui.StackLayout.prototype.onScroll = function () {
  var currentRect,
    len = this.items.length,
    currentIndex = this.items.indexOf( this.currentItem ),
    newIndex = currentIndex,
    containerRect = this.$element[ 0 ].getBoundingClientRect();

  if ( !containerRect || ( !containerRect.top && !containerRect.bottom ) ) {
    // Can't get bounding rect, possibly not attached.
    return;
  }

  function getRect( item ) {
    return item.$element[ 0 ].getBoundingClientRect();
  }

  function isVisible( item ) {
    var rect = getRect( item );
    return rect.bottom > containerRect.top && rect.top < containerRect.bottom;
  }

  currentRect = getRect( this.currentItem );

  if ( currentRect.bottom < containerRect.top ) {
    // Scrolled down past current item
    while ( ++newIndex < len ) {
      if ( isVisible( this.items[ newIndex ] ) ) {
        break;
      }
    }
  } else if ( currentRect.top > containerRect.bottom ) {
    // Scrolled up past current item
    while ( --newIndex >= 0 ) {
      if ( isVisible( this.items[ newIndex ] ) ) {
        break;
      }
    }
  }

  if ( newIndex !== currentIndex ) {
    this.emit( 'visibleItemChange', this.items[ newIndex ] );
  }
};

/**
 * Get the current panel.
 *
 * @return {OO.ui.Layout|null}
 */
OO.ui.StackLayout.prototype.getCurrentItem = function () {
  return this.currentItem;
};

/**
 * Unset the current item.
 *
 * @private
 * @param {OO.ui.StackLayout} layout
 * @fires set
 */
OO.ui.StackLayout.prototype.unsetCurrentItem = function () {
  var prevItem = this.currentItem;
  if ( prevItem === null ) {
    return;
  }

  this.currentItem = null;
  this.emit( 'set', null );
};

/**
 * Add panel layouts to the stack layout.
 *
 * Panels will be added to the end of the stack layout array unless the optional index parameter
 * specifies a different insertion point. Adding a panel that is already in the stack will move it
 * to the end of the array or the point specified by the index.
 *
 * @param {OO.ui.Layout[]} items Panels to add
 * @param {number} [index] Index of the insertion point
 * @chainable
 * @return {OO.ui.StackLayout} The layout, for chaining
 */
OO.ui.StackLayout.prototype.addItems = function ( items, index ) {
  // Update the visibility
  this.updateHiddenState( items, this.currentItem );

  // Mixin method
  OO.ui.mixin.GroupElement.prototype.addItems.call( this, items, index );

  if ( !this.currentItem && items.length ) {
    this.setItem( items[ 0 ] );
  }

  return this;
};

/**
 * Remove the specified panels from the stack layout.
 *
 * Removed panels are detached from the DOM, not removed, so that they may be reused. To remove all
 * panels, you may wish to use the #clearItems method instead.
 *
 * @param {OO.ui.Layout[]} items Panels to remove
 * @chainable
 * @return {OO.ui.StackLayout} The layout, for chaining
 * @fires set
 */
OO.ui.StackLayout.prototype.removeItems = function ( items ) {
  // Mixin method
  OO.ui.mixin.GroupElement.prototype.removeItems.call( this, items );

  if ( items.indexOf( this.currentItem ) !== -1 ) {
    if ( this.items.length ) {
      this.setItem( this.items[ 0 ] );
    } else {
      this.unsetCurrentItem();
    }
  }

  return this;
};

/**
 * Clear all panels from the stack layout.
 *
 * Cleared panels are detached from the DOM, not removed, so that they may be reused. To remove only
 * a subset of panels, use the #removeItems method.
 *
 * @chainable
 * @return {OO.ui.StackLayout} The layout, for chaining
 * @fires set
 */
OO.ui.StackLayout.prototype.clearItems = function () {
  this.unsetCurrentItem();
  OO.ui.mixin.GroupElement.prototype.clearItems.call( this );

  return this;
};

/**
 * Show the specified panel.
 *
 * If another panel is currently displayed, it will be hidden.
 *
 * @param {OO.ui.Layout} item Panel to show
 * @chainable
 * @return {OO.ui.StackLayout} The layout, for chaining
 * @fires set
 */
OO.ui.StackLayout.prototype.setItem = function ( item ) {
  if ( item !== this.currentItem ) {
    this.updateHiddenState( this.items, item );

    if ( this.items.indexOf( item ) !== -1 ) {
      this.currentItem = item;
      this.emit( 'set', item );
    } else {
      this.unsetCurrentItem();
    }
  }

  return this;
};

/**
 * Reset the scroll offset of all panels, or the container if continuous
 *
 * @inheritdoc
 */
OO.ui.StackLayout.prototype.resetScroll = function () {
  if ( this.continuous ) {
    // Parent method
    return OO.ui.StackLayout.super.prototype.resetScroll.call( this );
  }
  // Reset each panel
  this.getItems().forEach( function ( panel ) {
    // eslint-disable-next-line no-jquery/no-class-state
    var hidden = panel.$element.hasClass( 'oo-ui-element-hidden' );
    // Scroll can only be reset when panel is visible
    panel.$element.removeClass( 'oo-ui-element-hidden' );
    panel.resetScroll();
    if ( hidden ) {
      panel.$element.addClass( 'oo-ui-element-hidden' );
    }
  } );

  return this;
};

/**
 * Update the visibility of all items in case of non-continuous view.
 *
 * Ensure all items are hidden except for the selected one.
 * This method does nothing when the stack is continuous.
 *
 * @private
 * @param {OO.ui.Layout[]} items Item list iterate over
 * @param {OO.ui.Layout} [selectedItem] Selected item to show
 */
OO.ui.StackLayout.prototype.updateHiddenState = function ( items, selectedItem ) {
  var i, len;

  if ( !this.continuous ) {
    for ( i = 0, len = items.length; i < len; i++ ) {
      if ( !selectedItem || selectedItem !== items[ i ] ) {
        items[ i ].toggle( false );
        items[ i ].$element.attr( 'aria-hidden', 'true' );
      }
    }
    if ( selectedItem ) {
      selectedItem.toggle( true );
      selectedItem.$element.removeAttr( 'aria-hidden' );
    }
  }
};

/**
 * MenuLayouts combine a menu and a content {@link OO.ui.PanelLayout panel}. The menu is positioned
 * relative to the content (after, before, top, or bottom) and its size is customized with the
 * #menuSize config. The content area will fill all remaining space.
 *
 *     @example
 *     var menuLayout,
 *         menuPanel = new OO.ui.PanelLayout( {
 *             padded: true,
 *             expanded: true,
 *             scrollable: true
 *         } ),
 *         contentPanel = new OO.ui.PanelLayout( {
 *             padded: true,
 *             expanded: true,
 *             scrollable: true
 *         } ),
 *         select = new OO.ui.SelectWidget( {
 *             items: [
 *                 new OO.ui.OptionWidget( {
 *                     data: 'before',
 *                     label: 'Before'
 *                 } ),
 *                 new OO.ui.OptionWidget( {
 *                     data: 'after',
 *                     label: 'After'
 *                 } ),
 *                 new OO.ui.OptionWidget( {
 *                     data: 'top',
 *                     label: 'Top'
 *                 } ),
 *                 new OO.ui.OptionWidget( {
 *                     data: 'bottom',
 *                     label: 'Bottom'
 *                 } )
 *              ]
 *         } ).on( 'select', function ( item ) {
 *            menuLayout.setMenuPosition( item.getData() );
 *         } );
 *
 *     menuLayout = new OO.ui.MenuLayout( {
 *         position: 'top',
 *         menuPanel: menuPanel,
 *         contentPanel: contentPanel
 *     } );
 *     menuLayout.$menu.append(
 *         menuPanel.$element.append( '<b>Menu panel</b>', select.$element )
 *     );
 *     menuLayout.$content.append(
 *         contentPanel.$element.append(
 *             '<b>Content panel</b>',
 *             '<p>Note that the menu is positioned relative to the content panel: ' +
 *             'top, bottom, after, before.</p>'
 *          )
 *     );
 *     $( document.body ).append( menuLayout.$element );
 *
 * If menu size needs to be overridden, it can be accomplished using CSS similar to the snippet
 * below. MenuLayout's CSS will override the appropriate values with 'auto' or '0' to display the
 * menu correctly. If `menuPosition` is known beforehand, CSS rules corresponding to other positions
 * may be omitted.
 *
 *     .oo-ui-menuLayout-menu {
 *         width: 200px;
 *         height: 200px;
 *     }
 *
 *     .oo-ui-menuLayout-content {
 *         top: 200px;
 *         left: 200px;
 *         right: 200px;
 *         bottom: 200px;
 *     }
 *
 * @class
 * @extends OO.ui.Layout
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.PanelLayout} [menuPanel] Menu panel
 * @cfg {OO.ui.PanelLayout} [contentPanel] Content panel
 * @cfg {boolean} [expanded=true] Expand the layout to fill the entire parent element.
 * @cfg {boolean} [showMenu=true] Show menu
 * @cfg {string} [menuPosition='before'] Position of menu: `top`, `after`, `bottom` or `before`
 */
OO.ui.MenuLayout = function OoUiMenuLayout( config ) {
  // Configuration initialization
  config = $.extend( {
    expanded: true,
    showMenu: true,
    menuPosition: 'before'
  }, config );

  // Parent constructor
  OO.ui.MenuLayout.super.call( this, config );

  this.menuPanel = null;
  this.contentPanel = null;
  this.expanded = !!config.expanded;
  /**
   * Menu DOM node
   *
   * @property {jQuery}
   */
  this.$menu = $( '<div>' );
  /**
   * Content DOM node
   *
   * @property {jQuery}
   */
  this.$content = $( '<div>' );

  // Initialization
  this.$menu.addClass( 'oo-ui-menuLayout-menu' );
  this.$content.addClass( 'oo-ui-menuLayout-content' );
  this.$element.addClass( 'oo-ui-menuLayout' );
  if ( config.expanded ) {
    this.$element.addClass( 'oo-ui-menuLayout-expanded' );
  } else {
    this.$element.addClass( 'oo-ui-menuLayout-static' );
  }
  if ( config.menuPanel ) {
    this.setMenuPanel( config.menuPanel );
  }
  if ( config.contentPanel ) {
    this.setContentPanel( config.contentPanel );
  }
  this.setMenuPosition( config.menuPosition );
  this.toggleMenu( config.showMenu );
};

/* Setup */

OO.inheritClass( OO.ui.MenuLayout, OO.ui.Layout );

/* Methods */

/**
 * Toggle menu.
 *
 * @param {boolean} showMenu Show menu, omit to toggle
 * @chainable
 * @return {OO.ui.MenuLayout} The layout, for chaining
 */
OO.ui.MenuLayout.prototype.toggleMenu = function ( showMenu ) {
  showMenu = showMenu === undefined ? !this.showMenu : !!showMenu;

  if ( this.showMenu !== showMenu ) {
    this.showMenu = showMenu;
    this.$element
      .toggleClass( 'oo-ui-menuLayout-showMenu', this.showMenu )
      .toggleClass( 'oo-ui-menuLayout-hideMenu', !this.showMenu );
    this.$menu.attr( 'aria-hidden', this.showMenu ? 'false' : 'true' );
  }

  return this;
};

/**
 * Check if menu is visible
 *
 * @return {boolean} Menu is visible
 */
OO.ui.MenuLayout.prototype.isMenuVisible = function () {
  return this.showMenu;
};

/**
 * Set menu position.
 *
 * @param {string} position Position of menu, either `top`, `after`, `bottom` or `before`
 * @chainable
 * @return {OO.ui.MenuLayout} The layout, for chaining
 */
OO.ui.MenuLayout.prototype.setMenuPosition = function ( position ) {
  if ( [ 'top', 'bottom', 'before', 'after' ].indexOf( position ) === -1 ) {
    position = 'before';
  }

  this.$element.removeClass( 'oo-ui-menuLayout-' + this.menuPosition );
  this.menuPosition = position;
  if ( this.menuPosition === 'top' || this.menuPosition === 'before' ) {
    this.$element.append( this.$menu, this.$content );
  } else {
    this.$element.append( this.$content, this.$menu );
  }
  this.$element.addClass( 'oo-ui-menuLayout-' + position );

  return this;
};

/**
 * Get menu position.
 *
 * @return {string} Menu position
 */
OO.ui.MenuLayout.prototype.getMenuPosition = function () {
  return this.menuPosition;
};

/**
 * Set the menu panel.
 *
 * @param {OO.ui.PanelLayout} menuPanel Menu panel
 */
OO.ui.MenuLayout.prototype.setMenuPanel = function ( menuPanel ) {
  this.menuPanel = menuPanel;
  this.$menu.append( this.menuPanel.$element );
};

/**
 * Set the content panel.
 *
 * @param {OO.ui.PanelLayout} contentPanel Content panel
 */
OO.ui.MenuLayout.prototype.setContentPanel = function ( contentPanel ) {
  this.contentPanel = contentPanel;
  this.$content.append( this.contentPanel.$element );
};

/**
 * Clear the menu panel.
 */
OO.ui.MenuLayout.prototype.clearMenuPanel = function () {
  this.menuPanel = null;
  this.$menu.empty();
};

/**
 * Clear the content panel.
 */
OO.ui.MenuLayout.prototype.clearContentPanel = function () {
  this.contentPanel = null;
  this.$content.empty();
};

/**
 * Reset the scroll offset of all panels and the tab select widget
 *
 * @inheritdoc
 */
OO.ui.MenuLayout.prototype.resetScroll = function () {
  if ( this.menuPanel ) {
    this.menuPanel.resetScroll();
  }
  if ( this.contentPanel ) {
    this.contentPanel.resetScroll();
  }

  return this;
};

/**
 * BookletLayouts contain {@link OO.ui.PageLayout page layouts} as well as
 * an {@link OO.ui.OutlineSelectWidget outline} that allows users to easily navigate
 * through the pages and select which one to display. By default, only one page is
 * displayed at a time and the outline is hidden. When a user navigates to a new page,
 * the booklet layout automatically focuses on the first focusable element, unless the
 * default setting is changed. Optionally, booklets can be configured to show
 * {@link OO.ui.OutlineControlsWidget controls} for adding, moving, and removing items.
 *
 *     @example
 *     // Example of a BookletLayout that contains two PageLayouts.
 *
 *     function PageOneLayout( name, config ) {
 *         PageOneLayout.super.call( this, name, config );
 *         this.$element.append( '<p>First page</p><p>(This booklet has an outline, displayed on ' +
 *         'the left)</p>' );
 *     }
 *     OO.inheritClass( PageOneLayout, OO.ui.PageLayout );
 *     PageOneLayout.prototype.setupOutlineItem = function () {
 *         this.outlineItem.setLabel( 'Page One' );
 *     };
 *
 *     function PageTwoLayout( name, config ) {
 *         PageTwoLayout.super.call( this, name, config );
 *         this.$element.append( '<p>Second page</p>' );
 *     }
 *     OO.inheritClass( PageTwoLayout, OO.ui.PageLayout );
 *     PageTwoLayout.prototype.setupOutlineItem = function () {
 *         this.outlineItem.setLabel( 'Page Two' );
 *     };
 *
 *     var page1 = new PageOneLayout( 'one' ),
 *         page2 = new PageTwoLayout( 'two' );
 *
 *     var booklet = new OO.ui.BookletLayout( {
 *         outlined: true
 *     } );
 *
 *     booklet.addPages( [ page1, page2 ] );
 *     $( document.body ).append( booklet.$element );
 *
 * @class
 * @extends OO.ui.MenuLayout
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [continuous=false] Show all pages, one after another
 * @cfg {boolean} [autoFocus=true] Focus on the first focusable element when a new page is
 *  displayed. Disabled on mobile.
 * @cfg {boolean} [outlined=false] Show the outline. The outline is used to navigate through the
 *  pages of the booklet.
 * @cfg {boolean} [editable=false] Show controls for adding, removing and reordering pages.
 */
OO.ui.BookletLayout = function OoUiBookletLayout( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.BookletLayout.super.call( this, config );

  // Properties
  this.currentPageName = null;
  this.pages = {};
  this.ignoreFocus = false;
  this.stackLayout = new OO.ui.StackLayout( {
    continuous: !!config.continuous,
    expanded: this.expanded
  } );
  this.setContentPanel( this.stackLayout );
  this.autoFocus = config.autoFocus === undefined || !!config.autoFocus;
  this.outlineVisible = false;
  this.outlined = !!config.outlined;
  if ( this.outlined ) {
    this.editable = !!config.editable;
    this.outlineControlsWidget = null;
    this.outlineSelectWidget = new OO.ui.OutlineSelectWidget();
    this.outlinePanel = new OO.ui.PanelLayout( {
      expanded: this.expanded,
      scrollable: true
    } );
    this.setMenuPanel( this.outlinePanel );
    this.outlineVisible = true;
    if ( this.editable ) {
      this.outlineControlsWidget = new OO.ui.OutlineControlsWidget(
        this.outlineSelectWidget
      );
    }
  }
  this.toggleMenu( this.outlined );

  // Events
  this.stackLayout.connect( this, {
    set: 'onStackLayoutSet'
  } );
  if ( this.outlined ) {
    this.outlineSelectWidget.connect( this, {
      select: 'onOutlineSelectWidgetSelect'
    } );
    this.scrolling = false;
    this.stackLayout.connect( this, {
      visibleItemChange: 'onStackLayoutVisibleItemChange'
    } );
  }
  if ( this.autoFocus ) {
    // Event 'focus' does not bubble, but 'focusin' does
    this.stackLayout.$element.on( 'focusin', this.onStackLayoutFocus.bind( this ) );
  }

  // Initialization
  this.$element.addClass( 'oo-ui-bookletLayout' );
  this.stackLayout.$element.addClass( 'oo-ui-bookletLayout-stackLayout' );
  if ( this.outlined ) {
    this.outlinePanel.$element
      .addClass( 'oo-ui-bookletLayout-outlinePanel' )
      .append( this.outlineSelectWidget.$element );
    if ( this.editable ) {
      this.outlinePanel.$element
        .addClass( 'oo-ui-bookletLayout-outlinePanel-editable' )
        .append( this.outlineControlsWidget.$element );
    }
  }
};

/* Setup */

OO.inheritClass( OO.ui.BookletLayout, OO.ui.MenuLayout );

/* Events */

/**
 * A 'set' event is emitted when a page is {@link #setPage set} to be displayed by the
 * booklet layout.
 *
 * @event set
 * @param {OO.ui.PageLayout} page Current page
 */

/**
 * An 'add' event is emitted when pages are {@link #addPages added} to the booklet layout.
 *
 * @event add
 * @param {OO.ui.PageLayout[]} page Added pages
 * @param {number} index Index pages were added at
 */

/**
 * A 'remove' event is emitted when pages are {@link #clearPages cleared} or
 * {@link #removePages removed} from the booklet.
 *
 * @event remove
 * @param {OO.ui.PageLayout[]} pages Removed pages
 */

/* Methods */

/**
 * Handle stack layout focus.
 *
 * @private
 * @param {jQuery.Event} e Focusin event
 */
OO.ui.BookletLayout.prototype.onStackLayoutFocus = function ( e ) {
  var name, $target;

  // Find the page that an element was focused within
  $target = $( e.target ).closest( '.oo-ui-pageLayout' );
  for ( name in this.pages ) {
    // Check for page match, exclude current page to find only page changes
    if ( this.pages[ name ].$element[ 0 ] === $target[ 0 ] && name !== this.currentPageName ) {
      this.setPage( name );
      break;
    }
  }
};

/**
 * Handle visibleItemChange events from the stackLayout
 *
 * The next visible page is set as the current page by selecting it
 * in the outline
 *
 * @param {OO.ui.PageLayout} page The next visible page in the layout
 */
OO.ui.BookletLayout.prototype.onStackLayoutVisibleItemChange = function ( page ) {
  // Set a flag to so that the resulting call to #onStackLayoutSet doesn't
  // try and scroll the item into view again.
  this.scrolling = true;
  this.outlineSelectWidget.selectItemByData( page.getName() );
  this.scrolling = false;
};

/**
 * Handle stack layout set events.
 *
 * @private
 * @param {OO.ui.PanelLayout|null} page The page panel that is now the current panel
 */
OO.ui.BookletLayout.prototype.onStackLayoutSet = function ( page ) {
  var promise, layout = this;
  // If everything is unselected, do nothing
  if ( !page ) {
    return;
  }
  // For continuous BookletLayouts, scroll the selected page into view first
  if ( this.stackLayout.continuous && !this.scrolling ) {
    promise = page.scrollElementIntoView();
  } else {
    promise = $.Deferred().resolve();
  }
  // Focus the first element on the newly selected panel.
  // Don't focus if the page was set by scrolling.
  if ( this.autoFocus && !OO.ui.isMobile() && !this.scrolling ) {
    promise.done( function () {
      layout.focus();
    } );
  }
};

/**
 * Focus the first input in the current page.
 *
 * If no page is selected, the first selectable page will be selected.
 * If the focus is already in an element on the current page, nothing will happen.
 *
 * @param {number} [itemIndex] A specific item to focus on
 */
OO.ui.BookletLayout.prototype.focus = function ( itemIndex ) {
  var page,
    items = this.stackLayout.getItems();

  if ( itemIndex !== undefined && items[ itemIndex ] ) {
    page = items[ itemIndex ];
  } else {
    page = this.stackLayout.getCurrentItem();
  }

  if ( !page && this.outlined ) {
    this.selectFirstSelectablePage();
    page = this.stackLayout.getCurrentItem();
  }
  if ( !page ) {
    return;
  }
  // Only change the focus if is not already in the current page
  if ( !OO.ui.contains( page.$element[ 0 ], this.getElementDocument().activeElement, true ) ) {
    page.focus();
  }
};

/**
 * Find the first focusable input in the booklet layout and focus
 * on it.
 */
OO.ui.BookletLayout.prototype.focusFirstFocusable = function () {
  OO.ui.findFocusable( this.stackLayout.$element ).focus();
};

/**
 * Handle outline widget select events.
 *
 * @private
 * @param {OO.ui.OptionWidget|null} item Selected item
 */
OO.ui.BookletLayout.prototype.onOutlineSelectWidgetSelect = function ( item ) {
  if ( item ) {
    this.setPage( item.getData() );
  }
};

/**
 * Check if booklet has an outline.
 *
 * @return {boolean} Booklet has an outline
 */
OO.ui.BookletLayout.prototype.isOutlined = function () {
  return this.outlined;
};

/**
 * Check if booklet has editing controls.
 *
 * @return {boolean} Booklet is editable
 */
OO.ui.BookletLayout.prototype.isEditable = function () {
  return this.editable;
};

/**
 * Check if booklet has a visible outline.
 *
 * @return {boolean} Outline is visible
 */
OO.ui.BookletLayout.prototype.isOutlineVisible = function () {
  return this.outlined && this.outlineVisible;
};

/**
 * Hide or show the outline.
 *
 * @param {boolean} [show] Show outline, omit to invert current state
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.toggleOutline = function ( show ) {
  var booklet = this;

  if ( this.outlined ) {
    show = show === undefined ? !this.outlineVisible : !!show;
    this.outlineVisible = show;
    this.toggleMenu( show );
    if ( show && this.editable ) {
      // HACK: Kill dumb scrollbars when the sidebar stops animating, see T161798.
      // Only necessary when outline controls are present, delay matches transition on
      // `.oo-ui-menuLayout-menu`.
      setTimeout( function () {
        OO.ui.Element.static.reconsiderScrollbars( booklet.outlinePanel.$element[ 0 ] );
      }, OO.ui.theme.getDialogTransitionDuration() );
    }
  }

  return this;
};

/**
 * Find the page closest to the specified page.
 *
 * @param {OO.ui.PageLayout} page Page to use as a reference point
 * @return {OO.ui.PageLayout|null} Page closest to the specified page
 */
OO.ui.BookletLayout.prototype.findClosestPage = function ( page ) {
  var next, prev, level,
    pages = this.stackLayout.getItems(),
    index = pages.indexOf( page );

  if ( index !== -1 ) {
    next = pages[ index + 1 ];
    prev = pages[ index - 1 ];
    // Prefer adjacent pages at the same level
    if ( this.outlined ) {
      level = this.outlineSelectWidget.findItemFromData( page.getName() ).getLevel();
      if (
        prev &&
        level === this.outlineSelectWidget.findItemFromData( prev.getName() ).getLevel()
      ) {
        return prev;
      }
      if (
        next &&
        level === this.outlineSelectWidget.findItemFromData( next.getName() ).getLevel()
      ) {
        return next;
      }
    }
  }
  return prev || next || null;
};

/**
 * Get the outline widget.
 *
 * If the booklet is not outlined, the method will return `null`.
 *
 * @return {OO.ui.OutlineSelectWidget|null} Outline widget, or null if the booklet is not outlined
 */
OO.ui.BookletLayout.prototype.getOutline = function () {
  return this.outlineSelectWidget;
};

/**
 * Get the outline controls widget.
 *
 * If the outline is not editable, the method will return `null`.
 *
 * @return {OO.ui.OutlineControlsWidget|null} The outline controls widget.
 */
OO.ui.BookletLayout.prototype.getOutlineControls = function () {
  return this.outlineControlsWidget;
};

/**
 * Get a page by its symbolic name.
 *
 * @param {string} name Symbolic name of page
 * @return {OO.ui.PageLayout|undefined} Page, if found
 */
OO.ui.BookletLayout.prototype.getPage = function ( name ) {
  return this.pages[ name ];
};

/**
 * Get the current page.
 *
 * @return {OO.ui.PageLayout|undefined} Current page, if found
 */
OO.ui.BookletLayout.prototype.getCurrentPage = function () {
  var name = this.getCurrentPageName();
  return name ? this.getPage( name ) : undefined;
};

/**
 * Get the symbolic name of the current page.
 *
 * @return {string|null} Symbolic name of the current page
 */
OO.ui.BookletLayout.prototype.getCurrentPageName = function () {
  return this.currentPageName;
};

/**
 * Add pages to the booklet layout
 *
 * When pages are added with the same names as existing pages, the existing pages will be
 * automatically removed before the new pages are added.
 *
 * @param {OO.ui.PageLayout[]} pages Pages to add
 * @param {number} index Index of the insertion point
 * @fires add
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.addPages = function ( pages, index ) {
  var i, len, name, page, item, currentIndex,
    stackLayoutPages = this.stackLayout.getItems(),
    remove = [],
    items = [];

  // Remove pages with same names
  for ( i = 0, len = pages.length; i < len; i++ ) {
    page = pages[ i ];
    name = page.getName();

    if ( Object.prototype.hasOwnProperty.call( this.pages, name ) ) {
      // Correct the insertion index
      currentIndex = stackLayoutPages.indexOf( this.pages[ name ] );
      if ( currentIndex !== -1 && currentIndex + 1 < index ) {
        index--;
      }
      remove.push( this.pages[ name ] );
    }
  }
  if ( remove.length ) {
    this.removePages( remove );
  }

  // Add new pages
  for ( i = 0, len = pages.length; i < len; i++ ) {
    page = pages[ i ];
    name = page.getName();
    this.pages[ page.getName() ] = page;
    if ( this.outlined ) {
      item = new OO.ui.OutlineOptionWidget( { data: name } );
      page.setOutlineItem( item );
      items.push( item );
    }
  }

  if ( this.outlined && items.length ) {
    this.outlineSelectWidget.addItems( items, index );
    this.selectFirstSelectablePage();
  }
  this.stackLayout.addItems( pages, index );
  this.emit( 'add', pages, index );

  return this;
};

/**
 * Remove the specified pages from the booklet layout.
 *
 * To remove all pages from the booklet, you may wish to use the #clearPages method instead.
 *
 * @param {OO.ui.PageLayout[]} pages An array of pages to remove
 * @fires remove
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.removePages = function ( pages ) {
  var i, len, name, page,
    items = [];

  for ( i = 0, len = pages.length; i < len; i++ ) {
    page = pages[ i ];
    name = page.getName();
    delete this.pages[ name ];
    if ( this.outlined ) {
      items.push( this.outlineSelectWidget.findItemFromData( name ) );
      page.setOutlineItem( null );
    }
  }
  if ( this.outlined && items.length ) {
    this.outlineSelectWidget.removeItems( items );
    this.selectFirstSelectablePage();
  }
  this.stackLayout.removeItems( pages );
  this.emit( 'remove', pages );

  return this;
};

/**
 * Clear all pages from the booklet layout.
 *
 * To remove only a subset of pages from the booklet, use the #removePages method.
 *
 * @fires remove
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.clearPages = function () {
  var i, len,
    pages = this.stackLayout.getItems();

  this.pages = {};
  this.currentPageName = null;
  if ( this.outlined ) {
    this.outlineSelectWidget.clearItems();
    for ( i = 0, len = pages.length; i < len; i++ ) {
      pages[ i ].setOutlineItem( null );
    }
  }
  this.stackLayout.clearItems();

  this.emit( 'remove', pages );

  return this;
};

/**
 * Set the current page by symbolic name.
 *
 * @fires set
 * @param {string} name Symbolic name of page
 */
OO.ui.BookletLayout.prototype.setPage = function ( name ) {
  var selectedItem,
    $focused,
    page = this.pages[ name ],
    previousPage = this.currentPageName && this.pages[ this.currentPageName ];

  if ( name !== this.currentPageName ) {
    if ( this.outlined ) {
      selectedItem = this.outlineSelectWidget.findSelectedItem();
      if ( selectedItem && selectedItem.getData() !== name ) {
        this.outlineSelectWidget.selectItemByData( name );
      }
    }
    if ( page ) {
      if ( previousPage ) {
        previousPage.setActive( false );
        // Blur anything focused if the next page doesn't have anything focusable.
        // This is not needed if the next page has something focusable (because once it is
        // focused this blur happens automatically). If the layout is non-continuous, this
        // check is meaningless because the next page is not visible yet and thus can't
        // hold focus.
        if (
          this.autoFocus &&
          !OO.ui.isMobile() &&
          this.stackLayout.continuous &&
          OO.ui.findFocusable( page.$element ).length !== 0
        ) {
          $focused = previousPage.$element.find( ':focus' );
          if ( $focused.length ) {
            $focused[ 0 ].blur();
          }
        }
      }
      this.currentPageName = name;
      page.setActive( true );
      this.stackLayout.setItem( page );
      if ( !this.stackLayout.continuous && previousPage ) {
        // This should not be necessary, since any inputs on the previous page should have
        // been blurred when it was hidden, but browsers are not very consistent about
        // this.
        $focused = previousPage.$element.find( ':focus' );
        if ( $focused.length ) {
          $focused[ 0 ].blur();
        }
      }
      this.emit( 'set', page );
    }
  }
};

/**
 * For outlined-continuous booklets, also reset the outlineSelectWidget to the first item.
 *
 * @inheritdoc
 */
OO.ui.BookletLayout.prototype.resetScroll = function () {
  // Parent method
  OO.ui.BookletLayout.super.prototype.resetScroll.call( this );

  if (
    this.outlined &&
    this.stackLayout.continuous &&
    this.outlineSelectWidget.findFirstSelectableItem()
  ) {
    this.scrolling = true;
    this.outlineSelectWidget.selectItem( this.outlineSelectWidget.findFirstSelectableItem() );
    this.scrolling = false;
  }
  return this;
};

/**
 * Select the first selectable page.
 *
 * @chainable
 * @return {OO.ui.BookletLayout} The layout, for chaining
 */
OO.ui.BookletLayout.prototype.selectFirstSelectablePage = function () {
  if ( !this.outlineSelectWidget.findSelectedItem() ) {
    this.outlineSelectWidget.selectItem( this.outlineSelectWidget.findFirstSelectableItem() );
  }

  return this;
};

/**
 * IndexLayouts contain {@link OO.ui.TabPanelLayout tab panel layouts} as well as
 * {@link OO.ui.TabSelectWidget tabs} that allow users to easily navigate through the tab panels
 * and select which one to display. By default, only one tab panel is displayed at a time. When a
 * user navigates to a new tab panel, the index layout automatically focuses on the first focusable
 * element, unless the default setting is changed.
 *
 * TODO: This class is similar to BookletLayout, we may want to refactor to reduce duplication
 *
 *     @example
 *     // Example of a IndexLayout that contains two TabPanelLayouts.
 *
 *     function TabPanelOneLayout( name, config ) {
 *         TabPanelOneLayout.super.call( this, name, config );
 *         this.$element.append( '<p>First tab panel</p>' );
 *     }
 *     OO.inheritClass( TabPanelOneLayout, OO.ui.TabPanelLayout );
 *     TabPanelOneLayout.prototype.setupTabItem = function () {
 *         this.tabItem.setLabel( 'Tab panel one' );
 *     };
 *
 *     var tabPanel1 = new TabPanelOneLayout( 'one' ),
 *         tabPanel2 = new OO.ui.TabPanelLayout( 'two', { label: 'Tab panel two' } );
 *
 *     tabPanel2.$element.append( '<p>Second tab panel</p>' );
 *
 *     var index = new OO.ui.IndexLayout();
 *
 *     index.addTabPanels( [ tabPanel1, tabPanel2 ] );
 *     $( document.body ).append( index.$element );
 *
 * @class
 * @extends OO.ui.MenuLayout
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {OO.ui.StackLayout} [contentPanel] Content stack (see MenuLayout)
 * @cfg {boolean} [continuous=false] Show all tab panels, one after another
 * @cfg {boolean} [autoFocus=true] Focus on the first focusable element when a new tab panel is
 *  displayed. Disabled on mobile.
 * @cfg {boolean} [framed=true] Render the tabs with frames
 */
OO.ui.IndexLayout = function OoUiIndexLayout( config ) {
  // Configuration initialization
  config = $.extend( {}, config, { menuPosition: 'top' } );

  // Parent constructor
  OO.ui.IndexLayout.super.call( this, config );

  // Properties
  this.currentTabPanelName = null;
  // Allow infused widgets to pass existing tabPanels
  this.tabPanels = config.tabPanels || {};

  this.ignoreFocus = false;
  this.stackLayout = this.contentPanel || new OO.ui.StackLayout( {
    continuous: !!config.continuous,
    expanded: this.expanded
  } );
  this.setContentPanel( this.stackLayout );
  this.autoFocus = config.autoFocus === undefined || !!config.autoFocus;

  // Allow infused widgets to pass an existing tabSelectWidget
  this.tabSelectWidget = config.tabSelectWidget || new OO.ui.TabSelectWidget( {
    framed: config.framed === undefined || config.framed
  } );
  this.tabPanel = this.menuPanel || new OO.ui.PanelLayout( {
    expanded: this.expanded
  } );
  this.setMenuPanel( this.tabPanel );

  this.toggleMenu( true );

  // Events
  this.stackLayout.connect( this, {
    set: 'onStackLayoutSet'
  } );
  this.tabSelectWidget.connect( this, {
    select: 'onTabSelectWidgetSelect'
  } );
  if ( this.autoFocus ) {
    // Event 'focus' does not bubble, but 'focusin' does.
    this.stackLayout.$element.on( 'focusin', this.onStackLayoutFocus.bind( this ) );
  }

  // Initialization
  this.$element.addClass( 'oo-ui-indexLayout' );
  this.stackLayout.$element.addClass( 'oo-ui-indexLayout-stackLayout' );
  this.tabPanel.$element
    .addClass( 'oo-ui-indexLayout-tabPanel' )
    .append( this.tabSelectWidget.$element );

  this.selectFirstSelectableTabPanel();
};

/* Setup */

OO.inheritClass( OO.ui.IndexLayout, OO.ui.MenuLayout );

/* Events */

/**
 * A 'set' event is emitted when a tab panel is {@link #setTabPanel set} to be displayed by the
 * index layout.
 *
 * @event set
 * @param {OO.ui.TabPanelLayout} tabPanel Current tab panel
 */

/**
 * An 'add' event is emitted when tab panels are {@link #addTabPanels added} to the index layout.
 *
 * @event add
 * @param {OO.ui.TabPanelLayout[]} tabPanel Added tab panels
 * @param {number} index Index tab panels were added at
 */

/**
 * A 'remove' event is emitted when tab panels are {@link #clearTabPanels cleared} or
 * {@link #removeTabPanels removed} from the index.
 *
 * @event remove
 * @param {OO.ui.TabPanelLayout[]} tabPanel Removed tab panels
 */

/* Methods */

/**
 * Handle stack layout focus.
 *
 * @private
 * @param {jQuery.Event} e Focusing event
 */
OO.ui.IndexLayout.prototype.onStackLayoutFocus = function ( e ) {
  var name, $target;

  // Find the tab panel that an element was focused within
  $target = $( e.target ).closest( '.oo-ui-tabPanelLayout' );
  for ( name in this.tabPanels ) {
    // Check for tab panel match, exclude current tab panel to find only tab panel changes
    if ( this.tabPanels[ name ].$element[ 0 ] === $target[ 0 ] &&
        name !== this.currentTabPanelName ) {
      this.setTabPanel( name );
      break;
    }
  }
};

/**
 * Handle stack layout set events.
 *
 * @private
 * @param {OO.ui.PanelLayout|null} tabPanel The tab panel that is now the current panel
 */
OO.ui.IndexLayout.prototype.onStackLayoutSet = function ( tabPanel ) {
  // If everything is unselected, do nothing
  if ( !tabPanel ) {
    return;
  }
  // Focus the first element on the newly selected panel
  if ( this.autoFocus && !OO.ui.isMobile() ) {
    this.focus();
  }
};

/**
 * Focus the first input in the current tab panel.
 *
 * If no tab panel is selected, the first selectable tab panel will be selected.
 * If the focus is already in an element on the current tab panel, nothing will happen.
 *
 * @param {number} [itemIndex] A specific item to focus on
 */
OO.ui.IndexLayout.prototype.focus = function ( itemIndex ) {
  var tabPanel,
    items = this.stackLayout.getItems();

  if ( itemIndex !== undefined && items[ itemIndex ] ) {
    tabPanel = items[ itemIndex ];
  } else {
    tabPanel = this.stackLayout.getCurrentItem();
  }

  if ( !tabPanel ) {
    this.selectFirstSelectableTabPanel();
    tabPanel = this.stackLayout.getCurrentItem();
  }
  if ( !tabPanel ) {
    return;
  }
  // Only change the focus if is not already in the current page
  if ( !OO.ui.contains(
    tabPanel.$element[ 0 ],
    this.getElementDocument().activeElement,
    true
  ) ) {
    tabPanel.focus();
  }
};

/**
 * Find the first focusable input in the index layout and focus
 * on it.
 */
OO.ui.IndexLayout.prototype.focusFirstFocusable = function () {
  OO.ui.findFocusable( this.stackLayout.$element ).focus();
};

/**
 * Handle tab widget select events.
 *
 * @private
 * @param {OO.ui.OptionWidget|null} item Selected item
 */
OO.ui.IndexLayout.prototype.onTabSelectWidgetSelect = function ( item ) {
  if ( item ) {
    this.setTabPanel( item.getData() );
  }
};

/**
 * Get the tab panel closest to the specified tab panel.
 *
 * @param {OO.ui.TabPanelLayout} tabPanel Tab panel to use as a reference point
 * @return {OO.ui.TabPanelLayout|null} Tab panel closest to the specified
 */
OO.ui.IndexLayout.prototype.getClosestTabPanel = function ( tabPanel ) {
  var next, prev, level,
    tabPanels = this.stackLayout.getItems(),
    index = tabPanels.indexOf( tabPanel );

  if ( index !== -1 ) {
    next = tabPanels[ index + 1 ];
    prev = tabPanels[ index - 1 ];
    // Prefer adjacent tab panels at the same level
    level = this.tabSelectWidget.findItemFromData( tabPanel.getName() ).getLevel();
    if (
      prev &&
      level === this.tabSelectWidget.findItemFromData( prev.getName() ).getLevel()
    ) {
      return prev;
    }
    if (
      next &&
      level === this.tabSelectWidget.findItemFromData( next.getName() ).getLevel()
    ) {
      return next;
    }
  }
  return prev || next || null;
};

/**
 * Get the tabs widget.
 *
 * @return {OO.ui.TabSelectWidget} Tabs widget
 */
OO.ui.IndexLayout.prototype.getTabs = function () {
  return this.tabSelectWidget;
};

/**
 * Get a tab panel by its symbolic name.
 *
 * @param {string} name Symbolic name of tab panel
 * @return {OO.ui.TabPanelLayout|undefined} Tab panel, if found
 */
OO.ui.IndexLayout.prototype.getTabPanel = function ( name ) {
  return this.tabPanels[ name ];
};

/**
 * Get the current tab panel.
 *
 * @return {OO.ui.TabPanelLayout|undefined} Current tab panel, if found
 */
OO.ui.IndexLayout.prototype.getCurrentTabPanel = function () {
  var name = this.getCurrentTabPanelName();
  return name ? this.getTabPanel( name ) : undefined;
};

/**
 * Get the symbolic name of the current tab panel.
 *
 * @return {string|null} Symbolic name of the current tab panel
 */
OO.ui.IndexLayout.prototype.getCurrentTabPanelName = function () {
  return this.currentTabPanelName;
};

/**
 * Add tab panels to the index layout.
 *
 * When tab panels are added with the same names as existing tab panels, the existing tab panels
 * will be automatically removed before the new tab panels are added.
 *
 * @param {OO.ui.TabPanelLayout[]} tabPanels Tab panels to add
 * @param {number} index Index of the insertion point
 * @fires add
 * @chainable
 * @return {OO.ui.IndexLayout} The layout, for chaining
 */
OO.ui.IndexLayout.prototype.addTabPanels = function ( tabPanels, index ) {
  var i, len, name, tabPanel, tabItem, currentIndex,
    stackLayoutTabPanels = this.stackLayout.getItems(),
    remove = [],
    tabItems = [];

  // Remove tab panels with same names
  for ( i = 0, len = tabPanels.length; i < len; i++ ) {
    tabPanel = tabPanels[ i ];
    name = tabPanel.getName();

    if ( Object.prototype.hasOwnProperty.call( this.tabPanels, name ) ) {
      // Correct the insertion index
      currentIndex = stackLayoutTabPanels.indexOf( this.tabPanels[ name ] );
      if ( currentIndex !== -1 && currentIndex + 1 < index ) {
        index--;
      }
      remove.push( this.tabPanels[ name ] );
    }
  }
  if ( remove.length ) {
    this.removeTabPanels( remove );
  }

  // Add new tab panels
  for ( i = 0, len = tabPanels.length; i < len; i++ ) {
    tabPanel = tabPanels[ i ];
    name = tabPanel.getName();
    this.tabPanels[ name ] = tabPanel;
    tabItem = new OO.ui.TabOptionWidget(
      $.extend( { data: name }, tabPanel.getTabItemConfig() )
    );
    tabPanel.setTabItem( tabItem );
    tabItems.push( tabItem );
  }

  if ( tabItems.length ) {
    this.tabSelectWidget.addItems( tabItems, index );
    this.selectFirstSelectableTabPanel();
  }
  this.stackLayout.addItems( tabPanels, index );
  this.emit( 'add', tabPanels, index );

  return this;
};

/**
 * Remove the specified tab panels from the index layout.
 *
 * To remove all tab panels from the index, you may wish to use the #clearTabPanels method instead.
 *
 * @param {OO.ui.TabPanelLayout[]} tabPanels An array of tab panels to remove
 * @fires remove
 * @chainable
 * @return {OO.ui.IndexLayout} The layout, for chaining
 */
OO.ui.IndexLayout.prototype.removeTabPanels = function ( tabPanels ) {
  var i, len, name, tabPanel,
    items = [];

  for ( i = 0, len = tabPanels.length; i < len; i++ ) {
    tabPanel = tabPanels[ i ];
    name = tabPanel.getName();
    delete this.tabPanels[ name ];
    items.push( this.tabSelectWidget.findItemFromData( name ) );
    tabPanel.setTabItem( null );
  }
  if ( items.length ) {
    this.tabSelectWidget.removeItems( items );
    this.selectFirstSelectableTabPanel();
  }
  this.stackLayout.removeItems( tabPanels );
  this.emit( 'remove', tabPanels );

  return this;
};

/**
 * Clear all tab panels from the index layout.
 *
 * To remove only a subset of tab panels from the index, use the #removeTabPanels method.
 *
 * @fires remove
 * @chainable
 * @return {OO.ui.IndexLayout} The layout, for chaining
 */
OO.ui.IndexLayout.prototype.clearTabPanels = function () {
  var i, len,
    tabPanels = this.stackLayout.getItems();

  this.tabPanels = {};
  this.currentTabPanelName = null;
  this.tabSelectWidget.clearItems();
  for ( i = 0, len = tabPanels.length; i < len; i++ ) {
    tabPanels[ i ].setTabItem( null );
  }
  this.stackLayout.clearItems();

  this.emit( 'remove', tabPanels );

  return this;
};

/**
 * Set the current tab panel by symbolic name.
 *
 * @fires set
 * @param {string} name Symbolic name of tab panel
 */
OO.ui.IndexLayout.prototype.setTabPanel = function ( name ) {
  var selectedItem,
    $focused,
    previousTabPanel,
    tabPanel;

  if ( name !== this.currentTabPanelName ) {
    tabPanel = this.getTabPanel( name );
    previousTabPanel = this.getCurrentTabPanel();
    selectedItem = this.tabSelectWidget.findSelectedItem();
    if ( !selectedItem || selectedItem.getData() !== name ) {
      this.tabSelectWidget.selectItemByData( name );
    }
    if ( tabPanel ) {
      if ( previousTabPanel ) {
        previousTabPanel.setActive( false );
        // Blur anything focused if the next tab panel doesn't have anything focusable.
        // This is not needed if the next tab panel has something focusable (because once
        // it is focused this blur happens automatically). If the layout is non-continuous,
        // this check is meaningless because the next tab panel is not visible yet and thus
        // can't hold focus.
        if (
          this.autoFocus &&
          !OO.ui.isMobile() &&
          this.stackLayout.continuous &&
          OO.ui.findFocusable( tabPanel.$element ).length !== 0
        ) {
          $focused = previousTabPanel.$element.find( ':focus' );
          if ( $focused.length ) {
            $focused[ 0 ].blur();
          }
        }
      }
      this.currentTabPanelName = name;
      tabPanel.setActive( true );
      this.stackLayout.setItem( tabPanel );
      if ( !this.stackLayout.continuous && previousTabPanel ) {
        // This should not be necessary, since any inputs on the previous tab panel should
        // have been blurred when it was hidden, but browsers are not very consistent about
        // this.
        $focused = previousTabPanel.$element.find( ':focus' );
        if ( $focused.length ) {
          $focused[ 0 ].blur();
        }
      }
      this.emit( 'set', tabPanel );
    }
  }
};

/**
 * Select the first selectable tab panel.
 *
 * @chainable
 * @return {OO.ui.IndexLayout} The layout, for chaining
 */
OO.ui.IndexLayout.prototype.selectFirstSelectableTabPanel = function () {
  if ( !this.tabSelectWidget.findSelectedItem() ) {
    this.tabSelectWidget.selectItem( this.tabSelectWidget.findFirstSelectableItem() );
  }

  return this;
};

/**
 * ToggleWidget implements basic behavior of widgets with an on/off state.
 * Please see OO.ui.ToggleButtonWidget and OO.ui.ToggleSwitchWidget for examples.
 *
 * @abstract
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [value=false] The toggle’s initial on/off state.
 *  By default, the toggle is in the 'off' state.
 */
OO.ui.ToggleWidget = function OoUiToggleWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.ToggleWidget.super.call( this, config );

  // Mixin constructor
  OO.ui.mixin.TitledElement.call( this, config );

  // Properties
  this.value = null;

  // Initialization
  this.$element.addClass( 'oo-ui-toggleWidget' );
  this.setValue( !!config.value );
};

/* Setup */

OO.inheritClass( OO.ui.ToggleWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.ToggleWidget, OO.ui.mixin.TitledElement );

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the on/off state of the toggle changes.
 *
 * @param {boolean} value Value representing the new state of the toggle
 */

/* Methods */

/**
 * Get the value representing the toggle’s state.
 *
 * @return {boolean} The on/off state of the toggle
 */
OO.ui.ToggleWidget.prototype.getValue = function () {
  return this.value;
};

/**
 * Set the state of the toggle: `true` for 'on', `false` for 'off'.
 *
 * @param {boolean} value The state of the toggle
 * @fires change
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.ToggleWidget.prototype.setValue = function ( value ) {
  value = !!value;
  if ( this.value !== value ) {
    this.value = value;
    this.emit( 'change', value );
    this.$element.toggleClass( 'oo-ui-toggleWidget-on', value );
    this.$element.toggleClass( 'oo-ui-toggleWidget-off', !value );
  }
  return this;
};

/**
 * ToggleButtons are buttons that have a state (‘on’ or ‘off’) that is represented by a
 * Boolean value. Like other {@link OO.ui.ButtonWidget buttons}, toggle buttons can be
 * configured with {@link OO.ui.mixin.IconElement icons},
 * {@link OO.ui.mixin.IndicatorElement indicators},
 * {@link OO.ui.mixin.TitledElement titles}, {@link OO.ui.mixin.FlaggedElement styling flags},
 * and {@link OO.ui.mixin.LabelElement labels}. Please see
 * the [OOUI documentation][1] on MediaWiki for more information.
 *
 *     @example
 *     // Toggle buttons in the 'off' and 'on' state.
 *     var toggleButton1 = new OO.ui.ToggleButtonWidget( {
 *             label: 'Toggle Button off'
 *         } ),
 *         toggleButton2 = new OO.ui.ToggleButtonWidget( {
 *             label: 'Toggle Button on',
 *             value: true
 *         } );
 *     // Append the buttons to the DOM.
 *     $( document.body ).append( toggleButton1.$element, toggleButton2.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Buttons_and_Switches#Toggle_buttons
 *
 * @class
 * @extends OO.ui.ToggleWidget
 * @mixins OO.ui.mixin.ButtonElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [value=false] The toggle button’s initial on/off
 *  state. By default, the button is in the 'off' state.
 */
OO.ui.ToggleButtonWidget = function OoUiToggleButtonWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.ToggleButtonWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.ButtonElement.call( this, $.extend( {
    active: this.active
  }, config ) );
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.IndicatorElement.call( this, config );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.FlaggedElement.call( this, config );
  OO.ui.mixin.TabIndexedElement.call( this, $.extend( {
    $tabIndexed: this.$button
  }, config ) );

  // Events
  this.connect( this, {
    click: 'onAction'
  } );

  // Initialization
  this.$button.append( this.$icon, this.$label, this.$indicator );
  this.$element
    .addClass( 'oo-ui-toggleButtonWidget' )
    .append( this.$button );
  this.setTitledElement( this.$button );
};

/* Setup */

OO.inheritClass( OO.ui.ToggleButtonWidget, OO.ui.ToggleWidget );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.ButtonElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.ToggleButtonWidget, OO.ui.mixin.TabIndexedElement );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.ToggleButtonWidget.static.tagName = 'span';

/* Methods */

/**
 * Handle the button action being triggered.
 *
 * @private
 */
OO.ui.ToggleButtonWidget.prototype.onAction = function () {
  this.setValue( !this.value );
};

/**
 * @inheritdoc
 */
OO.ui.ToggleButtonWidget.prototype.setValue = function ( value ) {
  value = !!value;
  if ( value !== this.value ) {
    // Might be called from parent constructor before ButtonElement constructor
    if ( this.$button ) {
      this.$button.attr( 'aria-pressed', value.toString() );
    }
    this.setActive( value );
  }

  // Parent method
  OO.ui.ToggleButtonWidget.super.prototype.setValue.call( this, value );

  return this;
};

/**
 * @inheritdoc
 */
OO.ui.ToggleButtonWidget.prototype.setButtonElement = function ( $button ) {
  if ( this.$button ) {
    this.$button.removeAttr( 'aria-pressed' );
  }
  OO.ui.mixin.ButtonElement.prototype.setButtonElement.call( this, $button );
  this.$button.attr( 'aria-pressed', this.value.toString() );
};

/**
 * ToggleSwitches are switches that slide on and off. Their state is represented by a Boolean
 * value (`true` for ‘on’, and `false` otherwise, the default). The ‘off’ state is represented
 * visually by a slider in the leftmost position.
 *
 *     @example
 *     // Toggle switches in the 'off' and 'on' position.
 *     var toggleSwitch1 = new OO.ui.ToggleSwitchWidget(),
 *         toggleSwitch2 = new OO.ui.ToggleSwitchWidget( {
 *             value: true
 *         } );
 *         // Create a FieldsetLayout to layout and label switches.
 *         fieldset = new OO.ui.FieldsetLayout( {
 *             label: 'Toggle switches'
 *         } );
 *     fieldset.addItems( [
 *         new OO.ui.FieldLayout( toggleSwitch1, {
 *             label: 'Off',
 *             align: 'top'
 *         } ),
 *         new OO.ui.FieldLayout( toggleSwitch2, {
 *             label: 'On',
 *             align: 'top'
 *         } )
 *     ] );
 *     $( document.body ).append( fieldset.$element );
 *
 * @class
 * @extends OO.ui.ToggleWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [value=false] The toggle switch’s initial on/off state.
 *  By default, the toggle switch is in the 'off' position.
 */
OO.ui.ToggleSwitchWidget = function OoUiToggleSwitchWidget( config ) {
  // Parent constructor
  OO.ui.ToggleSwitchWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.TabIndexedElement.call( this, config );

  // Properties
  this.dragging = false;
  this.dragStart = null;
  this.sliding = false;
  this.$glow = $( '<span>' );
  this.$grip = $( '<span>' );

  // Events
  this.$element.on( {
    click: this.onClick.bind( this ),
    keypress: this.onKeyPress.bind( this )
  } );

  // Initialization
  this.$glow.addClass( 'oo-ui-toggleSwitchWidget-glow' );
  this.$grip.addClass( 'oo-ui-toggleSwitchWidget-grip' );
  this.$element
    .addClass( 'oo-ui-toggleSwitchWidget' )
    .attr( 'role', 'checkbox' )
    .append( this.$glow, this.$grip );
};

/* Setup */

OO.inheritClass( OO.ui.ToggleSwitchWidget, OO.ui.ToggleWidget );
OO.mixinClass( OO.ui.ToggleSwitchWidget, OO.ui.mixin.TabIndexedElement );

/* Methods */

/**
 * Handle mouse click events.
 *
 * @private
 * @param {jQuery.Event} e Mouse click event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.ToggleSwitchWidget.prototype.onClick = function ( e ) {
  if ( !this.isDisabled() && e.which === OO.ui.MouseButtons.LEFT ) {
    this.setValue( !this.value );
  }
  return false;
};

/**
 * Handle key press events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.ToggleSwitchWidget.prototype.onKeyPress = function ( e ) {
  if ( !this.isDisabled() && ( e.which === OO.ui.Keys.SPACE || e.which === OO.ui.Keys.ENTER ) ) {
    this.setValue( !this.value );
    return false;
  }
};

/**
 * @inheritdoc
 */
OO.ui.ToggleSwitchWidget.prototype.setValue = function ( value ) {
  OO.ui.ToggleSwitchWidget.super.prototype.setValue.call( this, value );
  this.$element.attr( 'aria-checked', this.value.toString() );
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.ToggleSwitchWidget.prototype.simulateLabelClick = function () {
  if ( !this.isDisabled() ) {
    this.setValue( !this.value );
  }
  this.focus();
};

/**
 * OutlineControlsWidget is a set of controls for an
 * {@link OO.ui.OutlineSelectWidget outline select widget}.
 * Controls include moving items up and down, removing items, and adding different kinds of items.
 *
 * **Currently, this class is only used by {@link OO.ui.BookletLayout booklet layouts}.**
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupElement
 *
 * @constructor
 * @param {OO.ui.OutlineSelectWidget} outline Outline to control
 * @param {Object} [config] Configuration options
 * @cfg {Object} [abilities] List of abilties
 * @cfg {boolean} [abilities.move=true] Allow moving movable items
 * @cfg {boolean} [abilities.remove=true] Allow removing removable items
 */
OO.ui.OutlineControlsWidget = function OoUiOutlineControlsWidget( outline, config ) {
  // Allow passing positional parameters inside the config object
  if ( OO.isPlainObject( outline ) && config === undefined ) {
    config = outline;
    outline = config.outline;
  }

  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.OutlineControlsWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.GroupElement.call( this, config );

  // Properties
  this.outline = outline;
  this.$movers = $( '<div>' );
  this.upButton = new OO.ui.ButtonWidget( {
    framed: false,
    icon: 'collapse',
    title: OO.ui.msg( 'ooui-outline-control-move-up' )
  } );
  this.downButton = new OO.ui.ButtonWidget( {
    framed: false,
    icon: 'expand',
    title: OO.ui.msg( 'ooui-outline-control-move-down' )
  } );
  this.removeButton = new OO.ui.ButtonWidget( {
    framed: false,
    icon: 'trash',
    title: OO.ui.msg( 'ooui-outline-control-remove' )
  } );
  this.abilities = { move: true, remove: true };

  // Events
  outline.connect( this, {
    select: 'onOutlineChange',
    add: 'onOutlineChange',
    remove: 'onOutlineChange'
  } );
  this.upButton.connect( this, {
    click: [ 'emit', 'move', -1 ]
  } );
  this.downButton.connect( this, {
    click: [ 'emit', 'move', 1 ]
  } );
  this.removeButton.connect( this, {
    click: [ 'emit', 'remove' ]
  } );

  // Initialization
  this.$element.addClass( 'oo-ui-outlineControlsWidget' );
  this.$group.addClass( 'oo-ui-outlineControlsWidget-items' );
  this.$movers
    .addClass( 'oo-ui-outlineControlsWidget-movers' )
    .append( this.upButton.$element, this.downButton.$element, this.removeButton.$element );
  this.$element.append( this.$icon, this.$group, this.$movers );
  this.setAbilities( config.abilities || {} );
};

/* Setup */

OO.inheritClass( OO.ui.OutlineControlsWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.OutlineControlsWidget, OO.ui.mixin.GroupElement );

/* Events */

/**
 * @event move
 * @param {number} places Number of places to move
 */

/**
 * @event remove
 */

/* Methods */

/**
 * Set abilities.
 *
 * @param {Object} abilities List of abilties
 * @param {boolean} [abilities.move] Allow moving movable items
 * @param {boolean} [abilities.remove] Allow removing removable items
 */
OO.ui.OutlineControlsWidget.prototype.setAbilities = function ( abilities ) {
  var ability;

  for ( ability in this.abilities ) {
    if ( abilities[ ability ] !== undefined ) {
      this.abilities[ ability ] = !!abilities[ ability ];
    }
  }

  this.onOutlineChange();
};

/**
 * Handle outline change events.
 *
 * @private
 */
OO.ui.OutlineControlsWidget.prototype.onOutlineChange = function () {
  var i, len, firstMovable, lastMovable,
    items = this.outline.getItems(),
    selectedItem = this.outline.findSelectedItem(),
    movable = this.abilities.move && selectedItem && selectedItem.isMovable(),
    removable = this.abilities.remove && selectedItem && selectedItem.isRemovable();

  if ( movable ) {
    i = -1;
    len = items.length;
    while ( ++i < len ) {
      if ( items[ i ].isMovable() ) {
        firstMovable = items[ i ];
        break;
      }
    }
    i = len;
    while ( i-- ) {
      if ( items[ i ].isMovable() ) {
        lastMovable = items[ i ];
        break;
      }
    }
  }
  this.upButton.setDisabled( !movable || selectedItem === firstMovable );
  this.downButton.setDisabled( !movable || selectedItem === lastMovable );
  this.removeButton.setDisabled( !removable );
};

/**
 * OutlineOptionWidget is an item in an {@link OO.ui.OutlineSelectWidget OutlineSelectWidget}.
 *
 * Currently, this class is only used by {@link OO.ui.BookletLayout booklet layouts}, which contain
 * {@link OO.ui.PageLayout page layouts}. See {@link OO.ui.BookletLayout BookletLayout}
 * for an example.
 *
 * @class
 * @extends OO.ui.DecoratedOptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {number} [level] Indentation level
 * @cfg {boolean} [movable] Allow modification from
 *  {@link OO.ui.OutlineControlsWidget outline controls}.
 */
OO.ui.OutlineOptionWidget = function OoUiOutlineOptionWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.OutlineOptionWidget.super.call( this, config );

  // Properties
  this.level = 0;
  this.movable = !!config.movable;
  this.removable = !!config.removable;

  // Initialization
  this.$element.addClass( 'oo-ui-outlineOptionWidget' );
  this.setLevel( config.level );
};

/* Setup */

OO.inheritClass( OO.ui.OutlineOptionWidget, OO.ui.DecoratedOptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.OutlineOptionWidget.static.highlightable = true;

/**
 * @static
 * @inheritdoc
 */
OO.ui.OutlineOptionWidget.static.scrollIntoViewOnSelect = true;

/**
 * @static
 * @inheritable
 * @property {string}
 */
OO.ui.OutlineOptionWidget.static.levelClass = 'oo-ui-outlineOptionWidget-level-';

/**
 * @static
 * @inheritable
 * @property {number}
 */
OO.ui.OutlineOptionWidget.static.levels = 3;

/* Methods */

/**
 * Check if item is movable.
 *
 * Movability is used by {@link OO.ui.OutlineControlsWidget outline controls}.
 *
 * @return {boolean} Item is movable
 */
OO.ui.OutlineOptionWidget.prototype.isMovable = function () {
  return this.movable;
};

/**
 * Check if item is removable.
 *
 * Removability is used by {@link OO.ui.OutlineControlsWidget outline controls}.
 *
 * @return {boolean} Item is removable
 */
OO.ui.OutlineOptionWidget.prototype.isRemovable = function () {
  return this.removable;
};

/**
 * Get indentation level.
 *
 * @return {number} Indentation level
 */
OO.ui.OutlineOptionWidget.prototype.getLevel = function () {
  return this.level;
};

/**
 * @inheritdoc
 */
OO.ui.OutlineOptionWidget.prototype.setPressed = function ( state ) {
  OO.ui.OutlineOptionWidget.super.prototype.setPressed.call( this, state );
  return this;
};

/**
 * Set movability.
 *
 * Movability is used by {@link OO.ui.OutlineControlsWidget outline controls}.
 *
 * @param {boolean} movable Item is movable
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OutlineOptionWidget.prototype.setMovable = function ( movable ) {
  this.movable = !!movable;
  this.updateThemeClasses();
  return this;
};

/**
 * Set removability.
 *
 * Removability is used by {@link OO.ui.OutlineControlsWidget outline controls}.
 *
 * @param {boolean} removable Item is removable
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OutlineOptionWidget.prototype.setRemovable = function ( removable ) {
  this.removable = !!removable;
  this.updateThemeClasses();
  return this;
};

/**
 * @inheritdoc
 */
OO.ui.OutlineOptionWidget.prototype.setSelected = function ( state ) {
  OO.ui.OutlineOptionWidget.super.prototype.setSelected.call( this, state );
  return this;
};

/**
 * Set indentation level.
 *
 * @param {number} [level=0] Indentation level, in the range of [0,#maxLevel]
 * @chainable
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.OutlineOptionWidget.prototype.setLevel = function ( level ) {
  var levels = this.constructor.static.levels,
    levelClass = this.constructor.static.levelClass,
    i = levels;

  this.level = level ? Math.max( 0, Math.min( levels - 1, level ) ) : 0;
  while ( i-- ) {
    if ( this.level === i ) {
      this.$element.addClass( levelClass + i );
    } else {
      this.$element.removeClass( levelClass + i );
    }
  }
  this.updateThemeClasses();

  return this;
};

/**
 * OutlineSelectWidget is a structured list that contains
 * {@link OO.ui.OutlineOptionWidget outline options}
 * A set of controls can be provided with an {@link OO.ui.OutlineControlsWidget outline controls}
 * widget.
 *
 * **Currently, this class is only used by {@link OO.ui.BookletLayout booklet layouts}.**
 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.OutlineSelectWidget = function OoUiOutlineSelectWidget( config ) {
  // Parent constructor
  OO.ui.OutlineSelectWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.TabIndexedElement.call( this, config );

  // Events
  this.$element.on( {
    focus: this.bindDocumentKeyDownListener.bind( this ),
    blur: this.unbindDocumentKeyDownListener.bind( this )
  } );

  // Initialization
  this.$element.addClass( 'oo-ui-outlineSelectWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.OutlineSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.OutlineSelectWidget, OO.ui.mixin.TabIndexedElement );

/**
 * ButtonOptionWidget is a special type of {@link OO.ui.mixin.ButtonElement button element} that
 * can be selected and configured with data. The class is
 * used with OO.ui.ButtonSelectWidget to create a selection of button options. Please see the
 * [OOUI documentation on MediaWiki] [1] for more information.
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options#Button_selects_and_options
 *
 * @class
 * @extends OO.ui.OptionWidget
 * @mixins OO.ui.mixin.ButtonElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.IndicatorElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.ButtonOptionWidget = function OoUiButtonOptionWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.ButtonOptionWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.ButtonElement.call( this, config );
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.IndicatorElement.call( this, config );

  // Initialization
  this.$element.addClass( 'oo-ui-buttonOptionWidget' );
  this.$button.append( this.$icon, this.$label, this.$indicator );
  this.$element.append( this.$button );
  this.setTitledElement( this.$button );
};

/* Setup */

OO.inheritClass( OO.ui.ButtonOptionWidget, OO.ui.OptionWidget );
OO.mixinClass( OO.ui.ButtonOptionWidget, OO.ui.mixin.ButtonElement );
OO.mixinClass( OO.ui.ButtonOptionWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.ButtonOptionWidget, OO.ui.mixin.IndicatorElement );

/* Static Properties */

/**
 * Allow button mouse down events to pass through so they can be handled by the parent select widget
 *
 * @static
 * @inheritdoc
 */
OO.ui.ButtonOptionWidget.static.cancelButtonMouseDownEvents = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.ButtonOptionWidget.static.highlightable = false;

/* Methods */

/**
 * @inheritdoc
 */
OO.ui.ButtonOptionWidget.prototype.setSelected = function ( state ) {
  OO.ui.ButtonOptionWidget.super.prototype.setSelected.call( this, state );

  if ( this.constructor.static.selectable ) {
    this.setActive( state );
  }

  return this;
};

/**
 * ButtonSelectWidget is a {@link OO.ui.SelectWidget select widget} that contains
 * button options and is used together with
 * OO.ui.ButtonOptionWidget. The ButtonSelectWidget provides an interface for
 * highlighting, choosing, and selecting mutually exclusive options. Please see
 * the [OOUI documentation on MediaWiki] [1] for more information.
 *
 *     @example
 *     // A ButtonSelectWidget that contains three ButtonOptionWidgets.
 *     var option1 = new OO.ui.ButtonOptionWidget( {
 *             data: 1,
 *             label: 'Option 1',
 *             title: 'Button option 1'
 *         } ),
 *         option2 = new OO.ui.ButtonOptionWidget( {
 *             data: 2,
 *             label: 'Option 2',
 *             title: 'Button option 2'
 *         } ),
 *         option3 = new OO.ui.ButtonOptionWidget( {
 *             data: 3,
 *             label: 'Option 3',
 *             title: 'Button option 3'
 *         } ),
 *         buttonSelect = new OO.ui.ButtonSelectWidget( {
 *             items: [ option1, option2, option3 ]
 *         } );
 *     $( document.body ).append( buttonSelect.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets/Selects_and_Options
 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 */
OO.ui.ButtonSelectWidget = function OoUiButtonSelectWidget( config ) {
  // Parent constructor
  OO.ui.ButtonSelectWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.TabIndexedElement.call( this, config );

  // Events
  this.$element.on( {
    focus: this.bindDocumentKeyDownListener.bind( this ),
    blur: this.unbindDocumentKeyDownListener.bind( this )
  } );

  // Initialization
  this.$element.addClass( 'oo-ui-buttonSelectWidget' );
};

/* Setup */

OO.inheritClass( OO.ui.ButtonSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.ButtonSelectWidget, OO.ui.mixin.TabIndexedElement );

/**
 * TabOptionWidget is an item in a {@link OO.ui.TabSelectWidget TabSelectWidget}.
 *
 * Currently, this class is only used by {@link OO.ui.IndexLayout index layouts}, which contain
 * {@link OO.ui.TabPanelLayout tab panel layouts}. See {@link OO.ui.IndexLayout IndexLayout}
 * for an example.
 *
 * @class
 * @extends OO.ui.OptionWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [href] Hyperlink to add to TabOption. Mostly used in OOUI PHP.
 */
OO.ui.TabOptionWidget = function OoUiTabOptionWidget( config ) {
  // Configuration initialization
  config = config || {};

  if ( config.href ) {
    config = $.extend( {
      $label: $( '<a>' ).attr( 'href', config.href )
    }, config );
  }

  // Parent constructor
  OO.ui.TabOptionWidget.super.call( this, config );

  // Initialization
  this.$element
    .addClass( 'oo-ui-tabOptionWidget' )
    .attr( 'role', 'tab' );
};

/* Setup */

OO.inheritClass( OO.ui.TabOptionWidget, OO.ui.OptionWidget );

/* Static Properties */

/**
 * @static
 * @inheritdoc
 */
OO.ui.TabOptionWidget.static.highlightable = false;

/**
 * @static
 * @inheritdoc
 */
OO.ui.TabOptionWidget.static.scrollIntoViewOnSelect = true;

/**
 * Center tab horizontally after selecting on mobile
 *
 * @param {Object} [config] Configuration options
 * @return {jQuery.Promise} Promise which resolves when the scroll is complete
 */
OO.ui.TabOptionWidget.prototype.scrollElementIntoView = function ( config ) {
  var padding;
  if ( !OO.ui.isMobile() || !this.getElementGroup() ) {
    // Parent method
    return OO.ui.TabOptionWidget.super.prototype.scrollElementIntoView.call( this );
  } else {
    padding = Math.max( (
      this.getElementGroup().$element[ 0 ].clientWidth - this.$element[ 0 ].clientWidth
    ) / 2, 0 );
    // Parent method
    return OO.ui.TabOptionWidget.super.prototype.scrollElementIntoView.call( this, $.extend(
      {
        padding: {
          left: padding,
          right: padding
        }
      },
      config
    ) );
  }
};

/**
 * TabSelectWidget is a list that contains {@link OO.ui.TabOptionWidget tab options}
 *
 * **Currently, this class is only used by {@link OO.ui.IndexLayout index layouts}.**
 *
 * @class
 * @extends OO.ui.SelectWidget
 * @mixins OO.ui.mixin.TabIndexedElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [framed=true] Use framed tabs
 */
OO.ui.TabSelectWidget = function OoUiTabSelectWidget( config ) {
  // Parent constructor
  OO.ui.TabSelectWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.TabIndexedElement.call( this, config );

  // Events
  this.$element.on( {
    focus: this.bindDocumentKeyDownListener.bind( this ),
    blur: this.unbindDocumentKeyDownListener.bind( this )
  } );

  // Initialization
  this.$element
    .addClass( 'oo-ui-tabSelectWidget' )
    .attr( 'role', 'tablist' );

  this.toggleFramed( config.framed === undefined || config.framed );

  if ( OO.ui.isMobile() ) {
    this.$element.addClass( 'oo-ui-tabSelectWidget-mobile' );
  }
};

/* Setup */

OO.inheritClass( OO.ui.TabSelectWidget, OO.ui.SelectWidget );
OO.mixinClass( OO.ui.TabSelectWidget, OO.ui.mixin.TabIndexedElement );

/* Methods */

/**
 * Check if tabs are framed.
 *
 * @return {boolean} Tabs are framed
 */
OO.ui.TabSelectWidget.prototype.isFramed = function () {
  return this.framed;
};

/**
 * Render the tabs with or without frames.
 *
 * @param {boolean} [framed] Make tabs framed, omit to toggle
 * @chainable
 * @return {OO.ui.Element} The element, for chaining
 */
OO.ui.TabSelectWidget.prototype.toggleFramed = function ( framed ) {
  framed = framed === undefined ? !this.framed : !!framed;
  if ( framed !== this.framed ) {
    this.framed = framed;
    this.$element
      .toggleClass( 'oo-ui-tabSelectWidget-frameless', !framed )
      .toggleClass( 'oo-ui-tabSelectWidget-framed', framed );
  }

  return this;
};

/**
 * ButtonMenuSelectWidgets launch a menu of options created with OO.ui.MenuOptionWidget.
 * The ButtonMenuSelectWidget takes care of opening and displaying the menu so that
 * users can interact with it.
 *
 *     @example
 *     // A ButtonMenuSelectWidget with a menu that contains three options.
 *     var buttonMenu = new OO.ui.ButtonMenuSelectWidget( {
 *         icon: 'menu',
 *         menu: {
 *             items: [
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'a',
 *                     label: 'First'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'b',
 *                     label: 'Second'
 *                 } ),
 *                 new OO.ui.MenuOptionWidget( {
 *                     data: 'c',
 *                     label: 'Third'
 *                 } )
 *             ]
 *         }
 *     } );
 *
 *     $( document.body ).append( buttonMenu.$element );
 *
 *     // When using the `clearOnSelect` option, listen to the `choose` event
 *     // to avoid getting the null select event.
 *     buttonMenu.getMenu().on( 'choose', function ( menuOption ) {
 *         console.log( menuOption.getData() );
 *     } );
 *
 * @class
 * @extends OO.ui.ButtonWidget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {boolean} [clearOnSelect=true] Clear selection immediately after making it
 * @cfg {Object} [menu] Configuration options to pass to
 *  {@link OO.ui.MenuSelectWidget menu select widget}.
 * @cfg {jQuery|boolean} [$overlay] Render the menu into a separate layer. This configuration is
 *  useful in cases where the expanded menu is larger than its containing `<div>`. The specified
 *  overlay layer is usually on top of the containing `<div>` and has a larger area. By default,
 *  the menu uses relative positioning. Pass 'true' to use the default overlay.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 */
OO.ui.ButtonMenuSelectWidget = function OoUiButtonMenuSelectWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.ButtonMenuSelectWidget.super.call( this, config );

  this.$overlay = ( config.$overlay === true ?
    OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;

  // Properties
  this.clearOnSelect = config.clearOnSelect !== false;
  this.menu = new OO.ui.MenuSelectWidget( $.extend( {
    widget: this,
    $floatableContainer: this.$element
  }, config.menu ) );

  // Events
  this.connect( this, {
    click: 'onButtonMenuClick'
  } );
  this.getMenu().connect( this, {
    select: 'onMenuSelect',
    toggle: 'onMenuToggle'
  } );

  // Initialization
  this.$button
    .attr( {
      'aria-expanded': 'false',
      'aria-haspopup': 'true',
      'aria-owns': this.menu.getElementId()
    } );
  this.$element.addClass( 'oo-ui-buttonMenuSelectWidget' );
  this.$overlay.append( this.menu.$element );
};

/* Setup */

OO.inheritClass( OO.ui.ButtonMenuSelectWidget, OO.ui.ButtonWidget );

/* Methods */

/**
 * Get the menu.
 *
 * @return {OO.ui.MenuSelectWidget} Menu of widget
 */
OO.ui.ButtonMenuSelectWidget.prototype.getMenu = function () {
  return this.menu;
};

/**
 * Handle menu select events.
 *
 * @private
 * @param {OO.ui.MenuOptionWidget} item Selected menu item
 */
OO.ui.ButtonMenuSelectWidget.prototype.onMenuSelect = function ( item ) {
  if ( this.clearOnSelect && item ) {
    // This will cause an additional 'select' event to fire, so
    // users should probably listen to the 'choose' event.
    this.getMenu().selectItem();
  }
};

/**
 * Handle menu toggle events.
 *
 * @private
 * @param {boolean} isVisible Open state of the menu
 */
OO.ui.ButtonMenuSelectWidget.prototype.onMenuToggle = function ( isVisible ) {
  this.$element.toggleClass( 'oo-ui-buttonElement-pressed', isVisible );
};

/**
 * Handle mouse click events.
 *
 * @private
 */
OO.ui.ButtonMenuSelectWidget.prototype.onButtonMenuClick = function () {
  this.menu.toggle();
};

/**
 * TagItemWidgets are used within a {@link OO.ui.TagMultiselectWidget
 * TagMultiselectWidget} to display the selected items.
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.ItemWidget
 * @mixins OO.ui.mixin.LabelElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TabIndexedElement
 * @mixins OO.ui.mixin.DraggableElement
 *
 * @constructor
 * @param {Object} [config] Configuration object
 * @cfg {boolean} [valid=true] Item is valid
 * @cfg {boolean} [fixed] Item is fixed. This means the item is
 *  always included in the values and cannot be removed.
 */
OO.ui.TagItemWidget = function OoUiTagItemWidget( config ) {
  config = config || {};

  // Parent constructor
  OO.ui.TagItemWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.ItemWidget.call( this );
  OO.ui.mixin.LabelElement.call( this, config );
  OO.ui.mixin.FlaggedElement.call( this, config );
  OO.ui.mixin.TabIndexedElement.call( this, config );
  OO.ui.mixin.DraggableElement.call( this, config );

  this.valid = config.valid === undefined ? true : !!config.valid;
  this.fixed = !!config.fixed;

  this.closeButton = new OO.ui.ButtonWidget( {
    framed: false,
    icon: 'close',
    tabIndex: -1,
    title: OO.ui.msg( 'ooui-item-remove' )
  } );
  this.closeButton.setDisabled( this.isDisabled() );

  // Events
  this.closeButton.connect( this, {
    click: 'remove'
  } );
  this.$element
    .on( 'click', this.select.bind( this ) )
    .on( 'keydown', this.onKeyDown.bind( this ) )
    // Prevent propagation of mousedown; the tag item "lives" in the
    // clickable area of the TagMultiselectWidget, which listens to
    // mousedown to open the menu or popup. We want to prevent that
    // for clicks specifically on the tag itself, so the actions taken
    // are more deliberate. When the tag is clicked, it will emit the
    // selection event (similar to how #OO.ui.MultioptionWidget emits 'change')
    // and can be handled separately.
    .on( 'mousedown', function ( e ) { e.stopPropagation(); } );

  // Initialization
  this.$element
    .addClass( 'oo-ui-tagItemWidget' )
    .append( this.$label, this.closeButton.$element );
};

/* Initialization */

OO.inheritClass( OO.ui.TagItemWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.ItemWidget );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.LabelElement );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.TabIndexedElement );
OO.mixinClass( OO.ui.TagItemWidget, OO.ui.mixin.DraggableElement );

/* Events */

/**
 * @event remove
 *
 * A remove action was performed on the item
 */

/**
 * @event navigate
 * @param {string} direction Direction of the movement, forward or backwards
 *
 * A navigate action was performed on the item
 */

/**
 * @event select
 *
 * The tag widget was selected. This can occur when the widget
 * is either clicked or enter was pressed on it.
 */

/**
 * @event valid
 * @param {boolean} isValid Item is valid
 *
 * Item validity has changed
 */

/**
 * @event fixed
 * @param {boolean} isFixed Item is fixed
 *
 * Item fixed state has changed
 */

/* Methods */

/**
 * Set this item as fixed, meaning it cannot be removed
 *
 * @param {string} [state] Item is fixed
 * @fires fixed
 * @return {OO.ui.Widget} The widget, for chaining
 */
OO.ui.TagItemWidget.prototype.setFixed = function ( state ) {
  state = state === undefined ? !this.fixed : !!state;

  if ( this.fixed !== state ) {
    this.fixed = state;
    if ( this.closeButton ) {
      this.closeButton.toggle( !this.fixed );
    }

    if ( !this.fixed && this.elementGroup && !this.elementGroup.isDraggable() ) {
      // Only enable the state of the item if the
      // entire group is draggable
      this.toggleDraggable( !this.fixed );
    }
    this.$element.toggleClass( 'oo-ui-tagItemWidget-fixed', this.fixed );

    this.emit( 'fixed', this.isFixed() );
  }
  return this;
};

/**
 * Check whether the item is fixed
 *
 * @return {boolean}
 */
OO.ui.TagItemWidget.prototype.isFixed = function () {
  return this.fixed;
};

/**
 * Handle removal of the item
 *
 * This is mainly for extensibility concerns, so other children
 * of this class can change the behavior if they need to. This
 * is called by both clicking the 'remove' button but also
 * on keypress, which is harder to override if needed.
 *
 * @fires remove
 */
OO.ui.TagItemWidget.prototype.remove = function () {
  if ( !this.isDisabled() && !this.isFixed() ) {
    this.emit( 'remove' );
  }
};

/**
 * Handle a keydown event on the widget
 *
 * @fires navigate
 * @fires remove
 * @param {jQuery.Event} e Key down event
 * @return {boolean|undefined} false to stop the operation
 */
OO.ui.TagItemWidget.prototype.onKeyDown = function ( e ) {
  var movement;

  if (
    !this.isDisabled() &&
    !this.isFixed() &&
    ( e.keyCode === OO.ui.Keys.BACKSPACE || e.keyCode === OO.ui.Keys.DELETE )
  ) {
    this.remove();
    return false;
  } else if ( e.keyCode === OO.ui.Keys.ENTER ) {
    this.select();
    return false;
  } else if (
    e.keyCode === OO.ui.Keys.LEFT ||
    e.keyCode === OO.ui.Keys.RIGHT
  ) {
    if ( OO.ui.Element.static.getDir( this.$element ) === 'rtl' ) {
      movement = {
        left: 'forwards',
        right: 'backwards'
      };
    } else {
      movement = {
        left: 'backwards',
        right: 'forwards'
      };
    }

    this.emit(
      'navigate',
      e.keyCode === OO.ui.Keys.LEFT ?
        movement.left : movement.right
    );
    return false;
  }
};

/**
 * Select this item
 *
 * @fires select
 */
OO.ui.TagItemWidget.prototype.select = function () {
  if ( !this.isDisabled() ) {
    this.emit( 'select' );
  }
};

/**
 * Set the valid state of this item
 *
 * @param {boolean} [valid] Item is valid
 * @fires valid
 */
OO.ui.TagItemWidget.prototype.toggleValid = function ( valid ) {
  valid = valid === undefined ? !this.valid : !!valid;

  if ( this.valid !== valid ) {
    this.valid = valid;

    this.setFlags( { invalid: !this.valid } );

    this.emit( 'valid', this.valid );
  }
};

/**
 * Check whether the item is valid
 *
 * @return {boolean} Item is valid
 */
OO.ui.TagItemWidget.prototype.isValid = function () {
  return this.valid;
};

/**
 * A basic tag multiselect widget, similar in concept to
 * {@link OO.ui.ComboBoxInputWidget combo box widget} that allows the user to add multiple values
 * that are displayed in a tag area.
 *
 * This widget is a base widget; see {@link OO.ui.MenuTagMultiselectWidget MenuTagMultiselectWidget}
 * and {@link OO.ui.PopupTagMultiselectWidget PopupTagMultiselectWidget} for the implementations
 * that use a menu and a popup respectively.
 *
 *     @example
 *     // A TagMultiselectWidget.
 *     var widget = new OO.ui.TagMultiselectWidget( {
 *         inputPosition: 'outline',
 *         allowedValues: [ 'Option 1', 'Option 2', 'Option 3' ],
 *         selected: [ 'Option 1' ]
 *     } );
 *     $( document.body ).append( widget.$element );
 *
 * @class
 * @extends OO.ui.Widget
 * @mixins OO.ui.mixin.GroupWidget
 * @mixins OO.ui.mixin.DraggableGroupElement
 * @mixins OO.ui.mixin.IndicatorElement
 * @mixins OO.ui.mixin.IconElement
 * @mixins OO.ui.mixin.TabIndexedElement
 * @mixins OO.ui.mixin.FlaggedElement
 * @mixins OO.ui.mixin.TitledElement
 *
 * @constructor
 * @param {Object} config Configuration object
 * @cfg {Object} [input] Configuration options for the input widget
 * @cfg {OO.ui.InputWidget} [inputWidget] An optional input widget. If given, it will
 *  replace the input widget used in the TagMultiselectWidget. If not given,
 *  TagMultiselectWidget creates its own.
 * @cfg {boolean} [inputPosition='inline'] Position of the input. Options are:
 *  - inline: The input is invisible, but exists inside the tag list, so
 *    the user types into the tag groups to add tags.
 *  - outline: The input is underneath the tag area.
 *  - none: No input supplied
 * @cfg {boolean} [allowEditTags=true] Allow editing of the tags by clicking them
 * @cfg {boolean} [allowArbitrary=false] Allow data items to be added even if
 *  not present in the menu.
 * @cfg {Object[]} [allowedValues] An array representing the allowed items
 *  by their datas.
 * @cfg {boolean} [allowDuplicates=false] Allow duplicate items to be added
 * @cfg {boolean} [allowDisplayInvalidTags=false] Allow the display of
 *  invalid tags. These tags will display with an invalid state, and
 *  the widget as a whole will have an invalid state if any invalid tags
 *  are present.
 * @cfg {number} [tagLimit] An optional limit on the number of selected options.
 *  If 'tagLimit' is set and is reached, the input is disabled, not allowing any
 *  additions. If 'tagLimit' is unset or is 0, an unlimited number of items can be
 *  added.
 * @cfg {boolean} [allowReordering=true] Allow reordering of the items
 * @cfg {Object[]|String[]} [selected] A set of selected tags. If given,
 *  these will appear in the tag list on initialization, as long as they
 *  pass the validity tests.
 */
OO.ui.TagMultiselectWidget = function OoUiTagMultiselectWidget( config ) {
  var inputEvents,
    rAF = window.requestAnimationFrame || setTimeout,
    widget = this,
    $tabFocus = $( '<span>' ).addClass( 'oo-ui-tagMultiselectWidget-focusTrap' );

  config = config || {};

  // Parent constructor
  OO.ui.TagMultiselectWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.GroupWidget.call( this, config );
  OO.ui.mixin.IndicatorElement.call( this, config );
  OO.ui.mixin.IconElement.call( this, config );
  OO.ui.mixin.TabIndexedElement.call( this, config );
  OO.ui.mixin.FlaggedElement.call( this, config );
  OO.ui.mixin.DraggableGroupElement.call( this, config );
  OO.ui.mixin.TitledElement.call( this, config );

  this.toggleDraggable(
    config.allowReordering === undefined ?
      true : !!config.allowReordering
  );

  this.inputPosition =
    this.constructor.static.allowedInputPositions.indexOf( config.inputPosition ) > -1 ?
      config.inputPosition : 'inline';
  this.allowEditTags = config.allowEditTags === undefined ? true : !!config.allowEditTags;
  this.allowArbitrary = !!config.allowArbitrary;
  this.allowDuplicates = !!config.allowDuplicates;
  this.allowedValues = config.allowedValues || [];
  this.allowDisplayInvalidTags = config.allowDisplayInvalidTags;
  this.hasInput = this.inputPosition !== 'none';
  this.tagLimit = config.tagLimit;
  this.height = null;
  this.valid = true;

  this.$content = $( '<div>' ).addClass( 'oo-ui-tagMultiselectWidget-content' );
  this.$handle = $( '<div>' )
    .addClass( 'oo-ui-tagMultiselectWidget-handle' )
    .append(
      this.$indicator,
      this.$icon,
      this.$content
        .append(
          this.$group.addClass( 'oo-ui-tagMultiselectWidget-group' )
        )
    );

  // Events
  this.aggregate( {
    remove: 'itemRemove',
    navigate: 'itemNavigate',
    select: 'itemSelect',
    fixed: 'itemFixed'
  } );
  this.connect( this, {
    itemRemove: 'onTagRemove',
    itemSelect: 'onTagSelect',
    itemFixed: 'onTagFixed',
    itemNavigate: 'onTagNavigate',
    change: 'onChangeTags'
  } );
  this.$handle.on( {
    mousedown: this.onMouseDown.bind( this )
  } );

  // Initialize
  this.$element
    .addClass( 'oo-ui-tagMultiselectWidget' )
    .append( this.$handle );

  if ( this.hasInput ) {
    if ( config.inputWidget ) {
      this.input = config.inputWidget;
    } else {
      this.input = new OO.ui.TextInputWidget( $.extend( {
        placeholder: config.placeholder,
        classes: [ 'oo-ui-tagMultiselectWidget-input' ]
      }, config.input ) );
    }
    this.input.setDisabled( this.isDisabled() );

    inputEvents = {
      focus: this.onInputFocus.bind( this ),
      blur: this.onInputBlur.bind( this ),
      'propertychange change click mouseup keydown keyup input cut paste select focus':
        OO.ui.debounce( this.updateInputSize.bind( this ) ),
      keydown: this.onInputKeyDown.bind( this ),
      keypress: this.onInputKeyPress.bind( this )
    };

    this.input.$input.on( inputEvents );
    this.inputPlaceholder = this.input.$input.attr( 'placeholder' );

    if ( this.inputPosition === 'outline' ) {
      // Override max-height for the input widget
      // in the case the widget is outline so it can
      // stretch all the way if the widget is wide
      this.input.$element.css( 'max-width', 'inherit' );
      this.$element
        .addClass( 'oo-ui-tagMultiselectWidget-outlined' )
        .append( this.input.$element );
    } else {
      this.$element.addClass( 'oo-ui-tagMultiselectWidget-inlined' );
      // HACK: When the widget is using 'inline' input, the
      // behavior needs to only use the $input itself
      // so we style and size it accordingly (otherwise
      // the styling and sizing can get very convoluted
      // when the wrapping divs and other elements)
      // We are taking advantage of still being able to
      // call the widget itself for operations like
      // .getValue() and setDisabled() and .focus() but
      // having only the $input attached to the DOM
      this.$content.append( this.input.$input );
    }
  } else {
    this.$content.append( $tabFocus );
  }

  this.setTabIndexedElement(
    this.hasInput ?
      this.input.$input :
      $tabFocus
  );

  if ( config.selected ) {
    this.setValue( config.selected );
  }

  // HACK: Input size needs to be calculated after everything
  // else is rendered
  rAF( function () {
    if ( widget.hasInput ) {
      widget.updateInputSize();
    }
  } );
};

/* Initialization */

OO.inheritClass( OO.ui.TagMultiselectWidget, OO.ui.Widget );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.GroupWidget );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.DraggableGroupElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.IndicatorElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.IconElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.TabIndexedElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.FlaggedElement );
OO.mixinClass( OO.ui.TagMultiselectWidget, OO.ui.mixin.TitledElement );

/* Static properties */

/**
 * Allowed input positions.
 * - inline: The input is inside the tag list
 * - outline: The input is under the tag list
 * - none: There is no input
 *
 * @property {Array}
 */
OO.ui.TagMultiselectWidget.static.allowedInputPositions = [ 'inline', 'outline', 'none' ];

/* Methods */

/**
 * Handle mouse down events.
 *
 * @private
 * @param {jQuery.Event} e Mouse down event
 * @return {boolean} False to prevent defaults
 */
OO.ui.TagMultiselectWidget.prototype.onMouseDown = function ( e ) {
  if (
    !this.isDisabled() &&
    ( !this.hasInput || e.target !== this.input.$input[ 0 ] ) &&
    e.which === OO.ui.MouseButtons.LEFT
  ) {
    this.focus();
    return false;
  }
};

/**
 * Handle key press events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @return {boolean} Whether to prevent defaults
 */
OO.ui.TagMultiselectWidget.prototype.onInputKeyPress = function ( e ) {
  var stopOrContinue,
    withMetaKey = e.metaKey || e.ctrlKey;

  if ( !this.isDisabled() ) {
    if ( e.which === OO.ui.Keys.ENTER ) {
      stopOrContinue = this.doInputEnter( e, withMetaKey );
    }

    // Make sure the input gets resized.
    setTimeout( this.updateInputSize.bind( this ), 0 );
    return stopOrContinue;
  }
};

/**
 * Handle key down events.
 *
 * @private
 * @param {jQuery.Event} e Key down event
 * @return {boolean}
 */
OO.ui.TagMultiselectWidget.prototype.onInputKeyDown = function ( e ) {
  var movement, direction,
    widget = this,
    withMetaKey = e.metaKey || e.ctrlKey,
    isMovementInsideInput = function ( direction ) {
      var inputRange = widget.input.getRange(),
        inputValue = widget.hasInput && widget.input.getValue();

      if ( direction === 'forwards' && inputRange.to > inputValue.length - 1 ) {
        return false;
      }

      if ( direction === 'backwards' && inputRange.from <= 0 ) {
        return false;
      }

      return true;
    };

  if ( !this.isDisabled() ) {
    // 'keypress' event is not triggered for Backspace key
    if ( e.keyCode === OO.ui.Keys.BACKSPACE ) {
      return this.doInputBackspace( e, withMetaKey );
    } else if ( e.keyCode === OO.ui.Keys.ESCAPE ) {
      return this.doInputEscape( e );
    } else if (
      e.keyCode === OO.ui.Keys.LEFT ||
      e.keyCode === OO.ui.Keys.RIGHT
    ) {
      if ( OO.ui.Element.static.getDir( this.$element ) === 'rtl' ) {
        movement = {
          left: 'forwards',
          right: 'backwards'
        };
      } else {
        movement = {
          left: 'backwards',
          right: 'forwards'
        };
      }
      direction = e.keyCode === OO.ui.Keys.LEFT ?
        movement.left : movement.right;

      if ( !this.hasInput || !isMovementInsideInput( direction ) ) {
        return this.doInputArrow( e, direction, withMetaKey );
      }
    }
  }
};

/**
 * Respond to input focus event
 */
OO.ui.TagMultiselectWidget.prototype.onInputFocus = function () {
  this.$element.addClass( 'oo-ui-tagMultiselectWidget-focus' );
  // Reset validity
  this.toggleValid( true );
};

/**
 * Respond to input blur event
 */
OO.ui.TagMultiselectWidget.prototype.onInputBlur = function () {
  this.$element.removeClass( 'oo-ui-tagMultiselectWidget-focus' );

  // Set the widget as invalid if there's text in the input
  this.addTagFromInput();
  this.toggleValid( this.checkValidity() && ( !this.hasInput || !this.input.getValue() ) );
};

/**
 * Perform an action after the Enter key on the input
 *
 * @param {jQuery.Event} e Event data
 * @param {boolean} [withMetaKey] Whether this key was pressed with
 * a meta key like Control
 * @return {boolean} Whether to prevent defaults
 */
OO.ui.TagMultiselectWidget.prototype.doInputEnter = function () {
  this.addTagFromInput();
  return false;
};

/**
 * Perform an action responding to the Backspace key on the input
 *
 * @param {jQuery.Event} e Event data
 * @param {boolean} [withMetaKey] Whether this key was pressed with
 * a meta key like Control
 * @return {boolean} Whether to prevent defaults
 */
OO.ui.TagMultiselectWidget.prototype.doInputBackspace = function ( e, withMetaKey ) {
  var items, item;

  if (
    this.inputPosition === 'inline' &&
    this.input.getValue() === '' &&
    !this.isEmpty()
  ) {
    // Delete the last item
    items = this.getItems();
    item = items[ items.length - 1 ];

    if ( !item.isDisabled() && !item.isFixed() ) {
      this.removeItems( [ item ] );
      // If Ctrl/Cmd was pressed, delete item entirely.
      // Otherwise put it into the text field for editing.
      if ( !withMetaKey ) {
        this.input.setValue( item.getLabel() );
      }
    }

    return false;
  }
};

/**
 * Perform an action after the Escape key on the input
 *
 * @param {jQuery.Event} e Event data
 */
OO.ui.TagMultiselectWidget.prototype.doInputEscape = function () {
  this.clearInput();
};

/**
 * Perform an action after the Left/Right arrow key on the input, select the previous
 * item from the input.
 * See #getPreviousItem
 *
 * @param {jQuery.Event} e Event data
 * @param {string} direction Direction of the movement; forwards or backwards
 * @param {boolean} [withMetaKey] Whether this key was pressed with
 *  a meta key like Control
 */
OO.ui.TagMultiselectWidget.prototype.doInputArrow = function ( e, direction ) {
  if (
    this.inputPosition === 'inline' &&
    !this.isEmpty() &&
    direction === 'backwards'
  ) {
    // Get previous item
    this.getPreviousItem().focus();
  }
};

/**
 * Respond to item select event
 *
 * @param {OO.ui.TagItemWidget} item Selected item
 */
OO.ui.TagMultiselectWidget.prototype.onTagSelect = function ( item ) {
  if ( this.hasInput && this.allowEditTags && !item.isFixed() ) {
    if ( this.input.getValue() ) {
      this.addTagFromInput();
    }
    // 1. Get the label of the tag into the input
    this.input.setValue( item.getLabel() );
    // 2. Remove the tag
    this.removeItems( [ item ] );
    // 3. Focus the input
    this.focus();
  }
};

/**
 * Respond to item fixed state change
 *
 * @param {OO.ui.TagItemWidget} item Selected item
 */
OO.ui.TagMultiselectWidget.prototype.onTagFixed = function ( item ) {
  var i,
    items = this.getItems();

  // Move item to the end of the static items
  for ( i = 0; i < items.length; i++ ) {
    if ( items[ i ] !== item && !items[ i ].isFixed() ) {
      break;
    }
  }
  this.addItems( item, i );
};
/**
 * Respond to change event, where items were added, removed, or cleared.
 */
OO.ui.TagMultiselectWidget.prototype.onChangeTags = function () {
  var isUnderLimit = this.isUnderLimit();

  // Reset validity
  this.toggleValid( this.checkValidity() );

  if ( this.hasInput ) {
    this.updateInputSize();
    if ( !isUnderLimit ) {
      // Clear the input
      this.input.setValue( '' );
    }
    if ( this.inputPosition === 'outline' ) {
      // Show/clear the placeholder and enable/disable the input
      // based on whether we are/aren't under the specified limit
      this.input.$input.attr( 'placeholder', isUnderLimit ? this.inputPlaceholder : '' );
      this.input.setDisabled( !isUnderLimit );
    } else {
      // Show/hide the input
      this.input.$input.toggleClass( 'oo-ui-element-hidden', !isUnderLimit );
    }
  }
  this.updateIfHeightChanged();
};

/**
 * @inheritdoc
 */
OO.ui.TagMultiselectWidget.prototype.setDisabled = function ( isDisabled ) {
  // Parent method
  OO.ui.TagMultiselectWidget.super.prototype.setDisabled.call( this, isDisabled );

  if ( this.hasInput && this.input ) {
    if ( !isDisabled ) {
      this.updateInputSize();
    }
    this.input.setDisabled( !!isDisabled && !this.isUnderLimit() );
  }

  if ( this.items ) {
    this.getItems().forEach( function ( item ) {
      item.setDisabled( !!isDisabled );
    } );
  }
};

/**
 * Respond to tag remove event
 *
 * @param {OO.ui.TagItemWidget} item Removed tag
 */
OO.ui.TagMultiselectWidget.prototype.onTagRemove = function ( item ) {
  this.removeTagByData( item.getData() );
};

/**
 * Respond to navigate event on the tag
 *
 * @param {OO.ui.TagItemWidget} item Removed tag
 * @param {string} direction Direction of movement; 'forwards' or 'backwards'
 */
OO.ui.TagMultiselectWidget.prototype.onTagNavigate = function ( item, direction ) {
  var firstItem = this.getItems()[ 0 ];

  if ( direction === 'forwards' ) {
    this.getNextItem( item ).focus();
  } else if ( !this.inputPosition === 'inline' || item !== firstItem ) {
    // If the widget has an inline input, we want to stop at the starting edge
    // of the tags
    this.getPreviousItem( item ).focus();
  }
};

/**
 * Get data and label for a new tag from the input value
 *
 * @return {Object} The data and label for a tag
 */
OO.ui.TagMultiselectWidget.prototype.getTagInfoFromInput = function () {
  var val = this.input.getValue();
  return { data: val, label: val };
};

/**
 * Add tag from input value
 */
OO.ui.TagMultiselectWidget.prototype.addTagFromInput = function () {
  var tagInfo = this.getTagInfoFromInput();

  if ( !tagInfo.data ) {
    return;
  }

  if ( this.addTag( tagInfo.data, tagInfo.label ) ) {
    this.clearInput();
  }
};

/**
 * Clear the input
 */
OO.ui.TagMultiselectWidget.prototype.clearInput = function () {
  this.input.setValue( '' );
};

/**
 * Check whether the given value is a duplicate of an existing
 * tag already in the list.
 *
 * @param {string|Object} data Requested value
 * @return {boolean} Value is duplicate
 */
OO.ui.TagMultiselectWidget.prototype.isDuplicateData = function ( data ) {
  return !!this.findItemFromData( data );
};

/**
 * Check whether a given value is allowed to be added
 *
 * @param {string|Object} data Requested value
 * @return {boolean} Value is allowed
 */
OO.ui.TagMultiselectWidget.prototype.isAllowedData = function ( data ) {
  if (
    !this.allowDuplicates &&
    this.isDuplicateData( data )
  ) {
    return false;
  }

  if ( this.allowArbitrary ) {
    return true;
  }

  // Check with allowed values
  if (
    this.getAllowedValues().some( function ( value ) {
      return data === value;
    } )
  ) {
    return true;
  }

  return false;
};

/**
 * Get the allowed values list
 *
 * @return {string[]} Allowed data values
 */
OO.ui.TagMultiselectWidget.prototype.getAllowedValues = function () {
  return this.allowedValues;
};

/**
 * Add a value to the allowed values list
 *
 * @param {string} value Allowed data value
 */
OO.ui.TagMultiselectWidget.prototype.addAllowedValue = function ( value ) {
  if ( this.allowedValues.indexOf( value ) === -1 ) {
    this.allowedValues.push( value );
  }
};

/**
 * Get the datas of the currently selected items
 *
 * @return {string[]|Object[]} Datas of currently selected items
 */
OO.ui.TagMultiselectWidget.prototype.getValue = function () {
  return this.getItems()
    .filter( function ( item ) {
      return item.isValid();
    } )
    .map( function ( item ) {
      return item.getData();
    } );
};

/**
 * Set the value of this widget by datas.
 *
 * @param {string|string[]|Object|Object[]} valueObject An object representing the data
 *  and label of the value. If the widget allows arbitrary values,
 *  the items will be added as-is. Otherwise, the data value will
 *  be checked against allowedValues.
 *  This object must contain at least a data key. Example:
 *  { data: 'foo', label: 'Foo item' }
 *  For multiple items, use an array of objects. For example:
 *  [
 *     { data: 'foo', label: 'Foo item' },
 *     { data: 'bar', label: 'Bar item' }
 *  ]
 *  Value can also be added with plaintext array, for example:
 *  [ 'foo', 'bar', 'bla' ] or a single string, like 'foo'
 */
OO.ui.TagMultiselectWidget.prototype.setValue = function ( valueObject ) {
  valueObject = Array.isArray( valueObject ) ? valueObject : [ valueObject ];

  this.clearItems();
  valueObject.forEach( function ( obj ) {
    if ( typeof obj === 'string' ) {
      this.addTag( obj );
    } else {
      this.addTag( obj.data, obj.label );
    }
  }.bind( this ) );
};

/**
 * Add tag to the display area.
 *
 * Performs a validation check on the tag to be added.
 *
 * @param {string|Object} data Tag data
 * @param {string} [label] Tag label. If no label is provided, the
 *  stringified version of the data will be used instead.
 * @return {boolean} Item was added successfully
 */
OO.ui.TagMultiselectWidget.prototype.addTag = function ( data, label ) {
  var newItemWidget,
    isValid = this.isAllowedData( data );

  if ( this.isUnderLimit() && ( isValid || this.allowDisplayInvalidTags ) ) {
    newItemWidget = this.createTagItemWidget( data, label );
    newItemWidget.toggleValid( isValid );
    this.addItems( [ newItemWidget ] );
    return true;
  }

  return false;
};

/**
 * Check whether the number of current tags is within the limit.
 *
 * @return {boolean} True if current tag count is within the limit or
 *  if 'tagLimit' is not set
 */
OO.ui.TagMultiselectWidget.prototype.isUnderLimit = function () {
  return !this.tagLimit ||
    this.getItemCount() < this.tagLimit;
};

/**
 * Remove tag by its data property.
 *
 * @param {string|Object} data Tag data
 */
OO.ui.TagMultiselectWidget.prototype.removeTagByData = function ( data ) {
  var item = this.findItemFromData( data );

  this.removeItems( [ item ] );
};

/**
 * Construct a OO.ui.TagItemWidget (or a subclass thereof) from given label and data.
 *
 * @protected
 * @param {string} data Item data
 * @param {string} label The label text.
 * @return {OO.ui.TagItemWidget}
 */
OO.ui.TagMultiselectWidget.prototype.createTagItemWidget = function ( data, label ) {
  label = label || data;

  return new OO.ui.TagItemWidget( { data: data, label: label } );
};

/**
 * Given an item, returns the item after it. If the item is already the
 * last item, return `this.input`. If no item is passed, returns the
 * very first item.
 *
 * @protected
 * @param {OO.ui.TagItemWidget} [item] Tag item
 * @return {OO.ui.Widget} The next widget available.
 */
OO.ui.TagMultiselectWidget.prototype.getNextItem = function ( item ) {
  var itemIndex = this.items.indexOf( item );

  if ( item === undefined || itemIndex === -1 ) {
    return this.items[ 0 ];
  }

  if ( itemIndex === this.items.length - 1 ) { // Last item
    if ( this.hasInput ) {
      return this.input;
    } else {
      // Return first item
      return this.items[ 0 ];
    }
  } else {
    return this.items[ itemIndex + 1 ];
  }
};

/**
 * Given an item, returns the item before it. If the item is already the
 * first item, return `this.input`. If no item is passed, returns the
 * very last item.
 *
 * @protected
 * @param {OO.ui.TagItemWidget} [item] Tag item
 * @return {OO.ui.Widget} The previous widget available.
 */
OO.ui.TagMultiselectWidget.prototype.getPreviousItem = function ( item ) {
  var itemIndex = this.items.indexOf( item );

  if ( item === undefined || itemIndex === -1 ) {
    return this.items[ this.items.length - 1 ];
  }

  if ( itemIndex === 0 ) {
    if ( this.hasInput ) {
      return this.input;
    } else {
      // Return the last item
      return this.items[ this.items.length - 1 ];
    }
  } else {
    return this.items[ itemIndex - 1 ];
  }
};

/**
 * Update the dimensions of the text input field to encompass all available area.
 * This is especially relevant for when the input is at the edge of a line
 * and should get smaller. The usual operation (as an inline-block with min-width)
 * does not work in that case, pushing the input downwards to the next line.
 *
 * @private
 */
OO.ui.TagMultiselectWidget.prototype.updateInputSize = function () {
  var $lastItem, direction, contentWidth, currentWidth, bestWidth, placeholder;

  if ( this.inputPosition === 'inline' && !this.isDisabled() ) {
    if ( this.input.$input[ 0 ].scrollWidth === 0 ) {
      // Input appears to be attached but not visible.
      // Don't attempt to adjust its size, because our measurements
      // are going to fail anyway.
      return;
    }
    this.input.$input.css( 'width', '1em' );
    $lastItem = this.$group.children().last();
    direction = OO.ui.Element.static.getDir( this.$handle );

    // Get the width of the input with the placeholder text as
    // the value and save it so that we don't keep recalculating
    placeholder = this.input.$input.attr( 'placeholder' );
    if (
      this.contentWidthWithPlaceholder === undefined &&
      this.input.getValue() === '' &&
      placeholder !== undefined
    ) {
      // Set the value directly to avoid any side effects of setValue
      this.input.$input.val( placeholder );
      this.contentWidthWithPlaceholder = this.input.$input[ 0 ].scrollWidth;
      this.input.$input.val( '' );

    }

    // Always keep the input wide enough for the placeholder text
    contentWidth = Math.max(
      this.input.$input[ 0 ].scrollWidth,
      // undefined arguments in Math.max lead to NaN
      ( this.contentWidthWithPlaceholder === undefined ) ?
        0 : this.contentWidthWithPlaceholder
    );
    currentWidth = this.input.$input.width();

    if ( contentWidth < currentWidth ) {
      this.updateIfHeightChanged();
      // All is fine, don't perform expensive calculations
      return;
    }

    if ( $lastItem.length === 0 ) {
      bestWidth = this.$content.innerWidth();
    } else {
      bestWidth = direction === 'ltr' ?
        this.$content.innerWidth() - $lastItem.position().left - $lastItem.outerWidth() :
        $lastItem.position().left;
    }

    // Some safety margin for sanity, because I *really* don't feel like finding out where the
    // few pixels this is off by are coming from.
    bestWidth -= 13;
    if ( contentWidth > bestWidth ) {
      // This will result in the input getting shifted to the next line
      bestWidth = this.$content.innerWidth() - 13;
    }
    this.input.$input.width( Math.floor( bestWidth ) );
    this.updateIfHeightChanged();
  } else {
    this.updateIfHeightChanged();
  }
};

/**
 * Determine if widget height changed, and if so,
 * emit the resize event. This is useful for when there are either
 * menus or popups attached to the bottom of the widget, to allow
 * them to change their positioning in case the widget moved down
 * or up.
 *
 * @private
 */
OO.ui.TagMultiselectWidget.prototype.updateIfHeightChanged = function () {
  var height = this.$element.height();
  if ( height !== this.height ) {
    this.height = height;
    this.emit( 'resize' );
  }
};

/**
 * Check whether all items in the widget are valid
 *
 * @return {boolean} Widget is valid
 */
OO.ui.TagMultiselectWidget.prototype.checkValidity = function () {
  return this.getItems().every( function ( item ) {
    return item.isValid();
  } );
};

/**
 * Set the valid state of this item
 *
 * @param {boolean} [valid] Item is valid
 * @fires valid
 */
OO.ui.TagMultiselectWidget.prototype.toggleValid = function ( valid ) {
  valid = valid === undefined ? !this.valid : !!valid;

  if ( this.valid !== valid ) {
    this.valid = valid;

    this.setFlags( { invalid: !this.valid } );

    this.emit( 'valid', this.valid );
  }
};

/**
 * Get the current valid state of the widget
 *
 * @return {boolean} Widget is valid
 */
OO.ui.TagMultiselectWidget.prototype.isValid = function () {
  return this.valid;
};

/**
 * PopupTagMultiselectWidget is a {@link OO.ui.TagMultiselectWidget OO.ui.TagMultiselectWidget}
 * intended to use a popup. The popup can be configured to have a default input to insert values
 * into the widget.
 *
 *     @example
 *     // A PopupTagMultiselectWidget.
 *     var widget = new OO.ui.PopupTagMultiselectWidget();
 *     $( document.body ).append( widget.$element );
 *
 *     // Example: A PopupTagMultiselectWidget with an external popup.
 *     var popupInput = new OO.ui.TextInputWidget(),
 *         widget = new OO.ui.PopupTagMultiselectWidget( {
 *            popupInput: popupInput,
 *            popup: {
 *               $content: popupInput.$element
 *            }
 *         } );
 *     $( document.body ).append( widget.$element );
 *
 * @class
 * @extends OO.ui.TagMultiselectWidget
 * @mixins OO.ui.mixin.PopupElement
 *
 * @param {Object} config Configuration object
 * @cfg {jQuery} [$overlay] An overlay for the popup.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 * @cfg {Object} [popup] Configuration options for the popup
 * @cfg {OO.ui.InputWidget} [popupInput] An input widget inside the popup that will be
 *  focused when the popup is opened and will be used as replacement for the
 *  general input in the widget.
 * @deprecated
 */
OO.ui.PopupTagMultiselectWidget = function OoUiPopupTagMultiselectWidget( config ) {
  var defaultInput,
    defaultConfig = { popup: {} };

  config = config || {};

  // Parent constructor
  OO.ui.PopupTagMultiselectWidget.super.call( this, $.extend( {
    inputPosition: 'none'
  }, config ) );

  this.$overlay = ( config.$overlay === true ?
    OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;

  if ( !config.popup ) {
    // For the default base implementation, we give a popup
    // with an input widget inside it. For any other use cases
    // the popup needs to be populated externally and the
    // event handled to add tags separately and manually
    defaultInput = new OO.ui.TextInputWidget();

    defaultConfig.popupInput = defaultInput;
    defaultConfig.popup.$content = defaultInput.$element;
    defaultConfig.popup.padded = true;

    this.$element.addClass( 'oo-ui-popupTagMultiselectWidget-defaultPopup' );
  }

  // Add overlay, and add that to the autoCloseIgnore
  defaultConfig.popup.$overlay = this.$overlay;
  defaultConfig.popup.$autoCloseIgnore = this.hasInput ?
    this.input.$element.add( this.$overlay ) : this.$overlay;

  // Allow extending any of the above
  config = $.extend( defaultConfig, config );

  // Mixin constructors
  OO.ui.mixin.PopupElement.call( this, config );

  if ( this.hasInput ) {
    this.input.$input.on( 'focus', this.popup.toggle.bind( this.popup, true ) );
  }

  // Configuration options
  this.popupInput = config.popupInput;
  if ( this.popupInput ) {
    this.popupInput.connect( this, {
      enter: 'onPopupInputEnter'
    } );
  }

  // Events
  this.on( 'resize', this.popup.updateDimensions.bind( this.popup ) );
  this.popup.connect( this, {
    toggle: 'onPopupToggle'
  } );
  this.$tabIndexed.on( 'focus', this.onFocus.bind( this ) );

  // Initialize
  this.$element
    .append( this.popup.$element )
    .addClass( 'oo-ui-popupTagMultiselectWidget' );

  // Deprecation warning
  OO.ui.warnDeprecation( 'PopupTagMultiselectWidget: Deprecated widget. Use MenuTagMultiselectWidget instead. See T208821.' );
};

/* Initialization */

OO.inheritClass( OO.ui.PopupTagMultiselectWidget, OO.ui.TagMultiselectWidget );
OO.mixinClass( OO.ui.PopupTagMultiselectWidget, OO.ui.mixin.PopupElement );

/* Methods */

/**
 * Focus event handler.
 *
 * @private
 */
OO.ui.PopupTagMultiselectWidget.prototype.onFocus = function () {
  this.popup.toggle( true );
};

/**
 * Respond to popup toggle event
 *
 * @param {boolean} isVisible Popup is visible
 */
OO.ui.PopupTagMultiselectWidget.prototype.onPopupToggle = function ( isVisible ) {
  if ( isVisible && this.popupInput ) {
    this.popupInput.focus();
  }
};

/**
 * Respond to popup input enter event
 */
OO.ui.PopupTagMultiselectWidget.prototype.onPopupInputEnter = function () {
  if ( this.popupInput ) {
    this.addTagByPopupValue( this.popupInput.getValue() );
    this.popupInput.setValue( '' );
  }
};

/**
 * @inheritdoc
 */
OO.ui.PopupTagMultiselectWidget.prototype.onTagSelect = function ( item ) {
  if ( this.popupInput && this.allowEditTags ) {
    this.popupInput.setValue( item.getData() );
    this.removeItems( [ item ] );

    this.popup.toggle( true );
    this.popupInput.focus();
  } else {
    // Parent
    OO.ui.PopupTagMultiselectWidget.super.prototype.onTagSelect.call( this, item );
  }
};

/**
 * Add a tag by the popup value.
 * Whatever is responsible for setting the value in the popup should call
 * this method to add a tag, or use the regular methods like #addTag or
 * #setValue directly.
 *
 * @param {string} data The value of item
 * @param {string} [label] The label of the tag. If not given, the data is used.
 */
OO.ui.PopupTagMultiselectWidget.prototype.addTagByPopupValue = function ( data, label ) {
  this.addTag( data, label );
};

/**
 * MenuTagMultiselectWidget is a {@link OO.ui.TagMultiselectWidget OO.ui.TagMultiselectWidget}
 * intended to use a menu of selectable options.
 *
 *     @example
 *     // A basic MenuTagMultiselectWidget.
 *     var widget = new OO.ui.MenuTagMultiselectWidget( {
 *         inputPosition: 'outline',
 *         options: [
 *            { data: 'option1', label: 'Option 1', icon: 'tag' },
 *            { data: 'option2', label: 'Option 2' },
 *            { data: 'option3', label: 'Option 3' },
 *         ],
 *         selected: [ 'option1', 'option2' ]
 *     } );
 *     $( document.body ).append( widget.$element );
 *
 * @class
 * @extends OO.ui.TagMultiselectWidget
 *
 * @constructor
 * @param {Object} [config] Configuration object
 * @cfg {boolean} [clearInputOnChoose=true] Clear the text input value when a menu option is chosen
 * @cfg {Object} [menu] Configuration object for the menu widget
 * @cfg {jQuery} [$overlay] An overlay for the menu.
 *  See <https://www.mediawiki.org/wiki/OOUI/Concepts#Overlays>.
 * @cfg {Object[]} [options=[]] Array of menu options in the format `{ data: …, label: … }`
 */
OO.ui.MenuTagMultiselectWidget = function OoUiMenuTagMultiselectWidget( config ) {
  var $autoCloseIgnore = $( [] );
  config = config || {};

  // Ensure that any pre-selected items exist as menu options,
  // so that they can be added as tags from #setValue
  config.options = config.options || [];
  config.selected = config.selected || [];
  config.selected.forEach( function ( title ) {
    config.options.push( {
      data: title,
      label: title
    } );
  } );

  // Parent constructor
  OO.ui.MenuTagMultiselectWidget.super.call( this, config );

  $autoCloseIgnore = $autoCloseIgnore.add( this.$group );
  if ( this.hasInput ) {
    $autoCloseIgnore = $autoCloseIgnore.add( this.input.$element );
  }

  this.$overlay = ( config.$overlay === true ?
    OO.ui.getDefaultOverlay() : config.$overlay ) || this.$element;
  this.clearInputOnChoose = config.clearInputOnChoose === undefined ||
    !!config.clearInputOnChoose;
  this.menu = this.createMenuWidget( $.extend( {
    widget: this,
    hideOnChoose: false,
    input: this.hasInput ? this.input : null,
    $input: this.hasInput ? this.input.$input : null,
    filterFromInput: !!this.hasInput,
    highlightOnFilter: !this.allowArbitrary,
    multiselect: true,
    $autoCloseIgnore: $autoCloseIgnore,
    $floatableContainer: this.hasInput && this.inputPosition === 'outline' ?
      this.input.$element : this.$element,
    $overlay: this.$overlay,
    disabled: this.isDisabled()
  }, config.menu ) );
  this.addOptions( config.options || [] );

  // Events
  this.menu.connect( this, {
    choose: 'onMenuChoose',
    toggle: 'onMenuToggle'
  } );
  if ( this.hasInput ) {
    this.input.connect( this, {
      change: 'onInputChange'
    } );
  }
  this.connect( this, {
    resize: 'onResize'
  } );

  // Initialization
  this.$overlay.append( this.menu.$element );
  this.$element.addClass( 'oo-ui-menuTagMultiselectWidget' );
  // Remove MenuSelectWidget's generic focus owner ARIA attribute
  // TODO: Should this widget have a `role` that is compatible with this attribute?
  this.menu.$focusOwner.removeAttr( 'aria-expanded' );
  // TagMultiselectWidget already does this, but it doesn't work right because this.menu is
  // not yet set up while the parent constructor runs, and #getAllowedValues rejects everything.
  if ( config.selected.length > 0 ) {
    this.setValue( config.selected );
  }
};

/* Initialization */

OO.inheritClass( OO.ui.MenuTagMultiselectWidget, OO.ui.TagMultiselectWidget );

/* Methods */

/**
 * Respond to resize event
 */
OO.ui.MenuTagMultiselectWidget.prototype.onResize = function () {
  // Reposition the menu
  this.menu.position();
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.onInputFocus = function () {
  // Parent method
  OO.ui.MenuTagMultiselectWidget.super.prototype.onInputFocus.call( this );

  this.menu.toggle( true );
};

/**
 * Respond to input change event
 */
OO.ui.MenuTagMultiselectWidget.prototype.onInputChange = function () {
  this.menu.toggle( true );
};

/**
 * Respond to menu choose event, which is intentional by the user.
 *
 * @param {OO.ui.OptionWidget} menuItem Selected menu items
 * @param {boolean} selected Item is selected
 */
OO.ui.MenuTagMultiselectWidget.prototype.onMenuChoose = function ( menuItem, selected ) {
  if ( selected && !this.findItemFromData( menuItem.getData() ) ) {
    // The menu item is selected, add it to the tags
    this.addTag( menuItem.getData(), menuItem.getLabel() );
  } else {
    // The menu item was unselected, remove the tag
    this.removeTagByData( menuItem.getData() );
  }

  if ( this.hasInput && this.clearInputOnChoose ) {
    this.input.setValue( '' );
  }
};

/**
 * Respond to menu toggle event. Reset item highlights on hide.
 *
 * @param {boolean} isVisible The menu is visible
 */
OO.ui.MenuTagMultiselectWidget.prototype.onMenuToggle = function ( isVisible ) {
  if ( !isVisible ) {
    this.menu.highlightItem( null );
    this.menu.scrollToTop();
  }
  setTimeout( function () {
    // Remove MenuSelectWidget's generic focus owner ARIA attribute
    // TODO: Should this widget have a `role` that is compatible with this attribute?
    this.menu.$focusOwner.removeAttr( 'aria-expanded' );
  }.bind( this ) );
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.onTagSelect = function ( tagItem ) {
  var menuItem = this.menu.findItemFromData( tagItem.getData() );
  if ( !this.allowArbitrary ) {
    // Override the base behavior from TagMultiselectWidget; the base behavior
    // in TagMultiselectWidget is to remove the tag to edit it in the input,
    // but in our case, we want to utilize the menu selection behavior, and
    // definitely not remove the item.

    // If there is an input that is used for filtering, erase the value so we don't filter
    if ( this.hasInput && this.menu.filterFromInput ) {
      this.input.setValue( '' );
    }

    this.focus();

    // Highlight the menu item
    this.menu.highlightItem( menuItem );
    this.menu.scrollItemIntoView( menuItem );

  } else {
    // Use the default
    OO.ui.MenuTagMultiselectWidget.super.prototype.onTagSelect.call( this, tagItem );
  }
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.removeItems = function ( items ) {
  var widget = this;

  // Parent
  OO.ui.MenuTagMultiselectWidget.super.prototype.removeItems.call( this, items );

  items.forEach( function ( tagItem ) {
    var menuItem = widget.menu.findItemFromData( tagItem.getData() );
    if ( menuItem ) {
      // Synchronize the menu selection - unselect the removed tag
      widget.menu.unselectItem( menuItem );
    }
  } );
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.setValue = function ( valueObject ) {
  valueObject = Array.isArray( valueObject ) ? valueObject : [ valueObject ];

  // We override this method from the parent, to make sure we are adding proper
  // menu items, and are accounting for cases where we have this widget with
  // a menu but also 'allowArbitrary'
  if ( !this.menu ) {
    return;
  }

  this.clearItems();
  valueObject.forEach( function ( obj ) {
    var data, label, menuItem;

    if ( typeof obj === 'string' ) {
      data = label = obj;
    } else {
      data = obj.data;
      label = obj.label;
    }

    // Check if the item is in the menu
    menuItem = this.menu.getItemFromLabel( label ) || this.menu.findItemFromData( data );
    if ( menuItem ) {
      // Menu item found, add the menu item
      this.addTag( menuItem.getData(), menuItem.getLabel() );
      // Make sure that item is also selected
      this.menu.selectItem( menuItem );
    } else if ( this.allowArbitrary ) {
      // If the item isn't in the menu, only add it if we
      // allow for arbitrary values
      this.addTag( data, label );
    }
  }.bind( this ) );
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.setDisabled = function ( isDisabled ) {
  // Parent method
  OO.ui.MenuTagMultiselectWidget.super.prototype.setDisabled.call( this, isDisabled );

  if ( this.menu ) {
    // Protect against calling setDisabled() before the menu was initialized
    this.menu.setDisabled( isDisabled );
  }
};

/**
 * Highlight the first selectable item in the menu, if configured.
 *
 * @private
 * @chainable
 */
OO.ui.MenuTagMultiselectWidget.prototype.initializeMenuSelection = function () {
  var highlightedItem;
  this.menu.highlightItem(
    this.allowArbitrary ?
      null :
      this.menu.findFirstSelectableItem()
  );

  highlightedItem = this.menu.findHighlightedItem();
  // Scroll to the highlighted item, if it exists
  if ( highlightedItem ) {
    this.menu.scrollItemIntoView( highlightedItem );
  }
};

/**
 * @inheritdoc
 */
OO.ui.MenuTagMultiselectWidget.prototype.getTagInfoFromInput = function () {
  var val = this.input.getValue(),
    // Look for a highlighted item first
    // Then look for the element that fits the data
    item = this.menu.findHighlightedItem() || this.menu.findItemFromData( val ),
    data = item ? item.getData() : val,
    label = item ? item.getLabel() : val;

  return { data: data, label: label };
};

/**
 * Create the menu for this widget. This is in a separate method so that
 * child classes can override this without polluting the constructor with
 * unnecessary extra objects that will be overidden.
 *
 * @param {Object} menuConfig Configuration options
 * @return {OO.ui.MenuSelectWidget} Menu widget
 */
OO.ui.MenuTagMultiselectWidget.prototype.createMenuWidget = function ( menuConfig ) {
  return new OO.ui.MenuSelectWidget( menuConfig );
};

/**
 * Add options to the menu
 *
 * @param {Object[]} menuOptions Object defining options
 */
OO.ui.MenuTagMultiselectWidget.prototype.addOptions = function ( menuOptions ) {
  var widget = this,
    items = menuOptions.map( function ( obj ) {
      return widget.createMenuOptionWidget( obj.data, obj.label, obj.icon );
    } );

  this.menu.addItems( items );
};

/**
 * Create a menu option widget.
 *
 * @param {string} data Item data
 * @param {string} [label] Item label
 * @param {string} [icon] Symbolic icon name
 * @return {OO.ui.OptionWidget} Option widget
 */
OO.ui.MenuTagMultiselectWidget.prototype.createMenuOptionWidget = function ( data, label, icon ) {
  return new OO.ui.MenuOptionWidget( {
    data: data,
    label: label || data,
    icon: icon
  } );
};

/**
 * Get the menu
 *
 * @return {OO.ui.MenuSelectWidget} Menu
 */
OO.ui.MenuTagMultiselectWidget.prototype.getMenu = function () {
  return this.menu;
};

/**
 * Get the allowed values list
 *
 * @return {string[]} Allowed data values
 */
OO.ui.MenuTagMultiselectWidget.prototype.getAllowedValues = function () {
  var menuDatas = [];
  if ( this.menu ) {
    // If the parent constructor is calling us, we're not ready yet, this.menu is not set up.
    menuDatas = this.menu.getItems().map( function ( menuItem ) {
      return menuItem.getData();
    } );
  }
  return this.allowedValues.concat( menuDatas );
};

/**
 * SelectFileWidgets allow for selecting files, using the HTML5 File API. These
 * widgets can be configured with {@link OO.ui.mixin.IconElement icons}, {@link
 * OO.ui.mixin.IndicatorElement indicators} and {@link OO.ui.mixin.TitledElement titles}.
 * Please see the [OOUI documentation on MediaWiki] [1] for more information and examples.
 *
 * Although SelectFileWidget inherits from SelectFileInputWidget, it does not
 * behave as an InputWidget, and can't be used in HTML forms.
 *
 *     @example
 *     // A file select widget.
 *     var selectFile = new OO.ui.SelectFileWidget();
 *     $( document.body ).append( selectFile.$element );
 *
 * [1]: https://www.mediawiki.org/wiki/OOUI/Widgets
 *
 * @class
 * @extends OO.ui.SelectFileInputWidget
 * @mixins OO.ui.mixin.PendingElement
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string} [notsupported] Text to display when file support is missing in the browser.
 * @cfg {boolean} [droppable=true] Whether to accept files by drag and drop.
 * @cfg {boolean} [buttonOnly=false] Show only the select file button, no info field. Requires
 *  showDropTarget to be false.
 * @cfg {boolean} [showDropTarget=false] Whether to show a drop target. Requires droppable to be
 *  true. Not yet supported in multiple file mode.
 * @cfg {number} [thumbnailSizeLimit=20] File size limit in MiB above which to not try and show a
 *  preview (for performance).
 */
OO.ui.SelectFileWidget = function OoUiSelectFileWidget( config ) {
  var dragHandler, droppable,
    isSupported = this.constructor.static.isSupported();

  // Configuration initialization
  config = $.extend( {
    notsupported: OO.ui.msg( 'ooui-selectfile-not-supported' ),
    droppable: true,
    buttonOnly: false,
    showDropTarget: false,
    thumbnailSizeLimit: 20
  }, config );

  if ( !isSupported ) {
    config.disabled = true;
  }

  // Parent constructor
  OO.ui.SelectFileWidget.super.call( this, config );

  // Mixin constructors
  OO.ui.mixin.PendingElement.call( this );

  if ( !isSupported ) {
    this.info.setValue( config.notsupported );
  }

  // Properties
  droppable = config.droppable && isSupported;
  // TODO: Support drop target when multiple is set
  this.showDropTarget = droppable && config.showDropTarget && !this.multiple;
  this.thumbnailSizeLimit = config.thumbnailSizeLimit;

  // Initialization
  if ( this.showDropTarget ) {
    this.selectButton.setIcon( 'upload' );
    this.$thumbnail = $( '<div>' ).addClass( 'oo-ui-selectFileWidget-thumbnail' );
    this.setPendingElement( this.$thumbnail );
    this.$element
      .addClass( 'oo-ui-selectFileWidget-dropTarget' )
      .on( {
        click: this.onDropTargetClick.bind( this )
      } )
      .append(
        this.$thumbnail,
        this.info.$element,
        this.selectButton.$element,
        $( '<span>' )
          .addClass( 'oo-ui-selectFileWidget-dropLabel' )
          .text( OO.ui.msg( 'ooui-selectfile-dragdrop-placeholder' ) )
      );
    this.fieldLayout.$element.remove();
  } else if ( config.buttonOnly ) {
    // Copy over any classes that may have been added already.
    // Ensure no events are bound to this.$element before here.
    this.selectButton.$element
      .addClass( this.$element.attr( 'class' ) )
      .addClass( 'oo-ui-selectFileWidget-buttonOnly' );
    // Set this.$element to just be the button
    this.$element = this.selectButton.$element;
  }

  // Events
  if ( droppable ) {
    dragHandler = this.onDragEnterOrOver.bind( this );
    this.$element.on( {
      dragenter: dragHandler,
      dragover: dragHandler,
      dragleave: this.onDragLeave.bind( this ),
      drop: this.onDrop.bind( this )
    } );
  }

  this.$input
    .on( 'click', function ( e ) {
      // Prevents dropTarget to get clicked which calls
      // a click on this input
      e.stopPropagation();
    } );

  this.$element.addClass( 'oo-ui-selectFileWidget' );

  this.updateUI();
};

/* Setup */

OO.inheritClass( OO.ui.SelectFileWidget, OO.ui.SelectFileInputWidget );
OO.mixinClass( OO.ui.SelectFileWidget, OO.ui.mixin.PendingElement );

/* Static Properties */

/**
 * Check if this widget is supported
 *
 * @static
 * @return {boolean}
 */
OO.ui.SelectFileWidget.static.isSupported = function () {
  var $input;
  if ( OO.ui.SelectFileWidget.static.isSupportedCache === null ) {
    $input = $( '<input>' ).attr( 'type', 'file' );
    OO.ui.SelectFileWidget.static.isSupportedCache = $input[ 0 ].files !== undefined;
  }
  return OO.ui.SelectFileWidget.static.isSupportedCache;
};

OO.ui.SelectFileWidget.static.isSupportedCache = null;

/* Events */

/**
 * @event change
 *
 * A change event is emitted when the on/off state of the toggle changes.
 *
 * @param {File|null} value New value
 */

/* Methods */

/**
 * Get the current value of the field
 *
 * For single file widgets returns a File or null.
 * For multiple file widgets returns a list of Files.
 *
 * @return {File|File[]|null}
 */
OO.ui.SelectFileWidget.prototype.getValue = function () {
  return this.multiple ? this.currentFiles : this.currentFiles[ 0 ];
};

/**
 * Set the current value of the field
 *
 * @param {File[]|null} files Files to select
 */
OO.ui.SelectFileWidget.prototype.setValue = function ( files ) {
  if ( files && !this.multiple ) {
    files = files.slice( 0, 1 );
  }

  function comparableFile( file ) {
    // Use extend to convert to plain objects so they can be compared.
    return $.extend( {}, file );
  }

  if ( !OO.compare(
    files && files.map( comparableFile ),
    this.currentFiles && this.currentFiles.map( comparableFile )
  ) ) {
    this.currentFiles = files || [];
    this.emit( 'change', this.currentFiles );
  }
};

/**
 * @inheritdoc
 */
OO.ui.SelectFileWidget.prototype.getFilename = function () {
  return this.currentFiles.map( function ( file ) {
    return file.name;
  } ).join( ', ' );
};

/**
 * Disable InputWidget#onEdit listener, onFileSelected is used instead.
 *
 * @inheritdoc
 */
OO.ui.SelectFileWidget.prototype.onEdit = function () {};

/**
 * @inheritdoc
 */
OO.ui.SelectFileWidget.prototype.updateUI = function () {
  // Too early, or not supported
  if ( !this.selectButton || !this.constructor.static.isSupported() ) {
    return;
  }

  // Parent method
  OO.ui.SelectFileWidget.super.prototype.updateUI.call( this );

  if ( this.currentFiles.length ) {
    this.$element.removeClass( 'oo-ui-selectFileInputWidget-empty' );

    if ( this.showDropTarget ) {
      this.pushPending();
      this.loadAndGetImageUrl( this.currentFiles[ 0 ] ).done( function ( url ) {
        this.$thumbnail.css( 'background-image', 'url( ' + url + ' )' );
      }.bind( this ) ).fail( function () {
        this.$thumbnail.append(
          new OO.ui.IconWidget( {
            icon: 'attachment',
            classes: [ 'oo-ui-selectFileWidget-noThumbnail-icon' ]
          } ).$element
        );
      }.bind( this ) ).always( function () {
        this.popPending();
      }.bind( this ) );
      this.$element.off( 'click' );
    }
  } else {
    if ( this.showDropTarget ) {
      this.$element.off( 'click' );
      this.$element.on( {
        click: this.onDropTargetClick.bind( this )
      } );
      this.$thumbnail
        .empty()
        .css( 'background-image', '' );
    }
    this.$element.addClass( 'oo-ui-selectFileInputWidget-empty' );
  }
};

/**
 * If the selected file is an image, get its URL and load it.
 *
 * @param {File} file File
 * @return {jQuery.Promise} Promise resolves with the image URL after it has loaded
 */
OO.ui.SelectFileWidget.prototype.loadAndGetImageUrl = function ( file ) {
  var deferred = $.Deferred(),
    reader = new FileReader();

  if (
    ( OO.getProp( file, 'type' ) || '' ).indexOf( 'image/' ) === 0 &&
    file.size < this.thumbnailSizeLimit * 1024 * 1024
  ) {
    reader.onload = function ( event ) {
      var img = document.createElement( 'img' );
      img.addEventListener( 'load', function () {
        if (
          img.naturalWidth === 0 ||
          img.naturalHeight === 0 ||
          img.complete === false
        ) {
          deferred.reject();
        } else {
          deferred.resolve( event.target.result );
        }
      } );
      img.src = event.target.result;
    };
    reader.readAsDataURL( file );
  } else {
    deferred.reject();
  }

  return deferred.promise();
};

/**
 * @inheritdoc
 */
OO.ui.SelectFileWidget.prototype.onFileSelected = function ( e ) {
  var files;

  if ( this.inputClearing ) {
    return;
  }

  files = this.filterFiles( e.target.files || [] );

  // After a file is selected clear the native widget to avoid confusion
  this.inputClearing = true;
  this.$input[ 0 ].value = '';
  this.inputClearing = false;

  this.setValue( files );
};

/**
 * Handle drop target click events.
 *
 * @private
 * @param {jQuery.Event} e Key press event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.SelectFileWidget.prototype.onDropTargetClick = function () {
  if ( !this.isDisabled() && this.$input ) {
    this.$input.trigger( 'click' );
    return false;
  }
};

/**
 * Handle drag enter and over events
 *
 * @private
 * @param {jQuery.Event} e Drag event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.SelectFileWidget.prototype.onDragEnterOrOver = function ( e ) {
  var itemsOrFiles,
    hasDroppableFile = false,
    dt = e.originalEvent.dataTransfer;

  e.preventDefault();
  e.stopPropagation();

  if ( this.isDisabled() ) {
    this.$element.removeClass( 'oo-ui-selectFileWidget-canDrop' );
    dt.dropEffect = 'none';
    return false;
  }

  // DataTransferItem and File both have a type property, but in Chrome files
  // have no information at this point.
  itemsOrFiles = dt.items || dt.files;
  if ( itemsOrFiles && itemsOrFiles.length ) {
    if ( this.filterFiles( itemsOrFiles ).length ) {
      hasDroppableFile = true;
    }
  // dt.types is Array-like, but not an Array
  } else if ( Array.prototype.indexOf.call( OO.getProp( dt, 'types' ) || [], 'Files' ) !== -1 ) {
    // File information is not available at this point for security so just assume
    // it is acceptable for now.
    // https://bugzilla.mozilla.org/show_bug.cgi?id=640534
    hasDroppableFile = true;
  }

  this.$element.toggleClass( 'oo-ui-selectFileWidget-canDrop', hasDroppableFile );
  if ( !hasDroppableFile ) {
    dt.dropEffect = 'none';
  }

  return false;
};

/**
 * Handle drag leave events
 *
 * @private
 * @param {jQuery.Event} e Drag event
 */
OO.ui.SelectFileWidget.prototype.onDragLeave = function () {
  this.$element.removeClass( 'oo-ui-selectFileWidget-canDrop' );
};

/**
 * Handle drop events
 *
 * @private
 * @param {jQuery.Event} e Drop event
 * @return {undefined|boolean} False to prevent default if event is handled
 */
OO.ui.SelectFileWidget.prototype.onDrop = function ( e ) {
  var files,
    dt = e.originalEvent.dataTransfer;

  e.preventDefault();
  e.stopPropagation();
  this.$element.removeClass( 'oo-ui-selectFileWidget-canDrop' );

  if ( this.isDisabled() ) {
    return false;
  }

  files = this.filterFiles( dt.files || [] );
  this.setValue( files );

  return false;
};

/**
 * @inheritdoc
 */
OO.ui.SelectFileWidget.prototype.setDisabled = function ( disabled ) {
  disabled = disabled || !this.constructor.static.isSupported();

  // Parent method
  OO.ui.SelectFileWidget.super.prototype.setDisabled.call( this, disabled );
};

/**
 * SearchWidgets combine a {@link OO.ui.TextInputWidget text input field},
 * where users can type a search query, and a menu of search results,
 * which is displayed beneath the query field.
 * Unlike {@link OO.ui.mixin.LookupElement lookup menus}, search result menus are always visible
 * to the user. Users can choose an item from the menu or type a query into the text field to
 * search for a matching result item.
 * In general, search widgets are used inside a separate {@link OO.ui.Dialog dialog} window.
 *
 * Each time the query is changed, the search result menu is cleared and repopulated. Please see
 * the [OOUI demos][1] for an example.
 *
 * [1]: https://doc.wikimedia.org/oojs-ui/master/demos/#SearchInputWidget-type-search
 *
 * @class
 * @extends OO.ui.Widget
 *
 * @constructor
 * @param {Object} [config] Configuration options
 * @cfg {string|jQuery} [placeholder] Placeholder text for query input
 * @cfg {string} [value] Initial query value
 * @cfg {OO.ui.InputWidget} [input] {@link OO.ui.InputWidget Input widget} for search. Defaults
 *  to a {@link OO.ui.SearchInputWidget search input widget} if not provided.
 */
OO.ui.SearchWidget = function OoUiSearchWidget( config ) {
  // Configuration initialization
  config = config || {};

  // Parent constructor
  OO.ui.SearchWidget.super.call( this, config );

  // Properties
  this.query = config.input || new OO.ui.SearchInputWidget( {
    placeholder: config.placeholder,
    value: config.value
  } );
  this.results = new OO.ui.SelectWidget();
  this.results.setFocusOwner( this.query.$input );
  this.$query = $( '<div>' );
  this.$results = $( '<div>' );

  // Events
  this.query.connect( this, {
    change: 'onQueryChange',
    enter: 'onQueryEnter'
  } );
  this.query.$input.on( 'keydown', this.onQueryKeydown.bind( this ) );

  // Initialization
  this.$query
    .addClass( 'oo-ui-searchWidget-query' )
    .append( this.query.$element );
  this.$results
    .addClass( 'oo-ui-searchWidget-results' )
    .append( this.results.$element );
  this.$element
    .addClass( 'oo-ui-searchWidget' )
    .append( this.$results, this.$query );
};

/* Setup */

OO.inheritClass( OO.ui.SearchWidget, OO.ui.Widget );

/* Methods */

/**
 * Handle query key down events.
 *
 * @private
 * @param {jQuery.Event} e Key down event
 */
OO.ui.SearchWidget.prototype.onQueryKeydown = function ( e ) {
  var highlightedItem, nextItem,
    dir = e.which === OO.ui.Keys.DOWN ? 1 : ( e.which === OO.ui.Keys.UP ? -1 : 0 );

  if ( dir ) {
    highlightedItem = this.results.findHighlightedItem();
    if ( !highlightedItem ) {
      highlightedItem = this.results.findSelectedItem();
    }
    nextItem = this.results.findRelativeSelectableItem( highlightedItem, dir );
    this.results.highlightItem( nextItem );
    nextItem.scrollElementIntoView();
  }
};

/**
 * Handle select widget select events.
 *
 * Clears existing results. Subclasses should repopulate items according to new query.
 *
 * @private
 * @param {string} value New value
 */
OO.ui.SearchWidget.prototype.onQueryChange = function () {
  // Reset
  this.results.clearItems();
};

/**
 * Handle select widget enter key events.
 *
 * Chooses highlighted item.
 *
 * @private
 * @param {string} value New value
 */
OO.ui.SearchWidget.prototype.onQueryEnter = function () {
  var highlightedItem = this.results.findHighlightedItem();
  if ( highlightedItem ) {
    this.results.chooseItem( highlightedItem );
  }
};

/**
 * Get the query input.
 *
 * @return {OO.ui.TextInputWidget} Query input
 */
OO.ui.SearchWidget.prototype.getQuery = function () {
  return this.query;
};

/**
 * Get the search results menu.
 *
 * @return {OO.ui.SelectWidget} Menu of search results
 */
OO.ui.SearchWidget.prototype.getResults = function () {
  return this.results;
};

}( OO ) );

//# sourceMappingURL=oojs-ui-widgets.js.map.json
var popup = new OO.ui.PopupWidget( {
    $content: $( '<p>Hi there!</p>' ),
    padded: true,
    width: 300
  } );

$( document.body ).append( popup.$element );

  </script>
</body>
</html>